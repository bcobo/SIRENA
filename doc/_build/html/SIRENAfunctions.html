
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>SIRENA functions &#8212; SIRENA 4.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="_static/_themes/themes_overrides.css" />
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="References" href="zreferences.html" />
    <link rel="prev" title="SIRENA Tools CLI" href="SIRENAcommandline.html" /> 
  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="index.html"><img src="_static/SIRENA_black.png" border="0" alt="py4sci"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="zreferences.html" title="References"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="SIRENAcommandline.html" title="SIRENA Tools CLI"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>

        <li class="nav-item nav-item-this"><a href="">SIRENA functions</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/SIRENA_black.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="SIRENAcommandline.html"
                        title="previous chapter">SIRENA Tools CLI</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="zreferences.html"
                        title="next chapter">References</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/SIRENAfunctions.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="functions"></span><section id="sirena-functions">
<h1>SIRENA functions<a class="headerlink" href="#sirena-functions" title="Permalink to this headline">¶</a></h1>
<table class="docutils align-default">
<colgroup>
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#a"><span class="std std-ref">A</span></a></p></td>
<td><p><a class="reference internal" href="#b"><span class="std std-ref">B</span></a></p></td>
<td><p><a class="reference internal" href="#c"><span class="std std-ref">C</span></a></p></td>
<td><p><a class="reference internal" href="#d"><span class="std std-ref">D</span></a></p></td>
<td><p><a class="reference internal" href="#e"><span class="std std-ref">E</span></a></p></td>
<td><p><a class="reference internal" href="#f"><span class="std std-ref">F</span></a></p></td>
<td><p><a class="reference internal" href="#g"><span class="std std-ref">G</span></a></p></td>
<td><p><a class="reference internal" href="#h"><span class="std std-ref">H</span></a></p></td>
<td><p><a class="reference internal" href="#i"><span class="std std-ref">I</span></a></p></td>
<td><p><a class="reference internal" href="#j"><span class="std std-ref">J</span></a></p></td>
<td><p><a class="reference internal" href="#k"><span class="std std-ref">K</span></a></p></td>
<td><p><a class="reference internal" href="#l"><span class="std std-ref">L</span></a></p></td>
<td><p><a class="reference internal" href="#m"><span class="std std-ref">M</span></a></p></td>
<td><p><a class="reference internal" href="#n"><span class="std std-ref">N</span></a></p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#o"><span class="std std-ref">O</span></a></p></td>
<td><p><a class="reference internal" href="#p"><span class="std std-ref">P</span></a></p></td>
<td><p><a class="reference internal" href="#q"><span class="std std-ref">Q</span></a></p></td>
<td><p><a class="reference internal" href="#r"><span class="std std-ref">R</span></a></p></td>
<td><p><a class="reference internal" href="#s"><span class="std std-ref">S</span></a></p></td>
<td><p><a class="reference internal" href="#t"><span class="std std-ref">T</span></a></p></td>
<td><p><a class="reference internal" href="#u"><span class="std std-ref">U</span></a></p></td>
<td><p><a class="reference internal" href="#v"><span class="std std-ref">V</span></a></p></td>
<td><p><a class="reference internal" href="#w"><span class="std std-ref">W</span></a></p></td>
<td><p><a class="reference internal" href="#x"><span class="std std-ref">X</span></a></p></td>
<td><p><a class="reference internal" href="#y"><span class="std std-ref">Y</span></a></p></td>
<td><p><a class="reference internal" href="#z"><span class="std std-ref">Z</span></a></p></td>
</tr>
</tbody>
</table>
<p>Search functions by name at <a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a>.</p>
<span class="target" id="a"></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411addFirstRowP21ReconstructInitSIRENAPP8fitsfilediP10gsl_vectorP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrix">
<span id="_CPPv311addFirstRowP21ReconstructInitSIRENAPP8fitsfilediP10gsl_vectorP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrix"></span><span id="_CPPv211addFirstRowP21ReconstructInitSIRENAPP8fitsfilediP10gsl_vectorP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrix"></span><span id="addFirstRow__ReconstructInitSIRENAP.fitsfilePP.double.i.gsl_vectorP.gsl_vectorP.gsl_matrixP.gsl_matrixP.gsl_matrixP.gsl_matrixP.gsl_matrixP.gsl_matrixP.gsl_matrixP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">addFirstRow</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="n"><span class="pre">fitsfile</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">inLibObject</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samprate</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">runF0orB0val</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">E</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">PHEIGHT</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">PULSE</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">PULSEB0</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">MF</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">MFB0</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">COVAR</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">WEIGHT</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">PULSEMaxLengthFixedFilter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411addFirstRowP21ReconstructInitSIRENAPP8fitsfilediP10gsl_vectorP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrix" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function writes the first row of the library (without intermediate AB-related values, because it would be necessary to have at least two rows=energies in the library). It also writes the <em>FIXFILTT</em> and <em>FIXFILTF</em> HDUs with the optimal filters in the time and frequency domain with fixed legnths (base-2 values) and the <em>PRCLOFWM</em> HDU with the precalculated values for optimal filtering and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>WEIGHTM</strong>.</p>
<ul class="simple">
<li><p>Declare variables</p></li>
<li><p>Write in the first row of the library FITS file some columns with the info provided by the input GSL vectors <a class="reference internal" href="#_CPPv411addFirstRowP21ReconstructInitSIRENAPP8fitsfilediP10gsl_vectorP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrix" title="addFirstRow::E"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">E</span></code></a>, <a class="reference internal" href="#_CPPv411addFirstRowP21ReconstructInitSIRENAPP8fitsfilediP10gsl_vectorP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrix" title="addFirstRow::PHEIGHT"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">PHEIGHT</span></code></a>, <a class="reference internal" href="#_CPPv411addFirstRowP21ReconstructInitSIRENAPP8fitsfilediP10gsl_vectorP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrix" title="addFirstRow::PULSE"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">PULSE</span></code></a>, <a class="reference internal" href="#_CPPv411addFirstRowP21ReconstructInitSIRENAPP8fitsfilediP10gsl_vectorP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrix" title="addFirstRow::PULSEB0"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">PULSEB0</span></code></a>,             <a class="reference internal" href="#_CPPv411addFirstRowP21ReconstructInitSIRENAPP8fitsfilediP10gsl_vectorP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrix" title="addFirstRow::MF"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">MF</span></code></a> and <a class="reference internal" href="#_CPPv411addFirstRowP21ReconstructInitSIRENAPP8fitsfilediP10gsl_vectorP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrix" title="addFirstRow::MFB0"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">MFB0</span></code></a> (and <a class="reference internal" href="#_CPPv411addFirstRowP21ReconstructInitSIRENAPP8fitsfilediP10gsl_vectorP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrix" title="addFirstRow::COVAR"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">COVAR</span></code></a> and <a class="reference internal" href="#_CPPv411addFirstRowP21ReconstructInitSIRENAPP8fitsfilediP10gsl_vectorP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrix" title="addFirstRow::WEIGHT"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">WEIGHT</span></code></a> if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRCLOFWM"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRCLOFWM</span></code></a> = yes) (and <a class="reference internal" href="#_CPPv411addFirstRowP21ReconstructInitSIRENAPP8fitsfilediP10gsl_vectorP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrix" title="addFirstRow::PULSEMaxLengthFixedFilter"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">PULSEMaxLengthFixedFilter</span></code></a> if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a> &gt; <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLengthNotPadded"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLengthNotPadded</span></code></a>, in general being <code class="xref std std-option docutils literal notranslate"><span class="pre">OFLengthNotPadded`=:option:`OFLength</span></code>)</p></li>
<li><p>Writing HDUs with fixed filters in time (<em>FIXFILTT</em>) and frequency (<em>FIXFILTF</em>), <strong>Tx</strong> and <strong>Fx</strong> columns respectively (calculating the optimal filters, <a class="reference internal" href="#_CPPv422calculus_optimalFilteriiiP10gsl_vectorldiP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP18gsl_vector_complex" title="calculus_optimalFilter"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">calculus_optimalFilter()</span></code></a>).
In time domain <strong>Tx</strong> columns are real numbers but in frequency domain <strong>Fx</strong> columns are complex numbers (so real parts are written in the first half of the column and imaginary parts in the second one)</p></li>
<li><p>Calculate and write the pre-calculated values by using the noise weight matrix from noise intervals (M’WM)^{-1}M’W for different lengths, <strong>OFWx</strong> columns in <em>PRCLOFWM</em></p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>fitsfile** <strong>inLibObject</strong></p>
<blockquote>
<div><p>FITS object containing information of the library FITS file</p>
</div></blockquote>
<p>double <strong>samprate</strong></p>
<blockquote>
<div><p>Sampling rate</p>
</div></blockquote>
<p>int <strong>runF0orB0val</strong></p>
<blockquote>
<div><p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterMethod"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterMethod</span></code></a> = <strong>F0</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv411addFirstRowP21ReconstructInitSIRENAPP8fitsfilediP10gsl_vectorP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrix" title="addFirstRow::runF0orB0val"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">runF0orB0val</span></code></a> = 1. If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterMethod"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterMethod</span></code></a> = <strong>B0</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv411addFirstRowP21ReconstructInitSIRENAPP8fitsfilediP10gsl_vectorP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrix" title="addFirstRow::runF0orB0val"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">runF0orB0val</span></code></a> = 0</p>
</div></blockquote>
<p>gsl_vector* <strong>E</strong></p>
<blockquote>
<div><p>First energy to be included in the library</p>
</div></blockquote>
<p>gsl_vector* <strong>PHEIGHT</strong></p>
<blockquote>
<div><p>Pulse height associated to the first energy to be included in the library</p>
</div></blockquote>
<p>gsl_matrix* <strong>PULSE</strong></p>
<blockquote>
<div><p>Pulse template associated to the first energy to be included in the library</p>
</div></blockquote>
<p>gsl_matrix* <strong>PULSEB0</strong></p>
<blockquote>
<div><p>Pulse template without baseline associated to the first energy to be included in the library</p>
</div></blockquote>
<p>gsl_matrix* <strong>MF</strong></p>
<blockquote>
<div><p>Matched filter associated to the first energy to be included in the library</p>
</div></blockquote>
<p>gsl_matrix* <strong>MFB0</strong></p>
<blockquote>
<div><p>Matched filter (baseline subtracted) associated to the first energy to be included in the library</p>
</div></blockquote>
<p>gsl_matrix* <strong>COVAR</strong></p>
<blockquote>
<div><p>Covariance matrix associated to the first energy to be included in the library</p>
</div></blockquote>
<p>gsl_matrix* <strong>WEIGHT</strong></p>
<blockquote>
<div><p>Weight matrix associated to the first energy to be included in the library</p>
</div></blockquote>
<p>gsl_matrix* <strong>PULSEMaxLengthFixedFilter</strong></p>
<blockquote>
<div><p>Pulse template whose length is <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a> associated to the first energy to be included in the library</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv45aligndPP10gsl_vectorPP10gsl_vector">
<span id="_CPPv35aligndPP10gsl_vectorPP10gsl_vector"></span><span id="_CPPv25aligndPP10gsl_vectorPP10gsl_vector"></span><span id="align__double.gsl_vectorPP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">align</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samprate</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vector1</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vector2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv45aligndPP10gsl_vectorPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>Based on <span id="id1">[<a class="reference internal" href="zreferences.html#id15" title="R. GilPita and others. Improving alignment of noisy signals using an iterative zero phase method. In European Signal Processing Conference 2005, volume 475 of EURASIP Proceedings. 2005. EURASIP. URL: http://www.eurasip.org/Proceedings/Eusipco/Eusipco2005/defevent/papers/cr1492.pdf.">GilPita+05</a>]</span></p>
<p>This function aligns <a class="reference internal" href="#_CPPv45aligndPP10gsl_vectorPP10gsl_vector" title="align::vector1"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vector1</span></code></a> with <a class="reference internal" href="#_CPPv45aligndPP10gsl_vectorPP10gsl_vector" title="align::vector2"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vector2</span></code></a> (by delaying or moving forward <a class="reference internal" href="#_CPPv45aligndPP10gsl_vectorPP10gsl_vector" title="align::vector2"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vector2</span></code></a>) assuming that <a class="reference internal" href="#_CPPv45aligndPP10gsl_vectorPP10gsl_vector" title="align::vector1"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vector1</span></code></a> and <a class="reference internal" href="#_CPPv45aligndPP10gsl_vectorPP10gsl_vector" title="align::vector2"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vector2</span></code></a> are shifted replicas of the same function.</p>
<p>From the discrete function <img class="math" src="_images/math/949050832afa80f0e137525c0ad2fef420a0ef86.png" alt="x[n] (n=0,...,N-1,N)"/> and according to the time shifting property of the Fourier transform:</p>
<div class="math">
<p><img src="_images/math/d87fbdc8e3bf353ed40f90fbcbf9cc99d967f8e2.png" alt="&amp; x[n]    &lt;------&gt; X[f]\\
&amp; x[n-m]  &lt;------&gt; X[f] exp(-j2\cdot\pi\cdot m/N)"/></p>
</div><p>If <img class="math" src="_images/math/c8412c98da077f2def6a8ae92d9eee0b008201eb.png" alt="\mathit{Shift} = m"/> then <img class="math" src="_images/math/92463392b438a5cc3227615318f0ecf50e0fbc8d.png" alt="\mathit{PhaseDueToTheShift}= 2\pi m/N"/> and thus, <img class="math" src="_images/math/a506fd91f64c329e151a2a2fd2ad017357506e73.png" alt="m = \mathit{PhaseDueToTheShift}\cdot N/(2\pi)"/></p>
<ol class="arabic simple">
<li><p>Declare variables</p></li>
<li><p>FFT of <a class="reference internal" href="#_CPPv45aligndPP10gsl_vectorPP10gsl_vector" title="align::vector1"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vector1</span></code></a></p></li>
<li><p>FFT of <a class="reference internal" href="#_CPPv45aligndPP10gsl_vectorPP10gsl_vector" title="align::vector2"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vector2</span></code></a></p></li>
<li><p>(Phases of the <em>FFT_vector1</em> and <em>FFT_vector2</em>) <img class="math" src="_images/math/d734a3d6609fa58b0098bdfebbc243230724d431.png" alt="*size/(2\pi)"/></p></li>
<li><p>Shift between the input vectors</p></li>
<li><p><em>shiftdouble</em> into <em>shiftint</em> (because we are working with samples)</p></li>
<li><p>Move forward or delay <a class="reference internal" href="#_CPPv45aligndPP10gsl_vectorPP10gsl_vector" title="align::vector1"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vector1</span></code></a> depending on positive or negative shift</p></li>
</ol>
<p><strong>Members/Variables</strong></p>
<p>double <strong>samprate</strong></p>
<blockquote>
<div><p>Sampling rate</p>
</div></blockquote>
<p>gsl_vector** <strong>vector1</strong></p>
<blockquote>
<div><p>GSL vector with input vector</p>
</div></blockquote>
<p>gsl_vector** <strong>vector2</strong></p>
<blockquote>
<div><p>GSL with input vector which is delayed or moved forward to be aligned with <a class="reference internal" href="#_CPPv45aligndPP10gsl_vectorPP10gsl_vector" title="align::vector1"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vector1</span></code></a></p>
</div></blockquote>
</dd></dl>

<span class="target" id="c"><span id="b"></span></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415calculateEnergyP10gsl_vectoriP10gsl_vectorP18gsl_vector_complexiiiP21ReconstructInitSIRENAidP10gsl_vectorP10gsl_matrixP10gsl_matrixPdiPdii">
<span id="_CPPv315calculateEnergyP10gsl_vectoriP10gsl_vectorP18gsl_vector_complexiiiP21ReconstructInitSIRENAidP10gsl_vectorP10gsl_matrixP10gsl_matrixPdiPdii"></span><span id="_CPPv215calculateEnergyP10gsl_vectoriP10gsl_vectorP18gsl_vector_complexiiiP21ReconstructInitSIRENAidP10gsl_vectorP10gsl_matrixP10gsl_matrixPdiPdii"></span><span id="calculateEnergy__gsl_vectorP.i.gsl_vectorP.gsl_vector_complexP.i.i.i.ReconstructInitSIRENAP.i.double.gsl_vectorP.gsl_matrixP.gsl_matrixP.doubleP.i.doubleP.i.i"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">calculateEnergy</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vector</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pulseGrade</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">filter</span></span>, <span class="n"><span class="pre">gsl_vector_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">filterFFT</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">runEMethod</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">indexEalpha</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">indexEbeta</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">domain</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samprate</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">Pab</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">PRCLWN</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">PRCLOFWM</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">calculatedEnergy</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">numlags</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tstartNewDev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">productSize</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">tooshortPulse_NoLags</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415calculateEnergyP10gsl_vectoriP10gsl_vectorP18gsl_vector_complexiiiP21ReconstructInitSIRENAidP10gsl_vectorP10gsl_matrixP10gsl_matrixPdiPdii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function calculates the energy of a pulse (<a class="reference internal" href="#_CPPv415calculateEnergyP10gsl_vectoriP10gsl_vectorP18gsl_vector_complexiiiP21ReconstructInitSIRENAidP10gsl_vectorP10gsl_matrixP10gsl_matrixPdiPdii" title="calculateEnergy::vector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vector</span></code></a>) depending on the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a>, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFNoise"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFNoise</span></code></a>, and the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterDomain"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterDomain</span></code></a> selected from input parameters.</p>
<ol class="loweralpha simple">
<li><p><strong>OPTFILT</strong> and <strong>NSD</strong> (= <strong>I2R</strong> or <strong>I2RFITTED</strong>): Optimal filter = Wiener filter  (see <a class="reference internal" href="SIRENA_preBuffer.html#optimalfilter-nsd"><span class="std std-ref">Optimal Filtering by using the noise spectral density</span></a>)</p></li>
</ol>
<p>Once the filter template has been created (<a class="reference internal" href="#_CPPv415calculateEnergyP10gsl_vectoriP10gsl_vectorP18gsl_vector_complexiiiP21ReconstructInitSIRENAidP10gsl_vectorP10gsl_matrixP10gsl_matrixPdiPdii" title="calculateEnergy::filter"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">filter</span></code></a> or <a class="reference internal" href="#_CPPv415calculateEnergyP10gsl_vectoriP10gsl_vectorP18gsl_vector_complexiiiP21ReconstructInitSIRENAidP10gsl_vectorP10gsl_matrixP10gsl_matrixPdiPdii" title="calculateEnergy::filterFFT"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">filterFFT</span></code></a>), pulse height analysis is performed by aligning the template with a pulse and multiplying each point in the template by the corresponding point in the pulse. The sum of these products is the energy.</p>
<p>In the practice, the alignment of the pulse relative to the trigger is not completely accurate, so a number of <em>n</em> lags could be used in order to find the peak value of the energy. The <em>n</em> peak values are fitted to a parabola to find the most accurate energy (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-LagsOrNot"><code class="xref std std-option docutils literal notranslate"><span class="pre">LagsOrNot</span></code></a>) and a corrected starting time.</p>
<ol class="loweralpha simple">
<li><p><strong>OPTFILT</strong> and <strong>WEIGHTM</strong> (= <strong>I2R</strong> or <strong>I2RFITTED</strong>) (see <a class="reference internal" href="SIRENA_preBuffer.html#optimalfilter-weightm"><span class="std std-ref">Optimal Filtering by using the noise weight matrix from noise intervals</span></a>)</p></li>
</ol>
<ol class="loweralpha simple" start="3">
<li><p><strong>WEIGHT</strong> and <strong>WEIGHTN</strong> (see <a class="reference internal" href="SIRENA_preBuffer.html#covmatrices"><span class="std std-ref">Covariance matrices</span></a>)</p></li>
</ol>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>vector</strong></p>
<blockquote>
<div><p>Pulse whose energy has to be determined</p>
</div></blockquote>
<p>int <strong>pulseGrade</strong></p>
<blockquote>
<div><p>Grade of the input pulse (to decide whether a full or only a rough estimation of energy is required).</p>
</div></blockquote>
<p>gsl_vector* <strong>filter</strong></p>
<blockquote>
<div><p>Optimal filter in time domain</p>
</div></blockquote>
<p>gsl_vector_complex* <strong>filterFFT</strong></p>
<blockquote>
<div><p>Optimal filter in frequency domain</p>
</div></blockquote>
<p>int <strong>runEMethod</strong></p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>OPTFILT</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv415calculateEnergyP10gsl_vectoriP10gsl_vectorP18gsl_vector_complexiiiP21ReconstructInitSIRENAidP10gsl_vectorP10gsl_matrixP10gsl_matrixPdiPdii" title="calculateEnergy::runEMethod"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">runEMethod</span></code></a> = 0</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>I2R</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv415calculateEnergyP10gsl_vectoriP10gsl_vectorP18gsl_vector_complexiiiP21ReconstructInitSIRENAidP10gsl_vectorP10gsl_matrixP10gsl_matrixPdiPdii" title="calculateEnergy::runEMethod"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">runEMethod</span></code></a> = 0</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>I2RFITTED</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv415calculateEnergyP10gsl_vectoriP10gsl_vectorP18gsl_vector_complexiiiP21ReconstructInitSIRENAidP10gsl_vectorP10gsl_matrixP10gsl_matrixPdiPdii" title="calculateEnergy::runEMethod"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">runEMethod</span></code></a> = 0</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>WEIGHT</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv415calculateEnergyP10gsl_vectoriP10gsl_vectorP18gsl_vector_complexiiiP21ReconstructInitSIRENAidP10gsl_vectorP10gsl_matrixP10gsl_matrixPdiPdii" title="calculateEnergy::runEMethod"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">runEMethod</span></code></a> = 1</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>WEIGHTN</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv415calculateEnergyP10gsl_vectoriP10gsl_vectorP18gsl_vector_complexiiiP21ReconstructInitSIRENAidP10gsl_vectorP10gsl_matrixP10gsl_matrixPdiPdii" title="calculateEnergy::runEMethod"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">runEMethod</span></code></a> = 2</p></li>
</ul>
</div></blockquote>
<p>int <strong>indexEalpha</strong></p>
<blockquote>
<div><p>Index of the energy lower than the energy of the pulse which is being analyzed</p>
</div></blockquote>
<p>int <strong>indexEbeta</strong></p>
<blockquote>
<div><p>Index of the energy higher than the energy of the pulse which is being analyzed</p>
</div></blockquote>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values)</p>
</div></blockquote>
<p>int <strong>domain</strong></p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterDomain"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterDomain</span></code></a> = <strong>T</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv415calculateEnergyP10gsl_vectoriP10gsl_vectorP18gsl_vector_complexiiiP21ReconstructInitSIRENAidP10gsl_vectorP10gsl_matrixP10gsl_matrixPdiPdii" title="calculateEnergy::domain"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">domain</span></code></a> = 0</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterDomain"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterDomain</span></code></a> = <strong>F</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv415calculateEnergyP10gsl_vectoriP10gsl_vectorP18gsl_vector_complexiiiP21ReconstructInitSIRENAidP10gsl_vectorP10gsl_matrixP10gsl_matrixPdiPdii" title="calculateEnergy::domain"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">domain</span></code></a> = 1</p></li>
</ul>
</div></blockquote>
<p>double <strong>samprate</strong></p>
<blockquote>
<div><p>Sampling rate in Hz</p>
</div></blockquote>
<p>gsl_vector* <strong>Pab</strong></p>
<blockquote>
<div><p><strong>PAB</strong> column in the library</p>
</div></blockquote>
<p>gsl_vector* <strong>PRCLWN</strong></p>
<blockquote>
<div><p><strong>PCLx</strong> column in the library</p>
</div></blockquote>
<p>gsl_vector* <strong>PRCLOFWM</strong></p>
<blockquote>
<div><p><strong>OFWx</strong> column in the library</p>
</div></blockquote>
<p>double* <strong>calculatedEnergy</strong></p>
<blockquote>
<div><p>Calculated energy in eV.</p>
</div></blockquote>
<p>int <strong>numlags</strong></p>
<blockquote>
<div><p>Number of lags (if option:<cite>EnergyMethod</cite> = <strong>OPTFILT</strong> or <strong>I2R</strong> or <strong>I2RFITTED</strong> and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFNoise"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFNoise</span></code></a> = <strong>NSD</strong>)</p>
</div></blockquote>
<p>double <strong>tstartNewDev</strong></p>
<blockquote>
<div><p>Addional deviation of the starting time (if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-LagsOrNot"><code class="xref std std-option docutils literal notranslate"><span class="pre">LagsOrNot</span></code></a> = 1)</p>
</div></blockquote>
<p>int <strong>productSize</strong></p>
<blockquote>
<div><p>Size of the scalar product to be calculated</p>
</div></blockquote>
<p>int <strong>tooshortPulse_NoLags</strong></p>
<blockquote>
<div><p>Pulse too short to apply lags (1) or not (0)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418calculateIntParamsP21ReconstructInitSIRENAiidiP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixP10gsl_matrixPP10gsl_matrix">
<span id="_CPPv318calculateIntParamsP21ReconstructInitSIRENAiidiP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixP10gsl_matrixPP10gsl_matrix"></span><span id="_CPPv218calculateIntParamsP21ReconstructInitSIRENAiidiP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixP10gsl_matrixPP10gsl_matrix"></span><span id="calculateIntParams__ReconstructInitSIRENAP.i.i.double.i.gsl_matrixP.gsl_matrixP.gsl_matrixP.gsl_vectorP.gsl_matrixPP.gsl_matrixPP.gsl_vectorPP.gsl_matrixPP.gsl_matrixPP.gsl_matrixPP.gsl_vectorPP.gsl_matrixPP.gsl_matrixPP.gsl_matrixPP.gsl_matrixPP.gsl_matrixPP.gsl_matrixP.gsl_matrixPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">calculateIntParams</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">indexa</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">indexb</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samprate</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">runF0orB0val</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">modelsaux</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">covarianceaux</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">weightaux</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">energycolumn</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">Wabaux</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">TVaux</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tEcolumn</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">XMaux</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">YVaux</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ZVaux</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">rEcolumn</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">Pabaux</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">Dabaux</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">PrecalWMaux</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">optimalfiltersabFREQaux</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">optimalfiltersabTIMEaux</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">modelsMaxLengthFixedFilteraux</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">PabMaxLengthFixedFilteraux</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418calculateIntParamsP21ReconstructInitSIRENAiidiP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixP10gsl_matrixPP10gsl_matrix" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function calculates some intermediate scalars, vectors and matrices (WAB, TV, tE, XM, YV, ZV, rE, PAB and DAB) for the interpolation and covariance methods. See <a class="reference internal" href="SIRENA_preBuffer.html#covmatrices"><span class="std std-ref">Covariance matrices</span></a> reconstruction method. It is used in <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">readAddSortParams()</span></code> .</p>
<ul class="simple">
<li><p>Declare variables and allocate GSL vectors and matrices</p></li>
<li><p>Calculate intermediate scalars, vectors and matrices</p></li>
<li><p>Free allocated GSL vectors and matrices</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>int <strong>indexa</strong></p>
<blockquote>
<div><p>Lower index of the library to calculate the intermediate params (<img class="math" src="_images/math/2f5aa019312e1bbc969deab8dca8b00f76025404.png" alt="\alpha"/>)</p>
</div></blockquote>
<p>int <strong>indexb</strong></p>
<blockquote>
<div><p>Higher index of the library to calculate the intermediate params (<img class="math" src="_images/math/7138dad9ac96835665b17f5817eacfcaa9b834c9.png" alt="\beta"/>)</p>
</div></blockquote>
<p>double <strong>samprate</strong></p>
<blockquote>
<div><p>Sampling rate</p>
</div></blockquote>
<p>int <strong>runF0orB0val</strong></p>
<blockquote>
<div><p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterMethod"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterMethod</span></code></a> = <strong>F0</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv418calculateIntParamsP21ReconstructInitSIRENAiidiP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixP10gsl_matrixPP10gsl_matrix" title="calculateIntParams::runF0orB0val"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">runF0orB0val</span></code></a> = 1. If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterMethod"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterMethod</span></code></a> = <strong>B0</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv418calculateIntParamsP21ReconstructInitSIRENAiidiP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_vectorPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixPP10gsl_matrixP10gsl_matrixPP10gsl_matrix" title="calculateIntParams::runF0orB0val"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">runF0orB0val</span></code></a> = 0</p>
</div></blockquote>
<p>gsl_matrix* <strong>modelsaux</strong></p>
<blockquote>
<div><p>GSL input matrix with model template</p>
</div></blockquote>
<p>gsl_matrix* <strong>covarianceaux</strong></p>
<blockquote>
<div><p>GSL input matrix with covariance matrix</p>
</div></blockquote>
<p>gsl_matrix* <strong>weightaux</strong></p>
<blockquote>
<div><p>GSL input matrix with weight matrix</p>
</div></blockquote>
<p>gsl_vector* <strong>energycolumn</strong></p>
<blockquote>
<div><p>GSL input vector with list of energies</p>
</div></blockquote>
<p>gsl_matrix** <strong>WAB</strong></p>
<blockquote>
<div><p>Input/output intermediate parameter</p>
</div></blockquote>
<p>gsl_matrix** <strong>TVaux</strong></p>
<blockquote>
<div><p>Input/output intermediate parameter</p>
</div></blockquote>
<p>gsl_vector** <strong>tEcolumn</strong></p>
<blockquote>
<div><p>Input/output intermediate parameter</p>
</div></blockquote>
<p>gsl_matrix** <strong>XMaux</strong></p>
<blockquote>
<div><p>Input/output intermediate parameter</p>
</div></blockquote>
<p>gsl_matrix** <strong>YVaux</strong></p>
<blockquote>
<div><p>Input/output intermediate parameter</p>
</div></blockquote>
<p>gsl_matrix** <strong>ZVaux</strong></p>
<blockquote>
<div><p>Input/output intermediate parameter</p>
</div></blockquote>
<p>gsl_vector** <strong>rEcolumn</strong></p>
<blockquote>
<div><p>Input/output intermediate parameter</p>
</div></blockquote>
<p>gsl_matrix** <strong>Pabaux</strong></p>
<blockquote>
<div><p>Input/output intermediate parameter</p>
</div></blockquote>
<p>gsl_matrix** <strong>Dabaux</strong></p>
<blockquote>
<div><p>Input/output intermediate parameter</p>
</div></blockquote>
<p>gsl_matrix** <strong>precalWMaux</strong></p>
<blockquote>
<div><p>Input/output intermediate parameter</p>
</div></blockquote>
<p>gsl_matrix** <strong>optimalfiltersabFREQaux</strong></p>
<blockquote>
<div><p>Input/output intermediate parameter</p>
</div></blockquote>
<p>gsl_matrix** <strong>optimalfiltersabTIMEaux</strong></p>
<blockquote>
<div><p>Input/output intermediate parameter</p>
</div></blockquote>
<p>gsl_matrix* <strong>modelsMaxLengthFixedFilteraux</strong></p>
<blockquote>
<div><p>Input/output intermediate parameter</p>
</div></blockquote>
<p>gsl_matrix** <strong>PabMaxLengthFixedFilteraux</strong></p>
<blockquote>
<div><p>Input/output intermediate parameter</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417calculateTemplateP21ReconstructInitSIRENAP16PulsesCollectionP16PulsesCollectiondPP10gsl_vectorPdPP10gsl_matrixPP10gsl_matrixPP10gsl_vector">
<span id="_CPPv317calculateTemplateP21ReconstructInitSIRENAP16PulsesCollectionP16PulsesCollectiondPP10gsl_vectorPdPP10gsl_matrixPP10gsl_matrixPP10gsl_vector"></span><span id="_CPPv217calculateTemplateP21ReconstructInitSIRENAP16PulsesCollectionP16PulsesCollectiondPP10gsl_vectorPdPP10gsl_matrixPP10gsl_matrixPP10gsl_vector"></span><span id="calculateTemplate__ReconstructInitSIRENAP.PulsesCollectionP.PulsesCollectionP.double.gsl_vectorPP.doubleP.gsl_matrixPP.gsl_matrixPP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">calculateTemplate</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="n"><span class="pre">PulsesCollection</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulsesAll</span></span>, <span class="n"><span class="pre">PulsesCollection</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulsesInRecord</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samprate</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulseaverage</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulseaverageHeight</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">covariance</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">weight</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulseaverageMaxLengthFixedFilter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417calculateTemplateP21ReconstructInitSIRENAP16PulsesCollectionP16PulsesCollectiondPP10gsl_vectorPdPP10gsl_matrixPP10gsl_matrixPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function calculates the template (<strong>PULSE</strong> column in the library) of non piled-up pulses.
Just in case in the detection process some piled-up pulses have not been distinguished as different pulses, a pulseheights histogram is built. This function uses the pulseheights histogram (built by using the <strong>PHEIGHT</strong> column of the library), <strong>Tstart</strong> and <strong>quality</strong> to select the non piled-up pulses.</p>
<ol class="arabic">
<li><p>Declare and initialize variables</p></li>
<li><p>Before building the histogram, select the pulseheights of the pulses well separated from other pulses whose <em>quality</em> = 0</p></li>
<li><p>Create the pulseheights histogram</p></li>
<li><p>Calculate the pulseaverage only taking into account the valid pulses:</p>
<blockquote>
<div><ul class="simple">
<li><p>Check if the pulse is piled-up or not</p></li>
<li><p>Non piled-up pulses <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Average them</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Calculate covariance and weight matrices</p></li>
<li><p>Free allocated GSL vectors</p></li>
</ol>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>PulsesCollection* <strong>pulsesAll</strong></p>
<blockquote>
<div><p>Collection of pulses found in the previous records</p>
</div></blockquote>
<p>PulsesCollection* <strong>pulsesInRecord</strong></p>
<blockquote>
<div><p>Collection of pulses found in the current record</p>
</div></blockquote>
<p>double <strong>samprate</strong></p>
<blockquote>
<div><p>Sampling rate</p>
</div></blockquote>
<p>gsl_vector** <strong>pulseaverage</strong></p>
<blockquote>
<div><p>GSL vector with the pulseaverage (template) of the non piled-up pulses</p>
</div></blockquote>
<p>double* <strong>pulseaverageHeight</strong></p>
<blockquote>
<div><p>Height value of the pulseaverage</p>
</div></blockquote>
<p>gsl_matrix** <strong>covariance</strong></p>
<blockquote>
<div><p>GSL matrix with covariance matrix</p>
</div></blockquote>
<p>gsl_matrix** <strong>weight</strong></p>
<blockquote>
<div><p>GSL matrix with weight matrix (inverse of covariance matrix)</p>
</div></blockquote>
<p>gsl_vector** <strong>pulseaverageMaxLengthFixedFilter</strong></p>
<blockquote>
<div><p>GSL vector with the pulseaverage (template) whose length is <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a> of the non piled-up pulses</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422calculus_optimalFilteriiiP10gsl_vectorldiP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP18gsl_vector_complex">
<span id="_CPPv322calculus_optimalFilteriiiP10gsl_vectorldiP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP18gsl_vector_complex"></span><span id="_CPPv222calculus_optimalFilteriiiP10gsl_vectorldiP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP18gsl_vector_complex"></span><span id="calculus_optimalFilter__i.i.i.gsl_vectorP.l.double.i.gsl_vectorP.gsl_vectorP.gsl_vectorPP.gsl_vectorPP.gsl_vectorPP.gsl_vector_complexPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">calculus_optimalFilter</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">TorF</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">intermediate</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">opmode</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">matchedfiltergsl</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">mf_size</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samprate</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">runF0orB0val</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">freqgsl</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">csdgsl</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">optimal_filtergsl</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">of_f</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">of_FFT</span></span>, <span class="n"><span class="pre">gsl_vector_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">of_FFT_complex</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422calculus_optimalFilteriiiP10gsl_vectorldiP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP18gsl_vector_complex" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>See description also at <a class="reference internal" href="SIRENA_preBuffer.html#optimalfilter-nsd"><span class="std std-ref">optimal filter chapter</span></a></p>
<p>This function calculates the optimal filter for a pulse whose matched filter (normalized template) is provided as input
parameter, <a class="reference internal" href="#_CPPv422calculus_optimalFilteriiiP10gsl_vectorldiP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP18gsl_vector_complex" title="calculus_optimalFilter::matchedfiltergsl"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">matchedfiltergsl</span></code></a>. An optimal filter is just a matched filter that has been adjusted based on the
noise spectrum of the system.</p>
<p>It is assumed that all pulses are scaled versions of a template. In the frequency domain (as noise can be frequency dependent), the raw data
can be expressed as <img class="math" src="_images/math/c550692ee38f669cca790c7a1e040be8bc078246.png" alt="P(f)=E\cdot S(f)+N(f)"/>, where <img class="math" src="_images/math/4b09380f889cdfb6b4375ed5b0a69b23c55677b2.png" alt="S(f)"/> is the normalized model pulse shape in the frequency domain,
<img class="math" src="_images/math/18732b2feb4428c46a2db0ed01158777057721fe.png" alt="N(f)"/> is the power spectrum of the noise and <img class="math" src="_images/math/1815f600df7845409443aed470eac2d449e4ddb0.png" alt="E"/> is the scalar amplitude for the photon energy.</p>
<p>The second assumption is that the noise is stationary, i.e., it does not vary with time. The amplitude of each pulse can then be estimated by
minimizing (weighted least-squares sense) the difference between the noisy data and the model pulse shape, being the <img class="math" src="_images/math/1cbe49dd16598c0550b8a7477dd597e6bc04367e.png" alt="\chi^2"/> condition
to be minimized:</p>
<div class="math">
<p><img src="_images/math/51180eff9438e7b1f554164ba52058291473274a.png" alt="\chi^2 = \int \frac{(P(f)-E \cdot S(f))^2}{\langle\lvert N(f)\lvert ^2\rangle} df"/></p>
</div><p>In the time domain, the amplitude is the best weighted (optimally filtered) sum of the values in the pulse</p>
<div class="math">
<p><img src="_images/math/583437ad3077696cb495abb99923d9ede68505e2.png" alt="E = k \int p(t)\cdot of(t)"/></p>
</div><p>where <img class="math" src="_images/math/52fc644f5f9116bc74ac93d08a7320b1b0bd5295.png" alt="of(t)"/> is the time domain expression of optimal filter which in frequency domain</p>
<div class="math">
<p><img src="_images/math/870e5cfd6c947d9171945cdcfd8c0f20b5ba1aee.png" alt="OF(f) = \frac{S^*(f)}{\langle\lvert N(f)\lvert ^2\rangle}"/></p>
</div><p>and <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> is the normalization factor to give <img class="math" src="_images/math/1815f600df7845409443aed470eac2d449e4ddb0.png" alt="E"/> in units of energy</p>
<div class="math">
<p><img src="_images/math/2f1c70fb00e9be35ce49334fdbc3f60d456f3c46.png" alt="k = \int \frac{S(f)\cdot S^{*}(f)}{\langle\lvert N(f)\lvert ^2\rangle} df"/></p>
</div><p>Steps:</p>
<ul>
<li><p>FFT calculus of the matched filter (filter template)</p>
<blockquote>
<div><ul class="simple">
<li><p>Declare variables</p></li>
<li><p>Complex FFT values for positive and negative frequencies</p></li>
<li><p>FFT calculus</p></li>
<li><p>Generation of the frequencies (positive and negative)</p></li>
<li><p>Magnitude and argument for positive and negative frequencies</p></li>
<li><p>Free allocated GSL vectors</p></li>
</ul>
</div></blockquote>
</li>
<li><p><img class="math" src="_images/math/18732b2feb4428c46a2db0ed01158777057721fe.png" alt="N(f)"/></p></li>
<li><p>To divide <img class="math" src="_images/math/00aa0d13ce4f5cd3d17e5640649a810b5f832afb.png" alt="MatchedFilter(f)/N^2(f)"/> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <img class="math" src="_images/math/fdd8ed11dc356518ff033a0c323365bfdfc768ea.png" alt="MatchedFilter(f)"/> and <img class="math" src="_images/math/18732b2feb4428c46a2db0ed01158777057721fe.png" alt="N(f)"/> must have the same number of points</p>
<blockquote>
<div><ul>
<li><p><em>if</em> (<a class="reference internal" href="#_CPPv422calculus_optimalFilteriiiP10gsl_vectorldiP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP18gsl_vector_complex" title="calculus_optimalFilter::mf_size"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">mf_size</span></code></a> &lt; <em>freqgsl-&gt;size</em>)</p>
<blockquote>
<div><ul class="simple">
<li><p><em>if</em> ((<em>freqgsl-&gt;size)%mf_size</em> == 0) <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Decimate noise samples</p></li>
<li><p><em>else</em> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> It is necessary to work only with the positive frequencies so as not to handle the <img class="math" src="_images/math/65bad3fd19d020ad9e54c06f74cc6141fe115cdc.png" alt="f=0"/> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <img class="math" src="_images/math/18732b2feb4428c46a2db0ed01158777057721fe.png" alt="N(f)"/> interpolation (<a class="reference internal" href="#_CPPv414interpolatePOSP10gsl_vectorP10gsl_vectorldPP10gsl_vectorPP10gsl_vector" title="interpolatePOS"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">interpolatePOS()</span></code></a>)</p></li>
</ul>
</div></blockquote>
</li>
<li><p><em>else if</em> (<a class="reference internal" href="#_CPPv422calculus_optimalFilteriiiP10gsl_vectorldiP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP18gsl_vector_complex" title="calculus_optimalFilter::mf_size"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">mf_size</span></code></a> &gt; <em>freqgsl-&gt;size</em>) <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Error: Noise spectrum must have more samples than pulse spectrum</p></li>
<li><p><em>else if</em> (<a class="reference internal" href="#_CPPv422calculus_optimalFilteriiiP10gsl_vectorldiP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP18gsl_vector_complex" title="calculus_optimalFilter::mf_size"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">mf_size</span></code></a> == <em>freqgsl-&gt;size</em>) <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> It is not necessary to do anything</p></li>
</ul>
</div></blockquote>
</li>
<li><p><img class="math" src="_images/math/3f8c56f4747ae724994add172988972df8fa4944.png" alt="OptimalFilter = MatchedFilter'(f)/N^2(f)"/></p></li>
<li><p>Calculus of the normalization factor</p></li>
<li><p>Apply the normalization factor</p></li>
<li><p>Inverse FFT (to get the expression of the optimal filter in time domain)</p>
<blockquote>
<div><ul class="simple">
<li><p>Complex <img class="math" src="_images/math/e44c4deaefde8938bda846df51762a34f1a3f2ad.png" alt="OptimalFilter(f)"/> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Taking into account magnitude <img class="math" src="_images/math/00aa0d13ce4f5cd3d17e5640649a810b5f832afb.png" alt="MatchedFilter(f)/N^2(f)"/> and phase given by <img class="math" src="_images/math/fdd8ed11dc356518ff033a0c323365bfdfc768ea.png" alt="MatchedFilter(f)"/></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Free allocated GSL vectors</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>int <strong>TorF</strong></p>
<blockquote>
<div><p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterDomain"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterDomain</span></code></a> = <strong>T</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv422calculus_optimalFilteriiiP10gsl_vectorldiP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP18gsl_vector_complex" title="calculus_optimalFilter::TorF"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">TorF</span></code></a> = 0; If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterDomain"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterDomain</span></code></a> = <strong>F</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv422calculus_optimalFilteriiiP10gsl_vectorldiP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP18gsl_vector_complex" title="calculus_optimalFilter::TorF"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">TorF</span></code></a> = 1</p>
</div></blockquote>
<p>int <strong>intermediate</strong></p>
<blockquote>
<div><p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-intermediate"><code class="xref std std-option docutils literal notranslate"><span class="pre">intermediate</span></code></a> = 0 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Do not write an intermediate file; If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-intermediate"><code class="xref std std-option docutils literal notranslate"><span class="pre">intermediate</span></code></a> = 1 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Write an intermediate file</p>
</div></blockquote>
<p>int <strong>opmode</strong></p>
<blockquote>
<div><p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> CALIBRATION run (library creation); If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 1 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> RECONSTRUCTION run (energy determination)</p>
</div></blockquote>
<p>gsl_vector* <strong>matchedfiltergsl</strong></p>
<blockquote>
<div><p>Matched filter associated to the pulse (in general, from the interpolation between two matched filters of the library)</p>
</div></blockquote>
<p>long <strong>mf_size</strong></p>
<blockquote>
<div><p>Matched filter size (samples)</p>
</div></blockquote>
<p>double <strong>samprate</strong></p>
<blockquote>
<div><p>Sampling rate</p>
</div></blockquote>
<p>int <strong>runF0orB0val</strong></p>
<blockquote>
<div><p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterMethod"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterMethod</span></code></a> = <strong>F0</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv422calculus_optimalFilteriiiP10gsl_vectorldiP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP18gsl_vector_complex" title="calculus_optimalFilter::runF0orB0val"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">runF0orB0val</span></code></a> = 1. If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterMethod"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterMethod</span></code></a> = <strong>B0</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv422calculus_optimalFilteriiiP10gsl_vectorldiP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP18gsl_vector_complex" title="calculus_optimalFilter::runF0orB0val"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">runF0orB0val</span></code></a> = 0.</p>
</div></blockquote>
<p>gsl_vector* <strong>freqgsl</strong></p>
<blockquote>
<div><p>Frequency axis of the current noise spectral density (input)</p>
</div></blockquote>
<p>gsl_vector* <strong>csdgsl</strong></p>
<blockquote>
<div><p>Current noise spectral density (input)</p>
</div></blockquote>
<p>gsl_vector* * <strong>optimal_filtergsl</strong></p>
<blockquote>
<div><p>Optimal filter in time domain (output)</p>
</div></blockquote>
<p>gsl_vector** <strong>of_f</strong></p>
<blockquote>
<div><p>Frequency axis of the optimal filter spectrum (output)</p>
</div></blockquote>
<p>gsl_vector** <strong>of_FFT</strong></p>
<blockquote>
<div><p>Optimal filter spectrum (absolute values) (output)</p>
</div></blockquote>
<p>gsl_vector_complex** <strong>of_FFT_complex</strong></p>
<blockquote>
<div><p>Optimal filter spectrum (complex values) (output)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv49checkXmlsPC10Parameters">
<span id="_CPPv39checkXmlsPC10Parameters"></span><span id="_CPPv29checkXmlsPC10Parameters"></span><span id="checkXmls__ParametersPC"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">checkXmls</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Parameters</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">par</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49checkXmlsPC10Parameters" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tesreconstruction.c</em></p>
<p>This function checks if the XML file used to build the library is the same to be used to recconstruct</p>
<p><strong>Members/Variables</strong></p>
<p>struct Parameters* const <strong>par</strong></p>
<blockquote>
<div><p>Structure containing the input parameters specified in <em>tesreconstruction.par</em></p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv410convertI2RPcddddddddPP10gsl_vector">
<span id="_CPPv310convertI2RPcddddddddPP10gsl_vector"></span><span id="_CPPv210convertI2RPcddddddddPP10gsl_vector"></span><span id="convertI2R__cP.double.double.double.double.double.double.double.double.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">convertI2R</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">EnergyMethod</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">Ibias</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">Imin</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">Imax</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ADU_CNV</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ADU_BIAS</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">I_BIAS</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">Ifit</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samprate</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">invector</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410convertI2RPcddddddddPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This funcion converts the current space into a quasi-resistance space (see <a class="reference internal" href="SIRENA_preBuffer.html#rspace"><span class="std std-ref">Quasi Resistance Space</span></a> for <strong>I2R</strong> and <strong>I2RFITTED</strong> modes). The input <a class="reference internal" href="#_CPPv410convertI2RPcddddddddPP10gsl_vector" title="convertI2R::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a> filled in with current values is filled in here with <em>I2R</em> or <strong>I2RFITTED</strong> quasi-resistances at the output.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">ADU_CNV</span></code> keyword is in the input FITS file and <a class="reference internal" href="#_CPPv410convertI2RPcddddddddPP10gsl_vector" title="convertI2R::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a> contains the <strong>ADC</strong> column data from the input FITS file:</p>
<blockquote>
<div><p><img class="math" src="_images/math/cb3b619d615ec996f9da3ea0961edbd19b808455.png" alt="I(A) = I\_BIAS+ADU\_CNV*(ADC-ADU\_BIAS)"/> being <img class="math" src="_images/math/e9bc31aa4036e52b5ef9bcb9cc2b108281ee361b.png" alt="ADC=I(adu)"/> and <code class="docutils literal notranslate"><span class="pre">ADU_CNV</span></code>, <code class="docutils literal notranslate"><span class="pre">ADU_BIAS</span></code> and <code class="docutils literal notranslate"><span class="pre">I_BIAS</span></code> are keywords in the input FITS file</p>
<ul>
<li><p>Conversion according to <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>I2R</strong>:</p>
<blockquote>
<div><p><img class="math" src="_images/math/e515bb519c3d970f7969d907715c9ff934b14f30.png" alt="DeltaI = I"/></p>
<p><img class="math" src="_images/math/23e57ccecc638a557496cc94f9d5fc0effbe93f6.png" alt="R/R0 = [1 - (abs(DeltaI)/I\_BIAS)/(1+abs(DeltaI)/I\_BIAS)]\cdot10^5"/></p>
</div></blockquote>
</li>
<li><p>Conversion according to <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>I2RFITTED</strong>:</p>
<blockquote>
<div><p><img class="math" src="_images/math/2e891283e4e6eb35d9f250aa2e57ec642a5d06c9.png" alt="R/V0 = -10^5/(I_{fit}+ADC)"/> being <img class="math" src="_images/math/fd0179dc927022f51d9a8abdb0acfd9f4e91f5ba.png" alt="I_{fit}"/> value an input parameter</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>If the <code class="docutils literal notranslate"><span class="pre">ADU_CNV</span></code> keyword is NOT in the input FITS file and <a class="reference internal" href="#_CPPv410convertI2RPcddddddddPP10gsl_vector" title="convertI2R::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a> contains the <strong>ADC</strong> column data from the input FITS file:</p>
<blockquote>
<div><p><img class="math" src="_images/math/6529b4cbffa9160774ffc3e803fe2a1f471ff13f.png" alt="aducnv = (IMAX-IMIN)/65534"/> (<code class="docutils literal notranslate"><span class="pre">IMIN</span></code> and <code class="docutils literal notranslate"><span class="pre">IMAX</span></code> are keywords in the input FITS file and 65534 the number of quantification leves)</p>
<p><img class="math" src="_images/math/43eab2224226149b757468b31f89b3b4718dc709.png" alt="I(A) = ADC*aducnv+IMIN"/> being <img class="math" src="_images/math/e9bc31aa4036e52b5ef9bcb9cc2b108281ee361b.png" alt="ADC=I(adu)"/></p>
<ul>
<li><p>Conversion according to <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>I2R</strong>:</p>
<blockquote>
<div><p><img class="math" src="_images/math/e515bb519c3d970f7969d907715c9ff934b14f30.png" alt="DeltaI = I"/></p>
<p><img class="math" src="_images/math/7af5b43b6dcb5eceda4a1cdc694eb9da8f1ef0a7.png" alt="R/R0 = [1 - (abs(DeltaI)/I0\_START)/(1+abs(DeltaI)/I0\_START)]\cdot10^5"/></p>
</div></blockquote>
</li>
<li><p>Conversion according to <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>I2RFITTED</strong></p>
<blockquote>
<div><p><img class="math" src="_images/math/2e891283e4e6eb35d9f250aa2e57ec642a5d06c9.png" alt="R/V0 = -10^5/(I_{fit}+ADC)"/> being <img class="math" src="_images/math/fd0179dc927022f51d9a8abdb0acfd9f4e91f5ba.png" alt="I_{fit}"/> value an input parameter</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>The <img class="math" src="_images/math/1005d5cba0257915abbd43381cee3bfa5eda67e3.png" alt="10^5"/> scaling factor has been included in the quasi resistance space (both <strong>I2R</strong> and <strong>I2RFITTED</strong> transformations) to avoid rounding errors when working with very small numbers.</p>
<p><strong>Members/Variables</strong></p>
<p>char* <strong>EnergyMethod</strong></p>
<blockquote>
<div><p>Quasi-resistance energy calculation method: <strong>I2R</strong> or <strong>I2RFITTED</strong>, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a></p>
</div></blockquote>
<p>double <strong>Ibias</strong></p>
<blockquote>
<div><p>Initial bias current (<strong>I0_START</strong> column)</p>
</div></blockquote>
<p>double <strong>Imin</strong></p>
<blockquote>
<div><p>Current corresponding to 0 ADU (<code class="docutils literal notranslate"><span class="pre">IMIN</span></code> keyword)</p>
</div></blockquote>
<p>double <strong>Imax</strong></p>
<blockquote>
<div><p>Current corresponding to maximum ADU (<code class="docutils literal notranslate"><span class="pre">IMAX</span></code> keyword)</p>
</div></blockquote>
<p>double <strong>ADU_CNV</strong></p>
<blockquote>
<div><p>Conversion factor (A/adu) (<code class="docutils literal notranslate"><span class="pre">ADU_CNV</span></code> keyword)</p>
</div></blockquote>
<p>double <strong>ADU_BIAS</strong></p>
<blockquote>
<div><p>Bias current (adu) (<code class="docutils literal notranslate"><span class="pre">ADU_BIAS</span></code> keyword)</p>
</div></blockquote>
<p>double <strong>I_BIAS</strong></p>
<blockquote>
<div><p>Bias current (A) (<code class="docutils literal notranslate"><span class="pre">I_BIAS</span></code> keyword)</p>
</div></blockquote>
<p>double <strong>samprate</strong></p>
<blockquote>
<div><p>Sampling rate</p>
</div></blockquote>
<p>gsl_vector* <strong>invector</strong></p>
<blockquote>
<div><p>GSL vector with input signal values (<strong>ADC</strong> column of the input FITS file)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416createDetectFileP21ReconstructInitSIRENAdPP8fitsfilei">
<span id="_CPPv316createDetectFileP21ReconstructInitSIRENAdPP8fitsfilei"></span><span id="_CPPv216createDetectFileP21ReconstructInitSIRENAdPP8fitsfilei"></span><span id="createDetectFile__ReconstructInitSIRENAP.double.fitsfilePP.i"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">createDetectFile</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samprate</span></span>, <span class="n"><span class="pre">fitsfile</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dtcObject</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">inputPulselength</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416createDetectFileP21ReconstructInitSIRENAdPP8fitsfilei" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function creates an intermediate FITS file with some useful info (during the development phase) if the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-intermediate"><code class="xref std std-option docutils literal notranslate"><span class="pre">intermediate</span></code></a> input parameter is set to 1.</p>
<p>The intermediate FITS file will contain 2 HDUs:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>PULSES</em> HDU will contain some info about the found pulses: <strong>TSTART</strong>, <strong>I0</strong> (the pulse itself), <strong>TEND</strong>, <strong>TAURISE</strong>, <strong>TAUFALL</strong> and <strong>QUALITY</strong></p></li>
<li><p><em>TESTINFO</em> HDU will contain columns <strong>FILDER</strong> (the low-pass filtered and differentiated records) and <strong>THRESHOLD</strong></p></li>
</ul>
</div></blockquote>
<p>If file exists <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Check <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-5"><code class="xref std std-option docutils literal notranslate"><span class="pre">clobber</span></code></a> for overwritting. If it does not, then create it.</p>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>double <strong>samprate</strong></p>
<blockquote>
<div><p>Sampling rate</p>
</div></blockquote>
<p>fitsfile <strong>dtcObject</strong></p>
<blockquote>
<div><p>Object which contains information of the intermediate FITS file (used also by <a class="reference internal" href="#_CPPv413writeTestInfoP21ReconstructInitSIRENAP10gsl_vectordP8fitsfile" title="writeTestInfo"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">writeTestInfo()</span></code></a> and <a class="reference internal" href="#_CPPv411writePulsesPP21ReconstructInitSIRENAddP10gsl_vectoriP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectorP8fitsfile" title="writePulses"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">writePulses()</span></code></a>).</p>
</div></blockquote>
<p>int <strong>inputPulseLength</strong></p>
<blockquote>
<div><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLengthNotPadded"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLengthNotPadded</span></code></a> input parameter</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411createHistoP10gsl_vectoriPP10gsl_vectorPP10gsl_vector">
<span id="_CPPv311createHistoP10gsl_vectoriPP10gsl_vectorPP10gsl_vector"></span><span id="_CPPv211createHistoP10gsl_vectoriPP10gsl_vectorPP10gsl_vector"></span><span id="createHisto__gsl_vectorP.i.gsl_vectorPP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">createHisto</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">invector</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nbins</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">xhistogsl</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">yhistogsl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411createHistoP10gsl_vectoriPP10gsl_vectorPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function builds the histogram of the input vector.</p>
<blockquote>
<div><ul class="simple">
<li><p>Histogram x-axis values are the different input vector values (pulseheights)</p></li>
<li><p>Histogram y-axis values are the the number of cases per unit of the variable on the horizontal axis</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple">
<li><p>Declare variables</p></li>
<li><p>It will work with the positive elements of the input vector <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <em>invectoraux2</em></p></li>
<li><p>Check if all the values of <a class="reference internal" href="#_CPPv411createHistoP10gsl_vectoriPP10gsl_vectorPP10gsl_vector" title="createHisto::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a> are the same <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Histogram of only one bin</p></li>
<li><p>Obtain <em>invector_max</em> and <em>invector_min</em></p></li>
<li><p>Obtain <em>binSize</em></p></li>
<li><p>Create histogram axis</p></li>
<li><p>Free allocated GSL vectors</p></li>
</ol>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>invector</strong></p>
<blockquote>
<div><p>GSL input vector</p>
</div></blockquote>
<p>int <strong>nbins</strong></p>
<blockquote>
<div><p>Number of bins to build the histogram</p>
</div></blockquote>
<p>gsl_vector** <strong>xhistogsl</strong></p>
<blockquote>
<div><p>GSL vector with output histogram x-axis</p>
</div></blockquote>
<p>gsl_vector** <strong>yhistogsl</strong></p>
<blockquote>
<div><p>GSL vector with output histogram y-axis</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413createLibraryP21ReconstructInitSIRENAPbPP8fitsfile">
<span id="_CPPv313createLibraryP21ReconstructInitSIRENAPbPP8fitsfile"></span><span id="_CPPv213createLibraryP21ReconstructInitSIRENAPbPP8fitsfile"></span><span id="createLibrary__ReconstructInitSIRENAP.bP.fitsfilePP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">createLibrary</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">appendToLibrary</span></span>, <span class="n"><span class="pre">fitsfile</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">inLibObject</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413createLibraryP21ReconstructInitSIRENAPbPP8fitsfile" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function creates the pulse templates library FITS file, if it does not exist yet. Otherwise, it opens it (to add a new row).</p>
<blockquote>
<div><ol class="arabic">
<li><p>If it exists <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Open it and set <em>appendToLibrary = true</em></p></li>
<li><p>If it does not exist <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Create it and set <em>appendToLibrary = false</em></p>
<blockquote>
<div><ul class="simple">
<li><p>Write keyword <code class="docutils literal notranslate"><span class="pre">EVENTCNT</span></code> = 1 in the <em>LIBRARY</em> extension</p></li>
<li><p>Write the whole list of input parameters in <code class="docutils literal notranslate"><span class="pre">HISTORY</span></code> in the <em>Primary</em> extension (by usin ‘HDpar_stamp’)</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</div></blockquote>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values)</p>
</div></blockquote>
<p>bool <strong>appendToLibrary</strong></p>
<blockquote>
<div><p>Used by the function <a class="reference internal" href="#_CPPv412writeLibraryP21ReconstructInitSIRENAddP10gsl_vectorP10gsl_matrixP10gsl_matrixbPP8fitsfileP10gsl_vector" title="writeLibrary"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">writeLibrary()</span></code></a></p>
</div></blockquote>
<p>fitsfile** <strong>inLibObject</strong></p>
<blockquote>
<div><p>Object which contains information of the library FITS file (used also by <a class="reference internal" href="#_CPPv412writeLibraryP21ReconstructInitSIRENAddP10gsl_vectorP10gsl_matrixP10gsl_matrixbPP8fitsfileP10gsl_vector" title="writeLibrary"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">writeLibrary()</span></code></a>)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417createTPSreprFilev">
<span id="_CPPv317createTPSreprFilev"></span><span id="_CPPv217createTPSreprFilev"></span><span id="createTPSreprFile"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">createTPSreprFile</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417createTPSreprFilev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>gennoisespec.cpp</em></p>
<p>This function creates the gennoisespec output FITS file.</p>
<p>Steps:</p>
<ul class="simple">
<li><p>Create the noise representation file (if it does not exist already)</p></li>
<li><p>Create the extensions <em>NOISE</em>, <em>NOISEALL</em> and <em>WEIGHTMS</em></p></li>
<li><p>Write keywords</p></li>
</ul>
</dd></dl>

<span class="target" id="d"></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413differentiatePP10gsl_vectori">
<span id="_CPPv313differentiatePP10gsl_vectori"></span><span id="_CPPv213differentiatePP10gsl_vectori"></span><span id="differentiate__gsl_vectorPP.i"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">differentiate</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">invector</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">szVct</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413differentiatePP10gsl_vectori" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function applies the derivative method <img class="math" src="_images/math/cf128e755096d0954c24b6ccd96874197127ae34.png" alt="x_i-x_{i-1}"/> to the input vector.</p>
<p>The derivative method provides more sensitivity to handle with piled-up pulses.
Moreover, little variations of the baseline will not affect.</p>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector** <strong>invector</strong></p>
<blockquote>
<div><p>Input/Ouput GSL vector (non-differentiate input vector/differentiate input vector)</p>
</div></blockquote>
<p>int <strong>szVct</strong></p>
<blockquote>
<div><p>Size of <a class="reference internal" href="#_CPPv413differentiatePP10gsl_vectori" title="differentiate::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a></p>
</div></blockquote>
</dd></dl>

<span class="target" id="e"></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv47eigenVVP10gsl_matrixPP10gsl_matrixPP10gsl_vector">
<span id="_CPPv37eigenVVP10gsl_matrixPP10gsl_matrixPP10gsl_vector"></span><span id="_CPPv27eigenVVP10gsl_matrixPP10gsl_matrixPP10gsl_vector"></span><span id="eigenVV__gsl_matrixP.gsl_matrixPP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">eigenVV</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">matrixin</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">eigenvectors</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">eigenvalues</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv47eigenVVP10gsl_matrixPP10gsl_matrixPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This funcion provides the principal eigenvectors and eigenvalues of the input matrix (at the moment, the first two eigenvalues and eigenvectors). The eigenvalues and eigenvectors are sorted in descending order and only the principal components are provided.</p>
<ul class="simple">
<li><p>Calculate the eigenvectors and the eigenvalues</p></li>
<li><p>Sort the eigenvectors and the eigenvalues in descending order</p></li>
<li><p>Choose the main eigenvectors and eigenvalues (the principal components analysis). At the moment, the first two eigenvectors and eigenvalues</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>gsl_matrix* <strong>matrixin</strong></p>
<blockquote>
<div><p>Input GSL matrix</p>
</div></blockquote>
<p>gsl_matrix** <strong>eigenvectors</strong></p>
<blockquote>
<div><p>Subset of eigenvectors of ‘matrixin’ chosen by PCA (the first two ones)</p>
</div></blockquote>
<p>gsl_vector** <strong>eigenvalues</strong></p>
<blockquote>
<div><p>Subset of eigenvalues of ‘matrixin’ chosen by PCA (the first two ones)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv410exit_errorPCKc6stringi">
<span id="_CPPv310exit_errorPCKc6stringi"></span><span id="_CPPv210exit_errorPCKc6stringi"></span><span id="exit_error__cCPC.string.i"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">exit_error</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">func</span></span>, <span class="n"><span class="pre">string</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">msg</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">status</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410exit_errorPCKc6stringi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>genutils.cpp</em></p>
<p>This function prints out error messages and exits program.</p>
<p><strong>Members/Variables</strong></p>
<p>const char* const <strong>func</strong></p>
<blockquote>
<div><p>Function name whose error is printed</p>
</div></blockquote>
<p>string <strong>msg</strong></p>
<blockquote>
<div><p>Error message to be printed</p>
</div></blockquote>
<p>int <strong>status</strong></p>
<blockquote>
<div><p>Status</p>
</div></blockquote>
</dd></dl>

<span class="target" id="f"></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv43FFTP10gsl_vectorP18gsl_vector_complexd">
<span id="_CPPv33FFTP10gsl_vectorP18gsl_vector_complexd"></span><span id="_CPPv23FFTP10gsl_vectorP18gsl_vector_complexd"></span><span id="FFT__gsl_vectorP.gsl_vector_complexP.double"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FFT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">invector</span></span>, <span class="n"><span class="pre">gsl_vector_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">outvector</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">STD</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv43FFTP10gsl_vectorP18gsl_vector_complexd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>genutils.cpp</em></p>
<p>This function calculates the FFT of the elements of a vector.</p>
<p>GSL library (overview of FFTs):</p>
<p>For physical applications it is important to remember that the index appearing in the DFT does not correspond directly to a physical frequency. If the time-step of the
DFT is <img class="math" src="_images/math/6450616b75212cb568e905db49efd0c3dd584648.png" alt="\Delta"/> then the frequency domain includes both positive and negative frequencies, ranging from <img class="math" src="_images/math/feb98ca40828239b98eb42f6440c094f5f7acd53.png" alt="-1/(2\Delta)"/> through 0 to <img class="math" src="_images/math/79eab82e0f1f22e4b145fe1463296d0efe39466d.png" alt="+1/(2\Delta)"/>. The positive frequencies are stored from the beginning of the array up to the middle, and the negative frequencies are stored backwards from the end of the array.</p>
<p>Here is a table which shows the layout of the array data, and the correspondence between the time domain data z, and the frequency domain data x.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 27%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>index</p></th>
<th class="head"><p>z</p></th>
<th class="head"><p>x = FFT(z)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><img class="math" src="_images/math/f8aedb98f4e021b6812e5713e6124391107ca361.png" alt="z(t = 0)"/></p></td>
<td><p><img class="math" src="_images/math/7fa0506c630c82a3fa7290dc4bc28f151116dd39.png" alt="x(f = 0)"/></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><img class="math" src="_images/math/cb8521d86a574a848ad622201872441e70f9806c.png" alt="z(t = 1)"/></p></td>
<td><p><img class="math" src="_images/math/f9a3b52a901cba259b7227059193a35e10ffaac1.png" alt="x(f = 1/(n\Delta))"/></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><img class="math" src="_images/math/6e6580a00ee8185c3dfcf7127f7660005d738e15.png" alt="z(t = 2)"/></p></td>
<td><p><img class="math" src="_images/math/d4e0171f3c7ab239375db1025cc013a6e7917a05.png" alt="x(f = 2/(n\Delta))"/></p></td>
</tr>
<tr class="row-odd"><td><p>[…]</p></td>
<td><p>[……..]</p></td>
<td><p>[………………]</p></td>
</tr>
<tr class="row-even"><td><p>n/2</p></td>
<td><p><img class="math" src="_images/math/ce8a3698900490883401d2da76b3d4e93428eeab.png" alt="z(t = n/2)"/></p></td>
<td><p><img class="math" src="_images/math/32fd360237673d15cb18cb84ae897282e908e14a.png" alt="x(f = +1/(2\Delta),-1/(2\Delta))"/></p></td>
</tr>
<tr class="row-odd"><td><p>[…]</p></td>
<td><p>[……..]</p></td>
<td><p>[………………]</p></td>
</tr>
<tr class="row-even"><td><p>n-3</p></td>
<td><p><img class="math" src="_images/math/c41de6e851a723d0a1c3f3eb5001b86db707a74b.png" alt="z(t = n-3)"/></p></td>
<td><p><img class="math" src="_images/math/8c893f8d44fe166a7464558b49306937f2d7a18f.png" alt="x(f = -3/(n\Delta))"/></p></td>
</tr>
<tr class="row-odd"><td><p>n-2</p></td>
<td><p><img class="math" src="_images/math/42dd0cc5bf2f1b67d96a074b014cc90cbf342d87.png" alt="z(t = n-2)"/></p></td>
<td><p><img class="math" src="_images/math/5a0f0b201e18be822c5c8e0259f00a8070557ada.png" alt="x(f = -2/(n\Delta))"/></p></td>
</tr>
<tr class="row-even"><td><p>n-1</p></td>
<td><p><img class="math" src="_images/math/295e9898e28f7a2554445fafc0b17a887b6adb01.png" alt="z(t = n-1)"/></p></td>
<td><p><img class="math" src="_images/math/ecd488c1b6360405583162edc75650b0a7fb3298.png" alt="x(f = -1/(n\Delta))"/></p></td>
</tr>
</tbody>
</table>
<p>The frequency axis will be built as <em>f = i/STD = i/(size/samprate)</em> with <em>i</em> varying from 0 to <em>size/2-1</em> (<em>n=size</em> and <img class="math" src="_images/math/4c83df9dd37e29db180d853d839f404d9b4845ba.png" alt="\Delta=1/samprate"/>  sec/sample).</p>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>invector</strong></p>
<blockquote>
<div><p>Input GSL vector</p>
</div></blockquote>
<p>gsl_vector_complex* <strong>outvector</strong></p>
<blockquote>
<div><p>Output GSL complex vector with the FFT of <a class="reference internal" href="#_CPPv43FFTP10gsl_vectorP18gsl_vector_complexd" title="FFT::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a></p>
</div></blockquote>
<p>double <strong>STD</strong></p>
<blockquote>
<div><p>SelectedTimeDuration = (Size of <a class="reference internal" href="#_CPPv43FFTP10gsl_vectorP18gsl_vector_complexd" title="FFT::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a>)/<em>samprate</em></p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv410FFTinverseP18gsl_vector_complexP10gsl_vectord">
<span id="_CPPv310FFTinverseP18gsl_vector_complexP10gsl_vectord"></span><span id="_CPPv210FFTinverseP18gsl_vector_complexP10gsl_vectord"></span><span id="FFTinverse__gsl_vector_complexP.gsl_vectorP.double"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FFTinverse</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">invector</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">outvector</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">STD</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410FFTinverseP18gsl_vector_complexP10gsl_vectord" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>genutils.cpp</em></p>
<p>This function calculates the inverse FFT of the elements of a vector.</p>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector_complex* <strong>invector</strong></p>
<blockquote>
<div><p>Input GSL complex vector</p>
</div></blockquote>
<p>gsl_vector* <strong>outvector</strong></p>
<blockquote>
<div><p>Output GSL vector with the inverse FFT of <a class="reference internal" href="#_CPPv410FFTinverseP18gsl_vector_complexP10gsl_vectord" title="FFTinverse::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a></p>
</div></blockquote>
<p>double <strong>STD</strong></p>
<blockquote>
<div><p>SelectedTimeDuration = (Size of <a class="reference internal" href="#_CPPv410FFTinverseP18gsl_vector_complexP10gsl_vectord" title="FFTinverse::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a>)/<em>samprate</em></p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413filderLibraryPP21ReconstructInitSIRENAd">
<span id="_CPPv313filderLibraryPP21ReconstructInitSIRENAd"></span><span id="_CPPv213filderLibraryPP21ReconstructInitSIRENAd"></span><span id="filderLibrary__ReconstructInitSIRENAPP.double"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filderLibrary</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samprate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413filderLibraryPP21ReconstructInitSIRENAd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function calculates the (low-pass filter and) derivative of the models (<em>pulse_templates</em>) in the library (only necessary if first record),
and it stores the <em>pulse_templates_filder</em> and the <em>maxDERs</em> and <em>samp1DERs</em> in the <a class="reference internal" href="#_CPPv413filderLibraryPP21ReconstructInitSIRENAd" title="filderLibrary::reconstruct_init"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">reconstruct_init</span></code></a> structure.</p>
<p>The maximum of the (low-pass filtered and) differentiated pulse has to be compared to the <em>maxDERs</em> to select the appropriate model. Or, the 1st sample out of the differentiated pulse has to be compared to the <em>samp1DERs</em> to select the appropriate model.</p>
<ol class="arabic simple">
<li><p>Check if it is the first record</p></li>
<li><p>(Low-pass filter and) differentiate the models (<em>pulse_templates</em>) of the library</p></li>
<li><p>Store the (low-pass filtered) derivatives in <em>pulse_templates_filder</em></p></li>
<li><p>Calculate the maximum of the (low-pass filtered and) differentiated models (<em>maxDERs</em>)</p></li>
<li><p>Locate the 1st sample of the (low-pass filtered and) differentiated models (<em>samp1DERs</em>)</p></li>
</ol>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>double <strong>samprate</strong></p>
<blockquote>
<div><p>Sampling rate</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv410fileExistsRKNSt6stringE">
<span id="_CPPv310fileExistsRKNSt6stringE"></span><span id="_CPPv210fileExistsRKNSt6stringE"></span><span id="fileExists__ssCR"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fileExists</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">string</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410fileExistsRKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>genutils.cpp</em></p>
<p>This function checks for file existence returning a boolean value.</p>
<p><strong>Members/Variables</strong></p>
<p>const std::string&amp; <strong>name</strong></p>
<blockquote>
<div><p>File name</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416filterByWaveletsP21ReconstructInitSIRENAPP10gsl_vectoriPi">
<span id="_CPPv316filterByWaveletsP21ReconstructInitSIRENAPP10gsl_vectoriPi"></span><span id="_CPPv216filterByWaveletsP21ReconstructInitSIRENAPP10gsl_vectoriPi"></span><span id="filterByWavelets__ReconstructInitSIRENAP.gsl_vectorPP.i.iP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">filterByWavelets</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">invector</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">length</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">onlyOnce</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416filterByWaveletsP21ReconstructInitSIRENAPP10gsl_vectoriPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function filters the input/output signal <a class="reference internal" href="#_CPPv416filterByWaveletsP21ReconstructInitSIRENAPP10gsl_vectoriPi" title="filterByWavelets::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a>, reducing the noise level.</p>
<p>Steps:</p>
<ul class="simple">
<li><p>It is only going to work with <em>n</em> elements of :cpp:member:’invector’</p></li>
<li><p>Discrete Wavelet Transform</p></li>
<li><p>Sorting coefficients</p></li>
<li><p>Hard thresholding: <em>n-nc</em> coefficients are deleted (those with low energy)</p></li>
<li><p>Inverse DWT</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>gsl_vector** <strong>invector</strong></p>
<blockquote>
<div><p>Input/output signal</p>
</div></blockquote>
<p>int <strong>length</strong></p>
<blockquote>
<div><p>Length of the wavelet transform</p>
</div></blockquote>
<p>int* <strong>onlyOnce</strong></p>
<blockquote>
<div><p>In order to control the times to be executed</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412findIntervaliP10gsl_vectorP10gsl_vectoriiiiPiPP10gsl_vector">
<span id="_CPPv312findIntervaliP10gsl_vectorP10gsl_vectoriiiiPiPP10gsl_vector"></span><span id="_CPPv212findIntervaliP10gsl_vectorP10gsl_vectoriiiiPiPP10gsl_vector"></span><span id="findInterval__i.gsl_vectorP.gsl_vectorP.i.i.i.i.iP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">findInterval</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">tail_duration</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">invector</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">startpulse</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">npin</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pulse_length</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nPF</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">interval</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ni</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">startinterval</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412findIntervaliP10gsl_vectorP10gsl_vectoriiiiPiPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>gennoisespec.cpp</em></p>
<p>This function finds the pulse-free intervals when the input vector has pulses.
The pulse-free intervals must have a minimum length (<em>intervalMinBins</em>).
The interval with pulse is <img class="math" src="_images/math/bd60e5ebfee70b9073b11a9763019600138079bf.png" alt="Tstart,Tend+nPF*pulse \_ length"/> (being <img class="math" src="_images/math/9396306c121f0fd33b1cd36cd5a474824e4c1aa6.png" alt="Tend=n*pulse \_ length"/>).</p>
<p>Steps:</p>
<ul class="simple">
<li><p>Declare variables</p></li>
<li><dl class="simple">
<dt>Processing if the input vector has more pulses</dt><dd><ul>
<li><p>It looks for pulse-free intervals between pulses</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Processing if there are no more pulses in the input vector</dt><dd><ul>
<li><p>It looks for pulse-free intervals at the end of the event and the search for more pulse-free intervals is finished</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>int <strong>tail_duration</strong></p>
<blockquote>
<div><p>Length of the tail of a previous pulse</p>
</div></blockquote>
<p>gsl_vector* <strong>invector</strong></p>
<blockquote>
<div><p>Input vector WITH pulses</p>
</div></blockquote>
<p>gsl_vector* <strong>startpulse</strong></p>
<blockquote>
<div><p>Vector with the Tstart of all the pulses of the input vector (samples)</p>
</div></blockquote>
<p>int <strong>npin</strong></p>
<blockquote>
<div><p>Number of pulses in the input vector</p>
</div></blockquote>
<p>int <strong>pulse_length</strong></p>
<blockquote>
<div><p>Pulse length (samples)</p>
</div></blockquote>
<p>int <strong>nPF</strong></p>
<blockquote>
<div><p>Number of pulse lengths after ending the pulse to start the pulse-free interval</p>
</div></blockquote>
<p>int <strong>interval</strong></p>
<blockquote>
<div><p>Minimum length of the interval (samples)</p>
</div></blockquote>
<p>int <strong>ni</strong></p>
<blockquote>
<div><p>Number of pulse-free intervals in the input vector</p>
</div></blockquote>
<p>gsl_vector** <strong>startinterval</strong></p>
<blockquote>
<div><p>Vector with the starting time of each pulse-free interval (samples)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413findIntervalNP10gsl_vectoriPiPP10gsl_vector">
<span id="_CPPv313findIntervalNP10gsl_vectoriPiPP10gsl_vector"></span><span id="_CPPv213findIntervalNP10gsl_vectoriPiPP10gsl_vector"></span><span id="findIntervalN__gsl_vectorP.i.iP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">findIntervalN</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">invector</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">interval</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ni</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">startinterval</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413findIntervalNP10gsl_vectoriPiPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>gennoisespec.cpp</em></p>
<p>This function finds the pulse-free intervals when the input vector has NO pulses.
The pulse-free intervals must have a minimum length (<em>intervalMinBins</em>).</p>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>invector</strong></p>
<blockquote>
<div><p>Input vector WITHOUT pulses</p>
</div></blockquote>
<p>int <strong>interval</strong></p>
<blockquote>
<div><p>Minimum length of the interval (samples)</p>
</div></blockquote>
<p>int* <strong>ni</strong></p>
<blockquote>
<div><p>Number of pulse-free intervals in the input vector</p>
</div></blockquote>
<p>gsl_vector** <strong>startinterval</strong></p>
<blockquote>
<div><p>Vector with the starting time of each pulse-free interval (samples)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413findMeanSigmaP10gsl_vectorPdPd">
<span id="_CPPv313findMeanSigmaP10gsl_vectorPdPd"></span><span id="_CPPv213findMeanSigmaP10gsl_vectorPdPd"></span><span id="findMeanSigma__gsl_vectorP.doubleP.doubleP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">findMeanSigma</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">invector</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">mean</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">sigma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413findMeanSigmaP10gsl_vectorPdPd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function calculates the mean and the standard deviation of the input vector.</p>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>invector</strong></p>
<blockquote>
<div><p>Input GSL vector</p>
</div></blockquote>
<p>double* <strong>mean</strong></p>
<blockquote>
<div><p>Mean of the elements of <a class="reference internal" href="#_CPPv413findMeanSigmaP10gsl_vectorPdPd" title="findMeanSigma::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a></p>
</div></blockquote>
<p>double* <strong>sigma</strong></p>
<blockquote>
<div><p>Standard deviation of the elements of <a class="reference internal" href="#_CPPv413findMeanSigmaP10gsl_vectorPdPd" title="findMeanSigma::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a></p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413findPulsesCALP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPiPdddidddP21ReconstructInitSIRENAdd">
<span id="_CPPv313findPulsesCALP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPiPdddidddP21ReconstructInitSIRENAdd"></span><span id="_CPPv213findPulsesCALP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPiPdddidddP21ReconstructInitSIRENAdd"></span><span id="findPulsesCAL__gsl_vectorP.gsl_vectorP.gsl_vectorPP.gsl_vectorPP.gsl_vectorPP.gsl_vectorPP.iP.doubleP.double.double.i.double.double.double.ReconstructInitSIRENAP.double.double"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">findPulsesCAL</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vectorin</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vectorinDER</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tstart</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">quality</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulseheight</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">maxDERgsl</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">nPulses</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">threshold</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">scalefactor</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samplingRate</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samplesup</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nsgms</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lb</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lrs</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">stopcriteriamkc</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">kappamkc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413findPulsesCALP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPiPdddidddP21ReconstructInitSIRENAdd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function is going to find the pulses in a record (in the <em>CALibration</em> mode) by using the function <a class="reference internal" href="#_CPPv413findTstartCALiP10gsl_vectordiP21ReconstructInitSIRENAPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="findTstartCAL"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">findTstartCAL()</span></code></a>.</p>
<p>Steps:</p>
<ul class="simple">
<li><p>Declare variables</p></li>
<li><p>Establish the threshold (call <a class="reference internal" href="#_CPPv419medianKappaClippingP10gsl_vectordddiPd" title="medianKappaClipping"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">medianKappaClipping()</span></code></a>)</p></li>
<li><p>Find pulses (call <a class="reference internal" href="#_CPPv413findTstartCALiP10gsl_vectordiP21ReconstructInitSIRENAPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="findTstartCAL"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">findTstartCAL()</span></code></a>)</p></li>
<li><p>If at least a pulse is found</p>
<ul>
<li><p>Get <a class="reference internal" href="#_CPPv413findPulsesCALP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPiPdddidddP21ReconstructInitSIRENAdd" title="findPulsesCAL::pulseheight"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">pulseheight</span></code></a> of each found pulse (in order to be used to build the pulse templates library)</p></li>
</ul>
</li>
<li><p>Free allocated GSL vectors</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>vectorin</strong></p>
<blockquote>
<div><p>Not filtered record</p>
</div></blockquote>
<p>gsl_vector* <strong>vectorinDER</strong></p>
<blockquote>
<div><p>Derivative of the (low-pass filtered) <a class="reference internal" href="#_CPPv413findPulsesCALP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPiPdddidddP21ReconstructInitSIRENAdd" title="findPulsesCAL::vectorin"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vectorin</span></code></a></p>
</div></blockquote>
<p>gsl_vector** <strong>tstart</strong></p>
<blockquote>
<div><p>Starting time of the found pulses into the record (in samples)</p>
</div></blockquote>
<p>gsl_vector** <strong>quality</strong></p>
<blockquote>
<div><p>Quality of the found pulses into the record</p>
</div></blockquote>
<p>gsl_vector** <strong>pulseheight</strong></p>
<blockquote>
<div><p>Pulse height of the found pulses into the record</p>
</div></blockquote>
<p>gsl_vector** <strong>maxDERgsl</strong></p>
<blockquote>
<div><p>Maximum of the derivative of the found (low-pass filtered) pulses into the record</p>
</div></blockquote>
<p>int* <strong>nPulses</strong></p>
<blockquote>
<div><p>Number of found pulses</p>
</div></blockquote>
<p>double* <strong>threshold</strong></p>
<blockquote>
<div><p>Threshold used to find the pulses (output parameter because it is necessary out of the function)</p>
</div></blockquote>
<p>double <strong>scalefactor</strong></p>
<blockquote>
<div><p>Scale factor to calculate the LPF box-car length (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-0"><code class="xref std std-option docutils literal notranslate"><span class="pre">scaleFactor</span></code></a>)</p>
</div></blockquote>
<p>double <strong>samplingRate</strong></p>
<blockquote>
<div><p>Sampling rate</p>
</div></blockquote>
<p>int <strong>samplesup</strong></p>
<blockquote>
<div><p>Number of consecutive samples over the threshold to locate a pulse (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-1"><code class="xref std std-option docutils literal notranslate"><span class="pre">samplesUp</span></code></a>)</p>
</div></blockquote>
<p>double <strong>nsgms</strong></p>
<blockquote>
<div><p>Number of Sigmas to establish the threshold (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-2"><code class="xref std std-option docutils literal notranslate"><span class="pre">nSgms</span></code></a>)</p>
</div></blockquote>
<p>double <strong>lb</strong></p>
<blockquote>
<div><p>Vector containing the baseline averaging length used for each pulse</p>
</div></blockquote>
<p>double <strong>lrs</strong></p>
<blockquote>
<div><p>Running sum length (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-LrsT"><code class="xref std std-option docutils literal notranslate"><span class="pre">LrsT</span></code></a> in samples)</p>
</div></blockquote>
<p>ReconstructInitSIRENA* <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>double <strong>stopcriteriamkc</strong></p>
<blockquote>
<div><p>Used in <a class="reference internal" href="#_CPPv419medianKappaClippingP10gsl_vectordddiPd" title="medianKappaClipping"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">medianKappaClipping()</span></code></a> (%)</p>
</div></blockquote>
<p>double <strong>kappamkc</strong></p>
<blockquote>
<div><p>Used in <a class="reference internal" href="#_CPPv419medianKappaClippingP10gsl_vectordddiPd" title="medianKappaClipping"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">medianKappaClipping()</span></code></a></p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415findPulsesNoiseP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPiPddididdd">
<span id="_CPPv315findPulsesNoiseP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPiPddididdd"></span><span id="_CPPv215findPulsesNoiseP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPiPddididdd"></span><span id="findPulsesNoise__gsl_vectorP.gsl_vectorP.gsl_vectorPP.gsl_vectorPP.iP.doubleP.double.i.double.i.double.double.double"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">findPulsesNoise</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vectorin</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vectorinDER</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tstart</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">quality</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">nPulses</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">threshold</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">scalefactor</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">sizepulsebins</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samplingRate</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samplesup</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nsgms</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">stopcriteriamkc</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">kappamkc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415findPulsesNoiseP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPiPddididdd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>gennoisespec.cpp</em></p>
<p>This function is going to find the pulses in a record by using the function <a class="reference internal" href="#_CPPv415findTstartNoiseiP10gsl_vectordiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="findTstartNoise"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">findTstartNoise()</span></code></a></p>
<p>Steps:</p>
<ul class="simple">
<li><p>Declare variables</p></li>
<li><p>Establish the threshold (call <a class="reference internal" href="#_CPPv419medianKappaClippingP10gsl_vectordddiPd" title="medianKappaClipping"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">medianKappaClipping()</span></code></a>)</p></li>
<li><p>Find pulses (call <a class="reference internal" href="#_CPPv415findTstartNoiseiP10gsl_vectordiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="findTstartNoise"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">findTstartNoise()</span></code></a>)</p></li>
<li><p>Free allocated GSL vectors</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>vectorin</strong></p>
<blockquote>
<div><p>Not filtered record</p>
</div></blockquote>
<p>gsl_vector* <strong>vectorinDER</strong></p>
<blockquote>
<div><p>Derivative of the low-pass filtered <a class="reference internal" href="#_CPPv415findPulsesNoiseP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPiPddididdd" title="findPulsesNoise::vectorin"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vectorin</span></code></a></p>
</div></blockquote>
<p>gsl_vector** <strong>tstart</strong></p>
<blockquote>
<div><p>Starting time of the found pulses into the record (samples)</p>
</div></blockquote>
<p>gsl_vector** <strong>quality</strong></p>
<blockquote>
<div><p>Quality of the found pulses into the record</p>
</div></blockquote>
<p>int* <strong>nPulses</strong></p>
<blockquote>
<div><p>Number of found pulses</p>
</div></blockquote>
<p>double* <strong>threshold</strong></p>
<blockquote>
<div><p>Threshold used to find the pulses (output parameter because it is necessary out of the function)</p>
</div></blockquote>
<p>double <strong>scalefactor</strong></p>
<blockquote>
<div><p>Scale factor to calculate the LPF box-car length</p>
</div></blockquote>
<p>int <strong>sizepulsebins</strong></p>
<blockquote>
<div><p>Size of the pulse (samples)</p>
</div></blockquote>
<p>double <strong>samplingRate</strong></p>
<blockquote>
<div><p>Sampling rate</p>
</div></blockquote>
<p>int <strong>samplesup</strong></p>
<blockquote>
<div><p>Number of consecutive samples over the threshold to locate a pulse</p>
</div></blockquote>
<p>double <strong>nsgms</strong></p>
<blockquote>
<div><p>Number of Sigmas to establish the threshold</p>
</div></blockquote>
<p>double <strong>stopCriteriamkc</strong></p>
<blockquote>
<div><p>Used in <a class="reference internal" href="#_CPPv430medianKappaClipping_noiseSigmaP10gsl_vectordddPdPd" title="medianKappaClipping_noiseSigma"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">medianKappaClipping_noiseSigma()</span></code></a> (%)</p>
</div></blockquote>
<p>double <strong>kappamkc</strong></p>
<blockquote>
<div><p>Used in <a class="reference internal" href="#_CPPv430medianKappaClipping_noiseSigmaP10gsl_vectordddPdPd" title="medianKappaClipping_noiseSigma"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">medianKappaClipping_noiseSigma()</span></code></a></p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415FindSecondariesiP10gsl_vectordP21ReconstructInitSIRENAiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vector">
<span id="_CPPv315FindSecondariesiP10gsl_vectordP21ReconstructInitSIRENAiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vector"></span><span id="_CPPv215FindSecondariesiP10gsl_vectordP21ReconstructInitSIRENAiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vector"></span><span id="FindSecondaries__i.gsl_vectorP.double.ReconstructInitSIRENAP.i.iP.gsl_vectorPP.gsl_vectorPP.gsl_vectorPP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FindSecondaries</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">maxPulsesPerRecord</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">adjustedDerivative</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">adaptativethreshold</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">tstartFirstEvent</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">numberPulses</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tstartgsl</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">flagTruncated</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">maxDERgsl</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">lagsgsl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415FindSecondariesiP10gsl_vectordP21ReconstructInitSIRENAiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function runs after <a class="reference internal" href="#_CPPv417InitialTriggeringP10gsl_vectordddddPbPiPiPdi" title="InitialTriggering"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">InitialTriggering()</span></code></a> to find all the events (except the first one) in the first derivative of the (low-pass filtered) record by using the Adjusted Derivative detection method.</p>
<p>Steps:</p>
<ul>
<li><p>Declare variables</p></li>
<li><p>Establishing the criteria of the slope of the derivative depending on the sampling rate</p></li>
<li><p>It is necessary to find the tstarts…</p>
<p>It looks for an event and if a pulse is found, it looks for another event</p>
<blockquote>
<div><ul>
<li><p>It looks for an event since the beginning (or the previous event) to the end of the record.
The first condition to detect an event is that the <a class="reference internal" href="#_CPPv415FindSecondariesiP10gsl_vectordP21ReconstructInitSIRENAiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="FindSecondaries::adjustedDerivative"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adjustedDerivative</span></code></a> was over the <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">threshold</span></code></p>
<blockquote>
<div><ul>
<li><p>Select the model of the found pulse from the libary by using the 1st sample of the derivative (<em>samp1DER</em>)</p></li>
<li><p>Dot product between the detected pulse and the pulse template in 3 different lags</p>
<blockquote>
<div><ul class="simple">
<li><p>If maximum of the dot product found <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Stop calculating dot products in more lags</p></li>
<li><p>If maximum of the dot product not found <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Calculate dot products in more lags (number of lags is limited to 5)</p></li>
</ul>
</div></blockquote>
</li>
<li><p>If maximum of the dot product not found <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> tstart is the first sample crossing above the threshold (without jitter)</p>
<blockquote>
<div><ul class="simple">
<li><p>Average of the first 4 samples of the derivative</p></li>
<li><p>Find model in order to subtract</p></li>
</ul>
</div></blockquote>
</li>
<li><p>If maximum of the dot product found <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Parabola analytically defined <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Locate the maximum <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> New tstart (with jitter)</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>Iterative process in order to extract the best template from the library:</dt><dd><ul>
<li><p><em>samp1DER</em> correction</p></li>
<li><p>Find the model from the libary by using the corrected <em>samp1DER</em></p></li>
<li><p>Dot product in 3 lags</p></li>
<li><p>Locate the maximum of the parabola</p></li>
</ul>
</dd>
</dl>
</li>
<li><p><em>samp1DER</em> correction</p></li>
<li><p>Find model in order to subtract</p></li>
<li><p>Template correction</p></li>
<li><p>Average of the first 4 samples of the derivative</p></li>
</ul>
</div></blockquote>
</li>
<li><p>The second condition to detect an event is meeting the criteria of the slope of the derivative</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Subtract the model from the adjusted derivative</p>
<blockquote>
<div><ul class="simple">
<li><p>Select the model of the found event from the libary by using the first sample of the derivative</p></li>
<li><p>Subtract</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p>… Or to use the tstart provided as input parameters</p>
<blockquote>
<div><ul class="simple">
<li><p>Obtain the <em>maxDERs</em> of the events whose tstarts have been provided (by using the maximum of the derivative to find the model)</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Free allocated GSL vectors</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>int <strong>maxPulsesPerRecord</strong></p>
<blockquote>
<div><p>Expected maximum number of events per record in order to not allocate the GSL variables with the size of the input vector (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-EventListSize"><code class="xref std std-option docutils literal notranslate"><span class="pre">EventListSize</span></code></a>)</p>
</div></blockquote>
<p>gsl_vector* <strong>adjustedDerivative</strong></p>
<blockquote>
<div><p>First derivative of the (low-pass filtered) record</p>
</div></blockquote>
<p>double <strong>adaptativethreshold</strong></p>
<blockquote>
<div><p>Threshold</p>
</div></blockquote>
<p>double <strong>samprate</strong></p>
<blockquote>
<div><p>Sampling rate</p>
</div></blockquote>
<p>ReconstructInitSIRENA* <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>int <strong>tstartFirstEvent</strong></p>
<blockquote>
<div><p>Tstart of the first event of the record (in samples) found by <a class="reference internal" href="#_CPPv417InitialTriggeringP10gsl_vectordddddPbPiPiPdi" title="InitialTriggering"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">InitialTriggering()</span></code></a></p>
</div></blockquote>
<p>int* <strong>numberPulses</strong></p>
<blockquote>
<div><p>Number of found events</p>
</div></blockquote>
<p>gsl_vector** <strong>tstartgsl</strong></p>
<blockquote>
<div><p>Starting time of the found events (in samples)</p>
</div></blockquote>
<p>gsl_vector** <strong>flagTruncated</strong></p>
<blockquote>
<div><p>Flag indicating if the event is truncated (inside this function only initial truncated pulses are classified)</p>
</div></blockquote>
<p>gsl_vector** <strong>maxDERgsl</strong></p>
<blockquote>
<div><p>Maximum of the derivative of the event</p>
</div></blockquote>
<p>gsl_vector** <strong>samp1DERgsl</strong></p>
<blockquote>
<div><p>Average of the first 4 samples of the derivative of the event</p>
</div></blockquote>
<p>gsl_vector** <strong>lagsgsl</strong></p>
<blockquote>
<div><p>Number of necessary lags to establish the tstart (currently limited to 5)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418FindSecondariesSTCiP10gsl_vectordP21ReconstructInitSIRENAiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vector">
<span id="_CPPv318FindSecondariesSTCiP10gsl_vectordP21ReconstructInitSIRENAiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vector"></span><span id="_CPPv218FindSecondariesSTCiP10gsl_vectordP21ReconstructInitSIRENAiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vector"></span><span id="FindSecondariesSTC__i.gsl_vectorP.double.ReconstructInitSIRENAP.i.iP.gsl_vectorPP.gsl_vectorPP.gsl_vectorPP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FindSecondariesSTC</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">maxPulsesPerRecord</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">adjustedDerivative</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">adaptativethreshold</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">tstartFirstEvent</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">numberPulses</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tstartgsl</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">flagTruncated</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">maxDERgsl</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">lagsgsl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418FindSecondariesSTCiP10gsl_vectordP21ReconstructInitSIRENAiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function runs after <a class="reference internal" href="#_CPPv417InitialTriggeringP10gsl_vectordddddPbPiPiPdi" title="InitialTriggering"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">InitialTriggering()</span></code></a> to find all the events (except the first one) in the first derivative of the (low-pass filtered) record by using the Single Threshold Crossing method.</p>
<p>Steps:</p>
<ul>
<li><p>Declare variables</p></li>
<li><p>It is necessary to find the tstarts…</p>
<p>It looks for an event and if a pulse is found, it looks for another event</p>
<blockquote>
<div><ul class="simple">
<li><p>It looks for an event since the beginning (or the previous event) to the end of the record.
The condition to detect an event is that the <a class="reference internal" href="#_CPPv418FindSecondariesSTCiP10gsl_vectordP21ReconstructInitSIRENAiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="FindSecondariesSTC::adjustedDerivative"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adjustedDerivative</span></code></a> was over the <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">threshold</span></code> at least <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-1"><code class="xref std std-option docutils literal notranslate"><span class="pre">samplesUp</span></code></a> consecutive samples</p></li>
</ul>
</div></blockquote>
</li>
<li><p>… Or to use the tstart provided as input parameters</p>
<blockquote>
<div><ul class="simple">
<li><p>Obtain the <em>maxDERs</em> of the events whose tstarts have been provided</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Free allocated GSL vectors</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>int <strong>maxPulsesPerRecord</strong></p>
<blockquote>
<div><p>Expected maximum number of events per record in order to not allocate the GSL variables with the size of the input vector (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-EventListSize"><code class="xref std std-option docutils literal notranslate"><span class="pre">EventListSize</span></code></a>)</p>
</div></blockquote>
<p>gsl_vector* <strong>adjustedDerivative</strong></p>
<blockquote>
<div><p>First derivative of the (low-pass filtered) record</p>
</div></blockquote>
<p>double <strong>adaptativethreshold</strong></p>
<blockquote>
<div><p>Threshold</p>
</div></blockquote>
<p>double <strong>samprate</strong></p>
<blockquote>
<div><p>Sampling rate</p>
</div></blockquote>
<p>ReconstructInitSIRENA* <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>int <strong>tstartFirstEvent</strong></p>
<blockquote>
<div><p>Tstart of the first event of the record (in samples) found by <a class="reference internal" href="#_CPPv417InitialTriggeringP10gsl_vectordddddPbPiPiPdi" title="InitialTriggering"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">InitialTriggering()</span></code></a></p>
</div></blockquote>
<p>int* <strong>numberPulses</strong></p>
<blockquote>
<div><p>Number of found events</p>
</div></blockquote>
<p>gsl_vector** <strong>tstartgsl</strong></p>
<blockquote>
<div><p>Starting time of the found events (in samples)</p>
</div></blockquote>
<p>gsl_vector** <strong>flagTruncated</strong></p>
<blockquote>
<div><p>Flag indicating if the event is truncated (inside this function only initial truncated pulses are classified)</p>
</div></blockquote>
<p>gsl_vector** <strong>maxDERgsl</strong></p>
<blockquote>
<div><p>Maximum of the derivative of the event</p>
</div></blockquote>
<p>gsl_vector** <strong>samp1DERgsl</strong></p>
<blockquote>
<div><p>Average of the first 4 samples of the derivative of the event</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413findTstartCALiP10gsl_vectordiP21ReconstructInitSIRENAPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vector">
<span id="_CPPv313findTstartCALiP10gsl_vectordiP21ReconstructInitSIRENAPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vector"></span><span id="_CPPv213findTstartCALiP10gsl_vectordiP21ReconstructInitSIRENAPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vector"></span><span id="findTstartCAL__i.gsl_vectorP.double.i.ReconstructInitSIRENAP.iP.gsl_vectorPP.gsl_vectorPP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">findTstartCAL</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">maxPulsesPerRecord</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">der</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">adaptativethreshold</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nSamplesUp</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">numberPulses</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tstartgsl</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">flagTruncated</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">maxDERgsl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413findTstartCALiP10gsl_vectordiP21ReconstructInitSIRENAPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function scans all the values of the derivative of the (low-pass filtered) record until it finds <a class="reference internal" href="#_CPPv413findTstartCALiP10gsl_vectordiP21ReconstructInitSIRENAPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="findTstartCAL::nSamplesUp"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">nSamplesUp</span></code></a> consecutive
values (due to the noise more than 1 value is required) over the threshold. To look for more pulses, it finds <a class="reference internal" href="#_CPPv413findTstartCALiP10gsl_vectordiP21ReconstructInitSIRENAPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="findTstartCAL::nSamplesUp"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">nSamplesUp</span></code></a> consecutive values
(due to the noise) under the threshold and then, it starts to scan again.</p>
<p>Steps:</p>
<ul>
<li><p>Declare variables</p></li>
<li><p>Allocate GSL vectors</p></li>
<li><p>It is possible to find the tstarts…</p>
<ul class="simple">
<li><p>Obtain tstart of each pulse in the derivative:</p>
<ul>
<li><p>If <img class="math" src="_images/math/b95ee706017de37a3a2a9a7aa3142da88f2f185a.png" alt="der_i&gt;threshold"/> and <em>foundPulse=false</em>, it looks for <a class="reference internal" href="#_CPPv413findTstartCALiP10gsl_vectordiP21ReconstructInitSIRENAPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="findTstartCAL::nSamplesUp"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">nSamplesUp</span></code></a> consecutive samples over the threshold</p>
<ul>
<li><p>If not, it looks again for a pulse crossing over the threshold</p></li>
<li><p>If yes, a pulse is found (truncated if it is at the beginning)</p></li>
</ul>
</li>
<li><p>If <img class="math" src="_images/math/b95ee706017de37a3a2a9a7aa3142da88f2f185a.png" alt="der_i&gt;threshold"/> and <em>foundPulse=true</em>, it looks for a sample under the threshold</p>
<ul>
<li><p>If not, it looks again for a sample under the threshold</p></li>
<li><p>If yes, it looks for <a class="reference internal" href="#_CPPv413findTstartCALiP10gsl_vectordiP21ReconstructInitSIRENAPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="findTstartCAL::nSamplesUp"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">nSamplesUp</span></code></a> consecutive samples under the threshold and again it starts to look for a pulse</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>… Or to use the tstart provided as input parameters</p>
<p>Obtain the <em>maxDERs</em> of the pulses whose tstarts have been provided</p>
</li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>int <strong>maxPulsesPerRecord</strong></p>
<blockquote>
<div><p>Expected maximum number of pulses per record in order to not allocate the GSL variables with the size of the input vector (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-EventListSize"><code class="xref std std-option docutils literal notranslate"><span class="pre">EventListSize</span></code></a>)</p>
</div></blockquote>
<p>gsl_vector* <strong>der</strong></p>
<blockquote>
<div><p>First derivative of the (low-pass filtered) record</p>
</div></blockquote>
<p>double <strong>adaptativethreshold</strong></p>
<blockquote>
<div><p>Threshold</p>
</div></blockquote>
<p>int <strong>nSamplesUp</strong></p>
<blockquote>
<div><p>Number of consecutive samples over the threshold to ‘find’ a pulse (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-1"><code class="xref std std-option docutils literal notranslate"><span class="pre">samplesUp</span></code></a>)</p>
</div></blockquote>
<p>ReconstructInitSIRENA* <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>int* <strong>numberPulses</strong></p>
<blockquote>
<div><p>Number of found pulses</p>
</div></blockquote>
<p>gsl_vector** <strong>tstartgsl</strong></p>
<blockquote>
<div><p>Pulses tstart (in samples)</p>
</div></blockquote>
<p>gsl_vector** <strong>flagTruncated</strong></p>
<blockquote>
<div><p>Flag indicating if the pulse is truncated</p>
</div></blockquote>
<p>gsl_vector** <strong>maxDERgsl</strong></p>
<blockquote>
<div><p>Maximum of the first derivative of the (low-pass filtered) record inside each found pulse</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415findTstartNoiseiP10gsl_vectordiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vector">
<span id="_CPPv315findTstartNoiseiP10gsl_vectordiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vector"></span><span id="_CPPv215findTstartNoiseiP10gsl_vectordiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vector"></span><span id="findTstartNoise__i.gsl_vectorP.double.i.iP.gsl_vectorPP.gsl_vectorPP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">findTstartNoise</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">maxPulsesPerRecord</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">der</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">adaptativethreshold</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nSamplesUp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">numberPulses</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tstartgsl</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">flagTruncated</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">maxDERgsl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415findTstartNoiseiP10gsl_vectordiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>gennoisespec.cpp</em>.</p>
<p>This function finds the pulses tstarts in the input vector (first derivative of the filtered record).</p>
<p>This function scans all values the derivative of the (low-pass filtered) record until it finds <em>nSamplesUp</em> consecutive values (due to the noise more than 1 value is
required) over the threshold. To look for more pulses, it finds <em>nSamplesUp</em> consecutive values (due to the noise) under the threshold and then, it starts to scan again.</p>
<p>Steps:</p>
<ul class="simple">
<li><p>Declare variables</p></li>
<li><p>Allocate GSL vectors</p></li>
<li><dl class="simple">
<dt>Obtain tstart of each pulse in the derivative:</dt><dd><ul>
<li><dl class="simple">
<dt>If <img class="math" src="_images/math/dc159696bc99a90d43750acb60321d305cc529ab.png" alt="der_i &gt; threshold"/> and <em>foundPulse=false</em>, it looks for <em>nSamplesUp</em> consecutive samples over the threshold</dt><dd><ul>
<li><p>If not, it looks again for a pulse crossing over the threshold</p></li>
<li><p>If yes, a pulse is found (truncated if it is at the beginning)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>If <img class="math" src="_images/math/dc159696bc99a90d43750acb60321d305cc529ab.png" alt="der_i &gt; threshold"/> and <em>foundPulse=true</em>, it looks for a sample under the threshold</dt><dd><ul>
<li><p>If not, it looks again for a sample under the threshold</p></li>
<li><p>If yes, it looks for <em>nSamplesUp</em> consecutive samples under the threshold and again it starts to look for a pulse</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>int <strong>maxPulsesPerRecord</strong></p>
<blockquote>
<div><p>Expected maximum number of pulses per record in order to not allocate the GSL variables with the size of the input vector</p>
</div></blockquote>
<p>gsl_vector* <strong>der</strong></p>
<blockquote>
<div><p>First derivative of the (low-pass filtered) record</p>
</div></blockquote>
<p>double <strong>adaptativethreshold</strong></p>
<blockquote>
<div><p>Threshold</p>
</div></blockquote>
<p>int <strong>nSamplesUp</strong></p>
<blockquote>
<div><p>Number of consecutive samples over the threshold to ‘find’ a pulse</p>
</div></blockquote>
<p>int* <strong>numberPulses</strong></p>
<blockquote>
<div><p>Number of found pulses</p>
</div></blockquote>
<p>gsl_vector** <strong>tstartgsl</strong></p>
<blockquote>
<div><p>Pulses tstart (samples)</p>
</div></blockquote>
<p>gsl_vector** <strong>flagTruncated</strong></p>
<blockquote>
<div><p>Flag indicating if the pulse is truncated (inside this function only initial truncated pulses are classified)</p>
</div></blockquote>
<p>gsl_vector** <strong>maxDERgsl</strong></p>
<blockquote>
<div><p>Maximum of the first derivative of the (low-pass filtered) record inside each found pulse</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd">
<span id="_CPPv315find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd"></span><span id="_CPPv215find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd"></span><span id="find_Esboundary__double.gsl_vectorP.ReconstructInitSIRENAP.iP.iP.doubleP.doubleP.double"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">find_Esboundary</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">maxDER</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">maxDERs</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indexEalpha</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indexEbeta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">Ealpha</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">Ebeta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">margin</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em>.</p>
<p>This function provides the indexes of the two energies which straddle the pulse energy, by  comparing the maximum value of the pulse derivative
(<a class="reference internal" href="#_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd" title="find_Esboundary::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a>) to the list of maximums in the library  (<a class="reference internal" href="#_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd" title="find_Esboundary::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a>).</p>
<p>It finds the two embracing <a class="reference internal" href="#_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd" title="find_Esboundary::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> in the calibration library:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <a class="reference internal" href="#_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd" title="find_Esboundary::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> is lower than the lowest <a class="reference internal" href="#_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd" title="find_Esboundary::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> in the library <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd" title="find_Esboundary::indexEalpha"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">indexEalpha</span></code></a> = <a class="reference internal" href="#_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd" title="find_Esboundary::indexEbeta"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">indexEbeta</span></code></a> = 0</p></li>
<li><p>If <a class="reference internal" href="#_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd" title="find_Esboundary::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> is higher than the highest <a class="reference internal" href="#_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd" title="find_Esboundary::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> in the library <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd" title="find_Esboundary::indexEalpha"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">indexEalpha</span></code></a> = <a class="reference internal" href="#_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd" title="find_Esboundary::indexEbeta"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">indexEbeta</span></code></a> = Number of templates-1</p></li>
</ul>
</div></blockquote>
<p><strong>Members/Variables</strong></p>
<p>double <strong>maxDER</strong></p>
<blockquote>
<div><p>Max value of the derivative of the (filtered) pulse whose embracing energies are being sought</p>
</div></blockquote>
<p>gsl_vector* <strong>maxDERs</strong></p>
<blockquote>
<div><p>GSL vector with the maximum values of the derivatives of the templates in the library to be compared with the pulse being analysed</p>
</div></blockquote>
<p>ReconstructInitSIRENA* <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values). In particular, this function uses the info in the library about the energies</p>
</div></blockquote>
<p>int* <strong>indexEalpha</strong></p>
<blockquote>
<div><p>Index of the energy lower than the energy of the pulse which is being analyzed</p>
</div></blockquote>
<p>int* <strong>indexEbeta</strong></p>
<blockquote>
<div><p>Index of the energy higher than the energy of the pulse which is being analyzed</p>
</div></blockquote>
<p>double* <strong>Ealpha</strong></p>
<blockquote>
<div><p>Energy (in eV) which straddle the <a class="reference internal" href="#_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd" title="find_Esboundary::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> in the lower limit</p>
</div></blockquote>
<p>double* <strong>Ebeta</strong></p>
<blockquote>
<div><p>Energy (in eV) which straddle the <a class="reference internal" href="#_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd" title="find_Esboundary::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> in the higher limit</p>
</div></blockquote>
<p>double <strong>margin</strong></p>
<blockquote>
<div><p>Margin to be applied when several energies in the library to choose the proper filter (hardcoded in <em>LibraryCollection</em> in <em>integraSIRENA.cpp</em>)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd">
<span id="_CPPv321find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd"></span><span id="_CPPv221find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd"></span><span id="find_matchedfilterDAB__i.double.gsl_vectorP.i.ReconstructInitSIRENAP.gsl_vectorPP.gsl_vectorPP.doubleP.doubleP.double"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">find_matchedfilterDAB</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">runF0orB0val</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">maxDER</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">maxDERs</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">preBuffer</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">matchedfilterFound</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">PabFound</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">Ealpha</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">Ebeta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">margin</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function selects the proper matched filter (normalized template) from the calibration library from column <strong>DAB</strong> (or from column <strong>MF</strong> if only one energy included in                                                the library) by comparing the maximum value of the pulse derivative (<a class="reference internal" href="#_CPPv421find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_matchedfilterDAB::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a>) to the list of maximums in the library  (<a class="reference internal" href="#_CPPv421find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_matchedfilterDAB::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a>) for the <em>DAB</em> interpolation method (see <a class="reference internal" href="SIRENA_preBuffer.html#optimalfilter-nsd"><span class="std std-ref">optimal filter chapter</span></a>). It also selects the proper row from the column <strong>PAB</strong>.</p>
<p>It finds the two embracing <a class="reference internal" href="#_CPPv421find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_matchedfilterDAB::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> in the calibration library:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <a class="reference internal" href="#_CPPv421find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_matchedfilterDAB::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> is lower than the lowest <a class="reference internal" href="#_CPPv421find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_matchedfilterDAB::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> in the library <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The data with the lowest <a class="reference internal" href="#_CPPv421find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_matchedfilterDAB::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> (first row) in the library are chosen</p></li>
<li><p>If <a class="reference internal" href="#_CPPv421find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_matchedfilterDAB::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> is higher than the highest <a class="reference internal" href="#_CPPv421find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_matchedfilterDAB::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> in the library <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The data of the penultimate row in the library are chosen</p></li>
</ul>
</div></blockquote>
<p><strong>Members/Variables</strong></p>
<p>int <strong>runF0orB0val</strong></p>
<blockquote>
<div><p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterMethod"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterMethod</span></code></a> = <strong>F0</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv421find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_matchedfilterDAB::runF0orB0val"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">runF0orB0val</span></code></a> = 1. If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterMethod"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterMethod</span></code></a> = <strong>B0</strong> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv421find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_matchedfilterDAB::runF0orB0val"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">runF0orB0val</span></code></a> = 0</p>
</div></blockquote>
<p>double <strong>maxDER</strong></p>
<blockquote>
<div><p>Max value of the derivative of the (filtered) pulse whose matched filter is being sought</p>
</div></blockquote>
<p>gsl_vector* <strong>maxDERs</strong></p>
<blockquote>
<div><p>GSL vector with the maximum values of the derivatives of the templates in the library to be compared with the pulse being analysed</p>
</div></blockquote>
<p>int <strong>preBuffer</strong></p>
<blockquote>
<div><p>preBuffer to work with in the particular pulse</p>
</div></blockquote>
<p>ReconstructInitSIRENA* <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>gsl_vector** <strong>matchedfilterFound</strong></p>
<blockquote>
<div><p>GSL vector with the matched filter selected</p>
</div></blockquote>
<p>gsl_vector** <strong>PabFound</strong></p>
<blockquote>
<div><p><strong>PAB</strong> column from the library</p>
</div></blockquote>
<p>double* <strong>Ealpha</strong></p>
<blockquote>
<div><p>Energy (in eV) which straddle the <a class="reference internal" href="#_CPPv421find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_matchedfilterDAB::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> in the lower limit</p>
</div></blockquote>
<p>double* <strong>Ebeta</strong></p>
<blockquote>
<div><p>Energy (in eV) which straddle the <a class="reference internal" href="#_CPPv421find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_matchedfilterDAB::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> in the higher limit</p>
</div></blockquote>
<p>double <strong>margin</strong></p>
<blockquote>
<div><p>Margin to be applied when several energies in the library to choose the proper filter (hardcoded in <em>LibraryCollection</em> in <em>integraSIRENA.cpp</em>)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419find_model_energiesdP21ReconstructInitSIRENAPP10gsl_vector">
<span id="_CPPv319find_model_energiesdP21ReconstructInitSIRENAPP10gsl_vector"></span><span id="_CPPv219find_model_energiesdP21ReconstructInitSIRENAPP10gsl_vector"></span><span id="find_model_energies__double.ReconstructInitSIRENAP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">find_model_energies</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">energy</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">modelFound</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419find_model_energiesdP21ReconstructInitSIRENAPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function uses <a class="reference internal" href="#_CPPv419find_model_energiesdP21ReconstructInitSIRENAPP10gsl_vector" title="find_model_energies::energy"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">energy</span></code></a> in order to choose the proper pulse template (<em>pulse_templates_B0</em>) of the calibration library.</p>
<p>In general, it finds the two energies wich straddle <a class="reference internal" href="#_CPPv419find_model_energiesdP21ReconstructInitSIRENAPP10gsl_vector" title="find_model_energies::energy"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">energy</span></code></a> in the calibration library and interpolates (<a class="reference internal" href="#_CPPv417interpolate_modelPP10gsl_vectordP10gsl_vectordP10gsl_vectord" title="interpolate_model"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">interpolate_model()</span></code></a>):</p>
<blockquote>
<div><ul class="simple">
<li><p>If <a class="reference internal" href="#_CPPv419find_model_energiesdP21ReconstructInitSIRENAPP10gsl_vector" title="find_model_energies::energy"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">energy</span></code></a> is lower than the lowest energy in the library <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The model with the lowest energy in the library is chosen</p></li>
<li><p>If <a class="reference internal" href="#_CPPv419find_model_energiesdP21ReconstructInitSIRENAPP10gsl_vector" title="find_model_energies::energy"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">energy</span></code></a> is higher than the highest energy in the library <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The model with the highest energy in the library is chosen</p></li>
</ul>
</div></blockquote>
<p><strong>Members/Variables</strong></p>
<p>double <strong>energy</strong></p>
<blockquote>
<div><p>Energy of the pulse whose pulse template is being sought</p>
</div></blockquote>
<p>ReconstructInitSIRENA* <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values). In particular, this function uses the energies of the models (<em>energies</em>)
and their templates (<em>pulse_templates</em>), the number of templates in the library (<em>ntemplates</em>), the template duration (<em>template_duration</em>) and
the <em>pulse_templates_B0</em>.</p>
</div></blockquote>
<p>gsl_vector** <strong>modelFound</strong></p>
<blockquote>
<div><p>Found template of the pulse whose energy is <a class="reference internal" href="#_CPPv419find_model_energiesdP21ReconstructInitSIRENAPP10gsl_vector" title="find_model_energies::energy"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">energy</span></code></a></p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418find_model_maxDERsdP21ReconstructInitSIRENAPP10gsl_vector">
<span id="_CPPv318find_model_maxDERsdP21ReconstructInitSIRENAPP10gsl_vector"></span><span id="_CPPv218find_model_maxDERsdP21ReconstructInitSIRENAPP10gsl_vector"></span><span id="find_model_maxDERs__double.ReconstructInitSIRENAP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">find_model_maxDERs</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">maxDER</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">modelFound</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418find_model_maxDERsdP21ReconstructInitSIRENAPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function uses the maximum of the derivative of the (filtered) pulse (<a class="reference internal" href="#_CPPv418find_model_maxDERsdP21ReconstructInitSIRENAPP10gsl_vector" title="find_model_maxDERs::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a>) in order to choose the proper
pulse template (<em>pulse_templates_filder</em>) of the calibration library.</p>
<p>In general, it finds the two <em>maxDER</em> which straddle <a class="reference internal" href="#_CPPv418find_model_maxDERsdP21ReconstructInitSIRENAPP10gsl_vector" title="find_model_maxDERs::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> in the calibration library and interpolates (<a class="reference internal" href="#_CPPv417interpolate_modelPP10gsl_vectordP10gsl_vectordP10gsl_vectord" title="interpolate_model"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">interpolate_model()</span></code></a>):</p>
<blockquote>
<div><ul class="simple">
<li><p>If <a class="reference internal" href="#_CPPv418find_model_maxDERsdP21ReconstructInitSIRENAPP10gsl_vector" title="find_model_maxDERs::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> is lower than the lowest <em>maxDERs</em> in the library <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The model with
the lowest <em>maxDERs</em> in the library is chosen</p></li>
<li><p>If <a class="reference internal" href="#_CPPv418find_model_maxDERsdP21ReconstructInitSIRENAPP10gsl_vector" title="find_model_maxDERs::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> is higher than the highest <em>maxDERs</em> in the library <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The model with
the highest <em>maxDERs</em> in the library is chosen</p></li>
</ul>
</div></blockquote>
<p><strong>Members/Variables</strong></p>
<p>double <strong>maxDER</strong></p>
<blockquote>
<div><p>Maximum of the derivative of the (filtered) pulse whose pulse template is being sought</p>
</div></blockquote>
<p>ReconstructInitSIRENA* <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values). In particular, this function uses the number of templates in
the library (<em>ntemplates</em>), the template duration (<em>template_duration</em>), the filtered and differentiated templates (<em>pulse_templates_filder</em>)
and the <em>maxDERs</em> of the templates</p>
</div></blockquote>
<p>gsl_vector** <strong>modelFound</strong></p>
<blockquote>
<div><p>Found template of the pulse whose maximum of the derivative of the filtered version is <a class="reference internal" href="#_CPPv418find_model_maxDERsdP21ReconstructInitSIRENAPP10gsl_vector" title="find_model_maxDERs::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a></p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420find_model_samp1DERsdP21ReconstructInitSIRENAPP10gsl_vector">
<span id="_CPPv320find_model_samp1DERsdP21ReconstructInitSIRENAPP10gsl_vector"></span><span id="_CPPv220find_model_samp1DERsdP21ReconstructInitSIRENAPP10gsl_vector"></span><span id="find_model_samp1DERs__double.ReconstructInitSIRENAP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">find_model_samp1DERs</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samp1DER</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">modelFound</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420find_model_samp1DERsdP21ReconstructInitSIRENAPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function uses the 1st sample of the derivative of the filtered pulse (<a class="reference internal" href="#_CPPv420find_model_samp1DERsdP21ReconstructInitSIRENAPP10gsl_vector" title="find_model_samp1DERs::samp1DER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">samp1DER</span></code></a>) in order to choose the proper pulse template (<em>pulse_templates_filder</em>) of the calibration library.</p>
<p>It finds the two <a class="reference internal" href="#_CPPv420find_model_samp1DERsdP21ReconstructInitSIRENAPP10gsl_vector" title="find_model_samp1DERs::samp1DER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">samp1DER</span></code></a> closer in the calibration library and interpolates (<a class="reference internal" href="#_CPPv417interpolate_modelPP10gsl_vectordP10gsl_vectordP10gsl_vectord" title="interpolate_model"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">interpolate_model()</span></code></a>)</p>
<blockquote>
<div><ul class="simple">
<li><p>If <a class="reference internal" href="#_CPPv420find_model_samp1DERsdP21ReconstructInitSIRENAPP10gsl_vector" title="find_model_samp1DERs::samp1DER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">samp1DER</span></code></a> is lower than the lowest samp1DER in the library <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The model with the lowest samp1DER in the library is chosen</p></li>
<li><p>If <a class="reference internal" href="#_CPPv420find_model_samp1DERsdP21ReconstructInitSIRENAPP10gsl_vector" title="find_model_samp1DERs::samp1DER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">samp1DER</span></code></a> is higher than the highest samp1DER in the library <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The model with the highest samp1DER in the library is chosen</p></li>
</ul>
</div></blockquote>
<p><strong>Members/Variables</strong></p>
<p>double <strong>samp1DER</strong></p>
<blockquote>
<div><p>1st sample of the derivative of the filtered pulse whose pulse template is being sought</p>
</div></blockquote>
<p>ReconstructInitSIRENA* <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values). In particular, this function uses the 1st samples of the derivative of the models (<em>samp1DERs</em>) and their derived templates (<em>pulse_templates_filder</em>), the number of templates in the library (<em>ntemplates</em>) and the template duration (<em>template_duration</em>).</p>
</div></blockquote>
<p>gsl_vector** <strong>modelFound</strong></p>
<blockquote>
<div><p>Found template of the pulse whose 1st sample of the derivative of the filtered pulse is <a class="reference internal" href="#_CPPv420find_model_samp1DERsdP21ReconstructInitSIRENAPP10gsl_vector" title="find_model_samp1DERs::samp1DER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">samp1DER</span></code></a></p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421find_optimalfilterDABdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd">
<span id="_CPPv321find_optimalfilterDABdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd"></span><span id="_CPPv221find_optimalfilterDABdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd"></span><span id="find_optimalfilterDAB__double.gsl_vectorP.ReconstructInitSIRENAP.gsl_vectorPP.gsl_vectorPP.doubleP.doubleP.double"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">find_optimalfilterDAB</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">maxDER</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">maxDERs</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">optimalfilterFound</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">PabFound</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">Ealpha</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">Ebeta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">margin</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv421find_optimalfilterDABdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>(or ‘Tx’or ‘Fx’columns if only one energy included in                                                *                        the library)
This function selects the proper optimal filter from the calibration library columns <strong>ABTx</strong> or <strong>ABFx</strong> (or from <strong>Tx</strong> or <strong>Fx**columns if only one energy included in                              the library) by comparing the maximum value of the pulse derivative (:cpp:member:`maxDER`) to the list of maximums in the library  (:cpp:member:`maxDERs`). It also selects the proper row from the column **PAB</strong>.</p>
<p>It finds the two embracing <a class="reference internal" href="#_CPPv421find_optimalfilterDABdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_optimalfilterDAB::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> in the calibration library:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <a class="reference internal" href="#_CPPv421find_optimalfilterDABdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_optimalfilterDAB::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> is lower than the lowest <a class="reference internal" href="#_CPPv421find_optimalfilterDABdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_optimalfilterDAB::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> in the library <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The data with the lowest <a class="reference internal" href="#_CPPv421find_optimalfilterDABdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_optimalfilterDAB::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> (first row) in the library are chosen</p></li>
<li><p>If <a class="reference internal" href="#_CPPv421find_optimalfilterDABdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_optimalfilterDAB::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> is higher than the highest <a class="reference internal" href="#_CPPv421find_optimalfilterDABdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_optimalfilterDAB::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> in the library <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The data of the penultimate row in the library are chosen</p></li>
</ul>
</div></blockquote>
<p><strong>Members/Variables</strong></p>
<p>double <strong>maxDER</strong></p>
<blockquote>
<div><p>Max value of the derivative of the (filtered) pulse whose optimal filter is being sought</p>
</div></blockquote>
<p>gsl_vector* <strong>maxDERs</strong></p>
<blockquote>
<div><p>GSL vector with the maximum values of the derivatives of the templates in the library to be compared with the pulse being analysed</p>
</div></blockquote>
<p>ReconstructInitSIRENA* <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values). In particular, this function uses the info
in the library (<em>optimal_filters</em>)</p>
</div></blockquote>
<p>gsl_vector** <strong>optimalfilterFound</strong></p>
<blockquote>
<div><p>GSL vector with the optimal filter selected</p>
</div></blockquote>
<p>gsl_vector** <strong>PabFound</strong></p>
<blockquote>
<div><p><strong>PAB</strong> column from the library</p>
</div></blockquote>
<p>double* <strong>Ealpha</strong></p>
<blockquote>
<div><p>Energy (in eV) which straddle the <a class="reference internal" href="#_CPPv421find_optimalfilterDABdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_optimalfilterDAB::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> in the lower limit</p>
</div></blockquote>
<p>double* <strong>Ebeta</strong></p>
<blockquote>
<div><p>Energy (in eV) which straddle the <a class="reference internal" href="#_CPPv421find_optimalfilterDABdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_optimalfilterDAB::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> in the higher limit</p>
</div></blockquote>
<p>double <strong>margin</strong></p>
<blockquote>
<div><p>Margin to be applied when several energies in the library to choose the proper filter (hardcoded in <em>LibraryCollection</em> in <em>integraSIRENA.cpp</em>)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413find_prclofwmdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPdPdd">
<span id="_CPPv313find_prclofwmdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPdPdd"></span><span id="_CPPv213find_prclofwmdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPdPdd"></span><span id="find_prclofwm__double.gsl_vectorP.ReconstructInitSIRENAP.gsl_vectorPP.doubleP.doubleP.double"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">find_prclofwm</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">maxDER</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">maxDERs</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">PRCLOFWMFound</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">Ealpha</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">Ebeta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">margin</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413find_prclofwmdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPdPdd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>When <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>OPTFILT</strong> and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFNoise"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFNoise</span></code></a> = <strong>WEIGHTM</strong> this function selects the proper precalculated values (<strong>OFWx</strong>) from the calibration <em>PRCLOFWM</em> HDU of the library by comparing the maximum value of the pulse derivative (<a class="reference internal" href="#_CPPv413find_prclofwmdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPdPdd" title="find_prclofwm::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a>) to the list of maximums in the library (<a class="reference internal" href="#_CPPv413find_prclofwmdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPdPdd" title="find_prclofwm::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a>) for <em>reconstruct_init-&gt;OFLib</em> = 1.</p>
<p>It finds the two embracing <a class="reference internal" href="#_CPPv413find_prclofwmdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPdPdd" title="find_prclofwm::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> in the calibration library:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <a class="reference internal" href="#_CPPv413find_prclofwmdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPdPdd" title="find_prclofwm::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> is lower than the lowest <a class="reference internal" href="#_CPPv413find_prclofwmdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPdPdd" title="find_prclofwm::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> in the library <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The data with the lowest <a class="reference internal" href="#_CPPv413find_prclofwmdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPdPdd" title="find_prclofwm::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> (first row) in the library are chosen</p></li>
<li><p>If <a class="reference internal" href="#_CPPv413find_prclofwmdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPdPdd" title="find_prclofwm::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> is higher than the highest <a class="reference internal" href="#_CPPv413find_prclofwmdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPdPdd" title="find_prclofwm::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> in the library <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The data of the penultimate row in the library are chosen</p></li>
</ul>
</div></blockquote>
<p><strong>Members/Variables</strong></p>
<p>double <strong>maxDER</strong></p>
<blockquote>
<div><p>Max value of the derivative of the (filtered) pulse whose optimal filter is being sought</p>
</div></blockquote>
<p>gsl_vector* <strong>maxDERs</strong></p>
<blockquote>
<div><p>GSL vector with the maximum values of the derivatives of the templates in the library to be compared with the pulse being analysed</p>
</div></blockquote>
<p>ReconstructInitSIRENA* <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>gsl_vector** <strong>PRCLOFWMFound</strong></p>
<blockquote>
<div><p>GSL vector with some precalculated selected</p>
</div></blockquote>
<p>double* <strong>Ealpha</strong></p>
<blockquote>
<div><p>Energy (in eV) which straddle the <a class="reference internal" href="#_CPPv413find_prclofwmdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPdPdd" title="find_prclofwm::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> in the lower limit</p>
</div></blockquote>
<p>double* <strong>Ebeta</strong></p>
<blockquote>
<div><p>Energy (in eV) which straddle the <a class="reference internal" href="#_CPPv413find_prclofwmdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPdPdd" title="find_prclofwm::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> in the higher limit</p>
</div></blockquote>
<p>double <strong>margin</strong></p>
<blockquote>
<div><p>Margin to be applied when several energies in the library to choose the proper filter (hardcoded in <em>LibraryCollection</em> in <em>integraSIRENA.cpp</em>)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411find_prclwndP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd">
<span id="_CPPv311find_prclwndP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd"></span><span id="_CPPv211find_prclwndP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd"></span><span id="find_prclwn__double.gsl_vectorP.ReconstructInitSIRENAP.gsl_vectorPP.gsl_vectorPP.doubleP.doubleP.double"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">find_prclwn</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">maxDER</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">maxDERs</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">PRCLWNFound</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">PabFound</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">Ealpha</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">Ebeta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">margin</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411find_prclwndP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>When <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>WEIGHTN</strong> this function selects the proper precalculated values (<strong>PCLx</strong>) from the <em>PRECALWN</em> HDU of the  calibration library by comparing the maximum value of the pulse derivative (<a class="reference internal" href="#_CPPv411find_prclwndP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_prclwn::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a>) to the list of maximums in the library (<a class="reference internal" href="#_CPPv411find_prclwndP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_prclwn::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a>) for the <em>reconstruct_init-&gt;OFLib</em> = 1. It also selects the proper row from the column <strong>PAB</strong>.</p>
<p>It finds the two embracing <a class="reference internal" href="#_CPPv411find_prclwndP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_prclwn::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> in the calibration library:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <a class="reference internal" href="#_CPPv411find_prclwndP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_prclwn::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> is lower than the lowest <a class="reference internal" href="#_CPPv411find_prclwndP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_prclwn::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> in the library <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The data with the lowest <a class="reference internal" href="#_CPPv411find_prclwndP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_prclwn::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> (first row) in the library are chosen</p></li>
<li><p>If <a class="reference internal" href="#_CPPv411find_prclwndP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_prclwn::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> is higher than the highest <a class="reference internal" href="#_CPPv411find_prclwndP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_prclwn::maxDERs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDERs</span></code></a> in the library <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The data of the penultimate row in the library are chosen</p></li>
</ul>
</div></blockquote>
<p><strong>Members/Variables</strong></p>
<p>double <strong>maxDER</strong></p>
<blockquote>
<div><p>Max value of the derivative of the (filtered) pulse whose optimal filter is being sought</p>
</div></blockquote>
<p>gsl_vector* <strong>maxDERs</strong></p>
<blockquote>
<div><p>GSL vector with the maximum values of the derivatives of the templates in the library to be compared with the pulse being analysed</p>
</div></blockquote>
<p>ReconstructInitSIRENA* <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>gsl_vector** <strong>PRCLWNFound</strong></p>
<blockquote>
<div><p>GSL vector with the precalculated values selected</p>
</div></blockquote>
<p>gsl_vector** <strong>PabFound</strong></p>
<blockquote>
<div><p><strong>PAB</strong> column from the library</p>
</div></blockquote>
<p>double* <strong>Ealpha</strong></p>
<blockquote>
<div><p>Energy (in eV) which straddle the <a class="reference internal" href="#_CPPv411find_prclwndP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_prclwn::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> in the lower limit</p>
</div></blockquote>
<p>double* <strong>Ebeta</strong></p>
<blockquote>
<div><p>Energy (in eV) which straddle the <a class="reference internal" href="#_CPPv411find_prclwndP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_prclwn::maxDER"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">maxDER</span></code></a> in the higher limit</p>
</div></blockquote>
<p>double <strong>margin</strong></p>
<blockquote>
<div><p>Margin to be applied when several energies in the library to choose the proper filter (hardcoded in <em>LibraryCollection</em> in <em>integraSIRENA.cpp</em>)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv423freeOptimalFilterSIRENAP19OptimalFilterSIRENA">
<span id="_CPPv323freeOptimalFilterSIRENAP19OptimalFilterSIRENA"></span><span id="_CPPv223freeOptimalFilterSIRENAP19OptimalFilterSIRENA"></span><span id="freeOptimalFilterSIRENA__OptimalFilterSIRENAP"></span><span class="n"><span class="pre">extern_C_void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">freeOptimalFilterSIRENA</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">OptimalFilterSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">OFilterColl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423freeOptimalFilterSIRENAP19OptimalFilterSIRENA" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>integraSIRENA.cpp</em></p>
<p>Destructor of <em>OptimalFilterSIRENA</em> structure.</p>
<p><strong>Members/Variables</strong></p>
<p>OptimalFilterSIRENA* <strong>OFilterColl</strong></p>
<blockquote>
<div><p>Instance of <em>OptimalFilterSIRENA</em> structure</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425freeReconstructInitSIRENAP21ReconstructInitSIRENA">
<span id="_CPPv325freeReconstructInitSIRENAP21ReconstructInitSIRENA"></span><span id="_CPPv225freeReconstructInitSIRENAP21ReconstructInitSIRENA"></span><span id="freeReconstructInitSIRENA__ReconstructInitSIRENAP"></span><span class="n"><span class="pre">extern_C_void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">freeReconstructInitSIRENA</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425freeReconstructInitSIRENAP21ReconstructInitSIRENA" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>integraSIRENA.cpp</em></p>
<p>Destructor of <em>ReconstructInitSIRENA</em> structure.</p>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA* <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Instance of <em>ReconstructInitSIRENA</em> structure</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420freePulsesCollectionP16PulsesCollection">
<span id="_CPPv320freePulsesCollectionP16PulsesCollection"></span><span id="_CPPv220freePulsesCollectionP16PulsesCollection"></span><span id="freePulsesCollection__PulsesCollectionP"></span><span class="n"><span class="pre">extern_C_void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">freePulsesCollection</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">PulsesCollection</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">PulsesColl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420freePulsesCollectionP16PulsesCollection" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>integraSIRENA.cpp</em></p>
<p>Destructor of <em>PulsesCollection</em> structure.</p>
<p><strong>Members/Variables</strong></p>
<p>PulsesCollection* <strong>PulsesColl</strong></p>
<blockquote>
<div><p>Instance of <em>PulsesCollection</em> structure</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413fromGslMatrixPPvPP10gsl_matrixi">
<span id="_CPPv313fromGslMatrixPPvPP10gsl_matrixi"></span><span id="_CPPv213fromGslMatrixPPvPP10gsl_matrixi"></span><span id="fromGslMatrix__voidPP.gsl_matrixPP.i"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fromGslMatrix</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">buffer</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">matrix</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413fromGslMatrixPPvPP10gsl_matrixi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>inoututils.cpp</em></p>
<p>The function puts the values of the input GSL matrix into an output buffer.</p>
<p><strong>Members/Variables</strong></p>
<p>void** <strong>buffer</strong></p>
<blockquote>
<div><p>Output buffer</p>
</div></blockquote>
<p>gsl_matrix** <strong>matrix</strong></p>
<blockquote>
<div><p>Input GSL matrix</p>
</div></blockquote>
<p>int <strong>type</strong></p>
<blockquote>
<div><p>FITS type (TINT, TSHORT, TDOUBLE, etc.)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413fromGslVectorPPvPP10gsl_vectori">
<span id="_CPPv313fromGslVectorPPvPP10gsl_vectori"></span><span id="_CPPv213fromGslVectorPPvPP10gsl_vectori"></span><span id="fromGslVector__voidPP.gsl_vectorPP.i"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fromGslVector</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">buffer</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">array</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413fromGslVectorPPvPP10gsl_vectori" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>inoututils.cpp</em></p>
<p>The function puts the values of the input GSL vector into an output buffer.</p>
<p><strong>Members/Variables</strong></p>
<p>void** <strong>buffer</strong></p>
<blockquote>
<div><p>Output buffer</p>
</div></blockquote>
<p>gsl_vector** <strong>array</strong></p>
<blockquote>
<div><p>Input GSL vector</p>
</div></blockquote>
<p>int <strong>type</strong></p>
<blockquote>
<div><p>FITS type (TINT, TSHORT, TDOUBLE, etc.)</p>
</div></blockquote>
</dd></dl>

<span class="target" id="g"></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417gennoisespec_mainv">
<span id="_CPPv317gennoisespec_mainv"></span><span id="_CPPv217gennoisespec_mainv"></span><span id="gennoisespec_main"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gennoisespec_main</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417gennoisespec_mainv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>gennoisespec.cpp</em></p>
<p>This function calculates the current noise spectral density.
If there are pulses in a record, the pulses are rejected and it is going to look for pulse-free intervals of a given size (<em>intervalMinBins</em>).
If there are no pulses in a record, the event is divided into pulse-free intervals of a given size (<em>intervalMinBins</em>).
It is going to look for pulse-free intervals, calculate their FFT(not filtered data) and average them.</p>
<p>Another facillity is calculate the weight matrix of the noise (in fact, weight matrixes of the noise of different lengths).</p>
<dl class="simple">
<dt>The output FITS file (_noisespec) contains three columns in two extensions, <em>NOISE</em> and <em>NOISEALL</em>:</dt><dd><ul class="simple">
<li><p><strong>FREQ</strong>: Frequency</p></li>
<li><p><strong>CSD</strong>: Current noise spectral density: Amount of current per unit (density) of frequency (spectral), as a function of the frequency</p></li>
<li><p><strong>SIGMACSD</strong>: Standard error of the mean (filled out with 0’s at the moment)</p></li>
</ul>
</dd>
</dl>
<p>There is also other extension, <em>WEIGHTMS</em>, where the weight matrices of the noise are stored.</p>
<p>Steps:</p>
<ul class="simple">
<li><p>Reading all programm parameters by using PIL</p></li>
<li><p>Open input FITS file</p></li>
<li><p>Check if input FITS file have been simulated with TESSIM or XIFUSIM</p></li>
<li><p>To calculate <em>aducnv</em> (conversion factor between arbitrary units and A)…</p></li>
<li><p>…or read <code class="docutils literal notranslate"><span class="pre">ADU_CNV</span></code>, <code class="docutils literal notranslate"><span class="pre">I_BIAS</span></code> and <code class="docutils literal notranslate"><span class="pre">ADU_BIAS</span></code></p></li>
<li><p>Get structure of input FITS file columns</p></li>
<li><p>Read info to transform to resistance space</p></li>
<li><p>Read and check other input keywords</p></li>
<li><p>Read other necessary keywords from ANY HDU</p></li>
<li><dl class="simple">
<dt>Calculate the sampling rate</dt><dd><ul>
<li><p>By using keywords in input FITS file (from <code class="docutils literal notranslate"><span class="pre">DELTAT</span></code> or <code class="docutils literal notranslate"><span class="pre">TCLOCK``+``DEC_FAC</span></code> or <code class="docutils literal notranslate"><span class="pre">NUMROW``+``P_ROW</span></code>)</p></li>
<li><p>If necessary read the sampling rate from input FITS file (from the <code class="docutils literal notranslate"><span class="pre">HISTORY</span></code> in the <em>Primary</em> HDU)</p></li>
<li><p>If not possible, provide an error message to include DELTAT (inverse of sampling rate) in the input FITS file</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Initialize variables and transform from seconds to samples</p></li>
<li><p>Declare variables</p></li>
<li><p>Create structure to run Iteration</p></li>
<li><dl class="simple">
<dt>Read columns (<strong>TIME</strong> and <strong>ADC</strong>)</dt><dd><ul>
<li><p>Called iteration function: <a class="reference internal" href="#_CPPv414inDataIteratorlllliP11iteratorColPv" title="inDataIterator"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">inDataIterator()</span></code></a></p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Close input FITS file</p></li>
<li><dl class="simple">
<dt>Generate CSD representation</dt><dd><ul>
<li><p>Applying <a class="reference internal" href="#_CPPv430medianKappaClipping_noiseSigmaP10gsl_vectordddPdPd" title="medianKappaClipping_noiseSigma"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">medianKappaClipping_noiseSigma()</span></code></a> in order to remove the noise intervals with a high sigma (if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-rmNoiseInterval"><code class="xref std std-option docutils literal notranslate"><span class="pre">rmNoiseInterval</span></code></a> = yes)</p></li>
<li><p>FFT calculus (EventSamplesFFT)</p></li>
<li><p>Add to mean FFT samples</p></li>
<li><p>Current noise spectral density</p></li>
<li><p>Extra normalization (further than the FFT normalization factor,1/n) in order to get the apropriate noise level provided by Peille (54 pA/rHz)</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Load in noiseIntervals only those intervals with a proper sigma (if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-rmNoiseInterval"><code class="xref std std-option docutils literal notranslate"><span class="pre">rmNoiseInterval</span></code></a> = yes) and NumMeanSamples = cnt (in order not to change excesively the code when weightMS)</p></li>
<li><p>Generate WEIGHT representation</p></li>
<li><p>Create output FITS File: GENNOISESPEC representation file</p></li>
<li><p>Write extensions <em>NOISE</em>, <em>NOISEALL</em> and <em>WEIGHTMS</em> (call <a class="reference internal" href="#_CPPv417writeTPSreprExtenv" title="writeTPSreprExten"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">writeTPSreprExten()</span></code></a>)</p></li>
<li><p>Free allocated GSL vectors</p></li>
<li><p>Close output FITS file</p></li>
<li><p>Free memory</p></li>
<li><p>Finalize the task</p></li>
</ul>
<p>The parameters (<em>struct Parameters</em> <strong>par</strong>) read by <a class="reference internal" href="#_CPPv416getpar_noiseSpecPC10Parameters" title="getpar_noiseSpec"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">getpar_noiseSpec()</span></code></a> are:</p>
<p>char <strong>inFile</strong></p>
<blockquote>
<div><p>Name of the input FITS file</p>
</div></blockquote>
<p>char <strong>outFile</strong></p>
<blockquote>
<div><p>Name of the output FITS file</p>
</div></blockquote>
<p>int <strong>intervalMinSamples</strong></p>
<blockquote>
<div><p>Length of a pulse-free interval to use (samples) = <em>intervalMinBins</em></p>
</div></blockquote>
<p>int <strong>nplPF</strong></p>
<blockquote>
<div><p>Number of pulse lengths after ending the pulse (Tend) to start the pulse-free interval</p>
</div></blockquote>
<p>int <strong>nintervals</strong></p>
<blockquote>
<div><p>Number of pulse-free intervals to use to calculate the Noise Spectral Density</p>
</div></blockquote>
<p>double <strong>scaleFactor</strong></p>
<blockquote>
<div><p>Scale factor to apply in order to calculate the LPF box-car length</p>
</div></blockquote>
<p>int <strong>samplesUp</strong></p>
<blockquote>
<div><p>Consecutive samples over the threshold to locate a pulse</p>
</div></blockquote>
<p>double <strong>nSgms</strong></p>
<blockquote>
<div><p>Number of Sigmas to establish the threshold</p>
</div></blockquote>
<p>int <strong>pulse_length</strong></p>
<blockquote>
<div><p>Pulse length (samples)</p>
</div></blockquote>
<p>double <strong>LrsT</strong></p>
<blockquote>
<div><p>Running sum length (seconds)</p>
</div></blockquote>
<p>double <strong>LbT</strong></p>
<blockquote>
<div><p>Baseline averaging length (seconds)</p>
</div></blockquote>
<p>char <strong>weightMS</strong></p>
<blockquote>
<div><p>Calculate and write the weight matrixes if <em>weightMS=yes</em></p>
</div></blockquote>
<p>char <strong>EnergyMethod</strong></p>
<blockquote>
<div><p>Transform to resistance space (I2R, I2RFITTED) or not (OPTFILT)</p>
</div></blockquote>
<p>double <strong>Ifit</strong></p>
<blockquote>
<div><p>Constant to apply the I2RFITTED conversion (adu)</p>
</div></blockquote>
<p>char <strong>clobber</strong></p>
<blockquote>
<div><p>Re-write output files if <em>clobber=yes</em></p>
</div></blockquote>
<p>int <strong>matrixSize</strong></p>
<blockquote>
<div><p>Size of noise matrix if only one to be created</p>
</div></blockquote>
<p>char <strong>rmNoiseIntervals</strong></p>
<blockquote>
<div><p>Remove some noise intervals before calculating the noise spectrum if <em>rmNoiseIntervals=yes</em></p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv44getBP10gsl_vectorP10gsl_vectoriPP10gsl_vectoriPP10gsl_vectorPP10gsl_vector">
<span id="_CPPv34getBP10gsl_vectorP10gsl_vectoriPP10gsl_vectoriPP10gsl_vectorPP10gsl_vector"></span><span id="_CPPv24getBP10gsl_vectorP10gsl_vectoriPP10gsl_vectoriPP10gsl_vectorPP10gsl_vector"></span><span id="getB__gsl_vectorP.gsl_vectorP.i.gsl_vectorPP.i.gsl_vectorPP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">getB</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vectorin</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tstart</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nPulses</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">lb</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">sizepulse</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">B</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">rmsB</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv44getBP10gsl_vectorP10gsl_vectoriPP10gsl_vectoriPP10gsl_vectorPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function calculates the sum, <a class="reference internal" href="#_CPPv44getBP10gsl_vectorP10gsl_vectoriPP10gsl_vectoriPP10gsl_vectorPP10gsl_vector" title="getB::B"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">B</span></code></a>, of <a class="reference internal" href="#_CPPv44getBP10gsl_vectorP10gsl_vectoriPP10gsl_vectoriPP10gsl_vectorPP10gsl_vector" title="getB::lb"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">lb</span></code></a> digitized data samples of a pulse-free interval immediately
before each pulse. If the pulse-free interval before the current pulse is lower than <a class="reference internal" href="#_CPPv44getBP10gsl_vectorP10gsl_vectoriPP10gsl_vectoriPP10gsl_vectorPP10gsl_vector" title="getB::lb"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">lb</span></code></a>, <a class="reference internal" href="#_CPPv44getBP10gsl_vectorP10gsl_vectoriPP10gsl_vectoriPP10gsl_vectorPP10gsl_vector" title="getB::B"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">B</span></code></a> is calculated with the available
number of samples. If there is not a pulse-free interval before the pulse, it is looked for it after the current pulse.
The number of samples of the pulse-free interval used to calculate <a class="reference internal" href="#_CPPv44getBP10gsl_vectorP10gsl_vectoriPP10gsl_vectoriPP10gsl_vectorPP10gsl_vector" title="getB::B"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">B</span></code></a> is stored in the <a class="reference internal" href="#_CPPv44getBP10gsl_vectorP10gsl_vectoriPP10gsl_vectoriPP10gsl_vectorPP10gsl_vector" title="getB::lb"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">lb</span></code></a> vector.</p>
<p>Steps:</p>
<p>First of all, the auxiliary variable <em>Baux</em> is initialized to -999 and all the elements of the <a class="reference internal" href="#_CPPv44getBP10gsl_vectorP10gsl_vectoriPP10gsl_vectoriPP10gsl_vectorPP10gsl_vector" title="getB::lb"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">lb</span></code></a> vector are equal to the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-LbT"><code class="xref std std-option docutils literal notranslate"><span class="pre">LbT</span></code></a> input parameter in samples.
Then, the code is divided into 2 <em>if</em> statements:</p>
<ul class="simple">
<li><p>When the current pulse is the first pulse into the record:</p>
<ul>
<li><p><img class="math" src="_images/math/949c7431d2aaf222557f0050ded1e51320d755ef.png" alt="tstart \geq lb"/> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Sum <em>lb</em> samples</p></li>
<li><p><img class="math" src="_images/math/0f0f2c70220962cba92dbb25bf46a8aa9e9e3f04.png" alt="0&lt;tstart&lt;lb"/> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Sum the available number of samples (although the available number of samples was lower than <em>lb</em>)</p></li>
<li><p><img class="math" src="_images/math/e1d07fa16eb55055976ba32b0d52716a1797a1e6.png" alt="tstart=0"/> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> If there is not a pulse-free interval before the pulse, it is looked for it after the current pulse</p></li>
</ul>
</li>
<li><p>When the current pulse is not the first pulse into the record:</p>
<ul>
<li><p><img class="math" src="_images/math/b95bfe819bafca28a01a0cafc73fa49c99255f4d.png" alt="tstart_i-tend_{i-1} \geq lb"/> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Sum lb samples</p></li>
<li><p><img class="math" src="_images/math/7e8e204636e4d23b96093164e800b43d62b90e20.png" alt="0&lt;tstart_i-tend{i-1}&lt;lb"/> <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Sum the available number of samples (although the available number of samples was lower than <em>lb</em>)</p></li>
<li><p>If there is not a pulse-free interval before the pulse, it is looked for it after the current pulse</p></li>
</ul>
</li>
</ul>
<p>If <em>Baux</em> is still -999, a pulse-free interval can not be found to apply the running sum filter. This has to be taken into account,
out of the function, to try to get a usable <a class="reference internal" href="#_CPPv44getBP10gsl_vectorP10gsl_vectoriPP10gsl_vectoriPP10gsl_vectorPP10gsl_vector" title="getB::B"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">B</span></code></a>.</p>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>vectorin</strong></p>
<blockquote>
<div><p>Input record</p>
</div></blockquote>
<p>gsl_vector* <strong>tstart</strong></p>
<blockquote>
<div><p>Starting time of the pulses into the record</p>
</div></blockquote>
<p>int <strong>nPulses</strong></p>
<blockquote>
<div><p>Number of pulses into the record</p>
</div></blockquote>
<p>gsl_vector** <strong>lb</strong></p>
<blockquote>
<div><p>Vector containing the baseline averaging length used for each pulse</p>
</div></blockquote>
<p>int <strong>sizepulse</strong></p>
<blockquote>
<div><p>Size of the pulse in samples</p>
</div></blockquote>
<p>gsl_vector** <strong>B</strong></p>
<blockquote>
<div><p>In general, sum of the <em>Lb</em> digitized data samples (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-LbT"><code class="xref std std-option docutils literal notranslate"><span class="pre">LbT</span></code></a> input parameters in samples) of a pulse-free interval immediately before the current pulse</p>
</div></blockquote>
<p>gsl_vector** <strong>rmsB</strong></p>
<blockquote>
<div><p>In general, rms of the baseline related to a pulse-free interval immediately before the current pulse</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420getLibraryCollectionPCKciiiiPciPcPcPccPPcdiiP10gsl_vectorP10gsl_vectorPCi">
<span id="_CPPv320getLibraryCollectionPCKciiiiPciPcPcPccPPcdiiP10gsl_vectorP10gsl_vectorPCi"></span><span id="_CPPv220getLibraryCollectionPCKciiiiPciPcPcPccPPcdiiP10gsl_vectorP10gsl_vectorPCi"></span><span id="getLibraryCollection__cCPC.i.i.i.i.cP.i.cP.cP.cP.c.cPP.double.i.i.gsl_vectorP.gsl_vectorP.iPC"></span><span class="n"><span class="pre">LibraryCollection</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">getLibraryCollection</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">filename</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">opmode</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">hduPRECALWN</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">hduPRCLOFWM</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">largeFilter</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">filter_domain</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pulse_length</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">energy_method</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ofnoise</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">filter_method</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">oflib</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ofinterp</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">filtEev</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lagsornot</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">preBuffer</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pBi</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">posti</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">status</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420getLibraryCollectionPCKciiiiPciPcPcPccPPcdiiP10gsl_vectorP10gsl_vectorPCi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>integraSIRENA.cpp</em></p>
<p>This function creates and retrieves a <em>LibraryCollection</em> from a file.</p>
<ul class="simple">
<li><p>Create <em>LibraryCollection</em> structure</p></li>
<li><p>Open FITS file in READONLY mode (move to the first HDU) and get number of templates (rows)</p></li>
<li><p>Allocate library structure</p></li>
<li><p>Get <strong>PULSE</strong> and <strong>MF</strong> column numbers (depending the different options)</p></li>
<li><p>Get template duration</p></li>
<li><p>Allocate library structure (cont.)</p></li>
<li><p>Get matched filter duration</p></li>
<li><p>Read different columns and populate the <em>LibraryCollection</em> structure</p></li>
<li><p>Added new code to handle the new HDUs <em>FIXFILTF</em>, <em>FIXFILTT</em>, <em>PRECALWN</em> and <em>PRCLOFWM</em></p></li>
<li><p>Free allocated GSL vectors and matrices</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>const char* const <strong>filename</strong></p>
<blockquote>
<div><p>File with library information</p>
</div></blockquote>
<p>int <strong>opmode</strong></p>
<blockquote>
<div><blockquote>
<div><p>Calibration run (0) or energy reconstruction run (1), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a></p>
</div></blockquote>
<p>int <strong>hduPRECALWN</strong></p>
<blockquote>
<div><p>Add or not the <em>PRECALWN</em> HDU in the library file (yes/no) (only for library creation, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRECALWN"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRECALWN</span></code></a></p>
</div></blockquote>
</div></blockquote>
<p>int <strong>hduPRCLOFWM</strong></p>
<blockquote>
<div><p>Add or not the <em>PRCLOFWM</em> HDU in the library file (yes/no) (only for library creation, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRCLOFWM"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRCLOFWM</span></code></a></p>
</div></blockquote>
<p>int <strong>largeFilter</strong></p>
<blockquote>
<div><p>Length of the longest fixed filters (only for library creation, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a></p>
</div></blockquote>
<p>char* <strong>filter_domain</strong></p>
<blockquote>
<div><p>Filtering Domain: Time (<strong>T</strong>) or Frequency (<strong>F</strong>), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterDomain"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterDomain</span></code></a></p>
</div></blockquote>
<p>int <strong>pulse_length</strong></p>
<blockquote>
<div><p>Pulse length, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLengthNotPadded"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLengthNotPadded</span></code></a></p>
</div></blockquote>
<p>char* <strong>energy_method</strong></p>
<blockquote>
<div><p>Energy calculation Method: <strong>OPTFILT</strong>, <strong>WEIGHT</strong>, <strong>WEIGHTN</strong>, <strong>I2R</strong>, <strong>I2RFITTED</strong> or <strong>PCA</strong>, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a></p>
</div></blockquote>
<p>char* <strong>ofnoise</strong></p>
<blockquote>
<div><p>For optimal filtering : <strong>NSD</strong> or <strong>WEIGHTM</strong>, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFNoise"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFNoise</span></code></a></p>
</div></blockquote>
<p>char* <strong>filter_method</strong></p>
<blockquote>
<div><p>Filtering Method: <strong>F0</strong> (deleting the zero frequency bin) or <strong>B0</strong> (deleting the baseline), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterMethod"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterMethod</span></code></a></p>
</div></blockquote>
<p>char <strong>oflib</strong></p>
<blockquote>
<div><p>Work or not with a library with optimal filters (1/0)</p>
</div></blockquote>
<p>char** <strong>ofinterp</strong></p>
<blockquote>
<div><p>Optimal Filter by using the Matched Filter or the DAB as matched filter (<em>MF</em>/<em>DAB</em>)
It has been fixed in <a class="reference internal" href="SIRENAcommandline.html#tesreconstruction"><span class="std std-ref">tesreconstruction</span></a> as <em>DAB</em> (but it would be possible to work with <em>MF</em>)</p>
</div></blockquote>
<p>double <strong>filtEev</strong></p>
<blockquote>
<div><p>Energy of the filters of the library to be used to calculate energy (only for OPTFILT, I2R and I2RFITTED), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-filtEeV"><code class="xref std std-option docutils literal notranslate"><span class="pre">filtEeV</span></code></a></p>
</div></blockquote>
<p>int <strong>lagsornot</strong></p>
<blockquote>
<div><p>Lags (1) or no lags (0)</p>
</div></blockquote>
<p>int <strong>preBuffer</strong></p>
<blockquote>
<div><p>Using preBuffer (1) or not using preBuffer (0)</p>
</div></blockquote>
<p>gsl_vector <strong>pBi</strong></p>
<blockquote>
<div><p>Vector with the preBuffer values read from the XML file</p>
</div></blockquote>
<p>gsl_vector <strong>posti</strong></p>
<blockquote>
<div><p>Vector with the post values read from the XML file</p>
</div></blockquote>
<p>int* const <strong>status</strong></p>
<blockquote>
<div><p>Input/output status</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412getNoiseSpecPCKciiPcPcPcPCi">
<span id="_CPPv312getNoiseSpecPCKciiPcPcPcPCi"></span><span id="_CPPv212getNoiseSpecPCKciiPcPcPcPCi"></span><span id="getNoiseSpec__cCPC.i.i.cP.cP.cP.iPC"></span><span class="n"><span class="pre">NoiseSpec</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">getNoiseSpec</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">filename</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">opmode</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">hduPRCLOFWM</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">energy_method</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ofnoise</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">filter_method</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">status</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412getNoiseSpecPCKciiPcPcPcPCi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located  in file: <em>integraSIRENA.cpp</em></p>
<p>This function creates and retrieves a <em>NoiseSpec</em> from a file.</p>
<ul class="simple">
<li><p>Create <em>NoiseSpec</em> structure</p></li>
<li><p>Open FITS file, move to the <em>NOISE</em>, <em>NOISEALL</em> and <em>WEIGHTMS</em> HDUs and get necessary keywords</p></li>
<li><p>Allocate <em>NoiseSpec</em> structure</p></li>
<li><p>Get noise spectrum (<strong>CSD</strong>), and noise frequencies (<strong>FREQ</strong>) column numbers</p></li>
<li><p>Read column <strong>CSD</strong> and save it into the structure</p></li>
<li><p>Read column <strong>FREQ</strong> and save it into the structure</p></li>
<li><p>Read columns <strong>Wx</strong> with the noise weight matrix from noise intervals and save them into the structure</p></li>
<li><p>Return noise spectrum</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>const char* const <strong>filename</strong></p>
<blockquote>
<div><p>File name with noise</p>
</div></blockquote>
<p>int <strong>opmode</strong></p>
<blockquote>
<div><p>Calibration run (0) or energy reconstruction run (1), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a></p>
</div></blockquote>
<p>int <strong>hduPRCLOFWM</strong></p>
<blockquote>
<div><p>Add or not the <em>PRCLOFWM</em> HDU in the library file (yes/no) (only for library creation, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRCLOFWM"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRCLOFWM</span></code></a></p>
</div></blockquote>
<p>char* <strong>energy_method</strong></p>
<blockquote>
<div><p>Energy calculation Method: <strong>OPTFILT</strong>, <strong>WEIGHT</strong>, <strong>WEIGHTN</strong>, <strong>I2R</strong>, <strong>I2RFITTED</strong> or <strong>PCA</strong>, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a></p>
</div></blockquote>
<p>char* <strong>ofnoise</strong></p>
<blockquote>
<div><p>For optimal filtering:  <strong>NSD</strong> or <strong>WEIGHTM</strong>, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFNoise"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFNoise</span></code></a></p>
</div></blockquote>
<p>char* <strong>filter_method</strong></p>
<blockquote>
<div><p>Filtering Method: <strong>F0</strong> (deleting the zero frequency bin) or <strong>B0</strong> (deleting the baseline), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterMethod"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterMethod</span></code></a></p>
</div></blockquote>
<p>int* const <strong>status</strong></p>
<blockquote>
<div><p>Input/Output status</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv46getparPC10Parameters">
<span id="_CPPv36getparPC10Parameters"></span><span id="_CPPv26getparPC10Parameters"></span><span id="getpar__ParametersPC"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">getpar</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Parameters</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">par</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv46getparPC10Parameters" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tesreconstruction.c</em></p>
<p>This function gets the input parameter from the command line or their default values from the <em>tesreconstruction.par</em> file</p>
<p><strong>Members/Variables</strong></p>
<p>struct Parameters* const <strong>par</strong></p>
<blockquote>
<div><p>Structure containing the input parameters specified in <em>tesreconstruction.par</em></p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416getpar_noiseSpecPC10Parameters">
<span id="_CPPv316getpar_noiseSpecPC10Parameters"></span><span id="_CPPv216getpar_noiseSpecPC10Parameters"></span><span id="getpar_noiseSpec__ParametersPC"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">getpar_noiseSpec</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">Parameters</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">par</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416getpar_noiseSpecPC10Parameters" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>gennoisespec.cpp</em></p>
<p>This function gets the input parameter from the command line or their default values from the <em>gennoisespec.par</em> file</p>
<p><strong>Members/Variables</strong></p>
<p>struct Parameters* const <strong>par</strong></p>
<blockquote>
<div><p>Structure containing the input parameters specified in <em>gennoisespec.par</em></p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414getPulseHeightP10gsl_vectorddidddiPd">
<span id="_CPPv314getPulseHeightP10gsl_vectorddidddiPd"></span><span id="_CPPv214getPulseHeightP10gsl_vectorddidddiPd"></span><span id="getPulseHeight__gsl_vectorP.double.double.i.double.double.double.i.doubleP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">getPulseHeight</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vectorin</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">tstart</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">tstartnext</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lastPulse</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lrs</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lb</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">B</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">sizepulse</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulseheight</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414getPulseHeightP10gsl_vectorddidddiPd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function estimates the pulse height of a pulse by using a running sum filter. It extracts from the record, <a class="reference internal" href="#_CPPv414getPulseHeightP10gsl_vectorddidddiPd" title="getPulseHeight::vectorin"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vectorin</span></code></a>, the pulse whose
pulse height is going to be estimated by using <a class="reference internal" href="#_CPPv49RS_filterP10gsl_vectordddPd" title="RS_filter"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">RS_filter()</span></code></a>.</p>
<p>Steps:</p>
<ul class="simple">
<li><p>Declare variables</p></li>
<li><p>Extracting from the record the pulse whose pulse height is going to be estimated</p></li>
<li><p>Apply the running sum filter</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>vectorin</strong></p>
<blockquote>
<div><p>Not filtered record</p>
</div></blockquote>
<p>double <strong>tstart</strong></p>
<blockquote>
<div><p>Starting time of the pulse whose pulse height is going to be estimated</p>
</div></blockquote>
<p>double <strong>tstartnext</strong></p>
<blockquote>
<div><p>Starting time of the next pulse whose pulse height is going to be estimated</p>
</div></blockquote>
<p>int <strong>lastPulse</strong></p>
<blockquote>
<div><p>It is 1 if the pulse is the last one into the record or the only one</p>
</div></blockquote>
<p>double <strong>lrs</strong></p>
<blockquote>
<div><p>Running sum length (equal to the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-LrsT"><code class="xref std std-option docutils literal notranslate"><span class="pre">LrsT</span></code></a> input parameter in samples)</p>
</div></blockquote>
<p>double <strong>lb</strong></p>
<blockquote>
<div><p>Baseline averaging length used for the pulse whose pulse height is going to be estimated</p>
</div></blockquote>
<p>double <strong>B</strong></p>
<blockquote>
<div><p>In general, sum of the <em>Lb</em> digitized data samples (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-LbT"><code class="xref std std-option docutils literal notranslate"><span class="pre">LbT</span></code></a> input parameters in samples) of a pulse-free interval immediately before the current pulse</p>
</div></blockquote>
<p>int <strong>sizepulse</strong></p>
<blockquote>
<div><p>Size of the pulse in samples</p>
</div></blockquote>
<p>double* <strong>pulseheight</strong></p>
<blockquote>
<div><p>Estimated pulse height of the pulse</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426gsl_vector_complex_absIFCAP10gsl_vectorP18gsl_vector_complex">
<span id="_CPPv326gsl_vector_complex_absIFCAP10gsl_vectorP18gsl_vector_complex"></span><span id="_CPPv226gsl_vector_complex_absIFCAP10gsl_vectorP18gsl_vector_complex"></span><span id="gsl_vector_complex_absIFCA__gsl_vectorP.gsl_vector_complexP"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_vector_complex_absIFCA</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cvnew</span></span>, <span class="n"><span class="pre">gsl_vector_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426gsl_vector_complex_absIFCAP10gsl_vectorP18gsl_vector_complex" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>genutils.cpp</em></p>
<p>This function calculates the magnitude of the complex elements of a vector (real part).</p>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector_complex* <strong>cv</strong></p>
<blockquote>
<div><p>Input GSL complex vector</p>
</div></blockquote>
<p>gsl_vector* <strong>cvnew</strong></p>
<blockquote>
<div><p>Output GSL vector with the absolute values of the elements of <a class="reference internal" href="#_CPPv426gsl_vector_complex_absIFCAP10gsl_vectorP18gsl_vector_complex" title="gsl_vector_complex_absIFCA::cv"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">cv</span></code></a></p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv426gsl_vector_complex_argIFCAP10gsl_vectorP18gsl_vector_complex">
<span id="_CPPv326gsl_vector_complex_argIFCAP10gsl_vectorP18gsl_vector_complex"></span><span id="_CPPv226gsl_vector_complex_argIFCAP10gsl_vectorP18gsl_vector_complex"></span><span id="gsl_vector_complex_argIFCA__gsl_vectorP.gsl_vector_complexP"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_vector_complex_argIFCA</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">varg</span></span>, <span class="n"><span class="pre">gsl_vector_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vin</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426gsl_vector_complex_argIFCAP10gsl_vectorP18gsl_vector_complex" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>genutils.cpp</em></p>
<p>This function calculates the arguments of the complex elements of a vector.</p>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector_complex* <strong>vin</strong></p>
<blockquote>
<div><p>Input GSL complex vector</p>
</div></blockquote>
<p>gsl_vector* <strong>varg</strong></p>
<blockquote>
<div><p>Output GSL vector with the arguments of the elements of <a class="reference internal" href="#_CPPv426gsl_vector_complex_argIFCAP10gsl_vectorP18gsl_vector_complex" title="gsl_vector_complex_argIFCA::vin"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vin</span></code></a></p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428gsl_vector_complex_scaleIFCAP18gsl_vector_complex11gsl_complex">
<span id="_CPPv328gsl_vector_complex_scaleIFCAP18gsl_vector_complex11gsl_complex"></span><span id="_CPPv228gsl_vector_complex_scaleIFCAP18gsl_vector_complex11gsl_complex"></span><span id="gsl_vector_complex_scaleIFCA__gsl_vector_complexP.gsl_complex"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_vector_complex_scaleIFCA</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cv</span></span>, <span class="n"><span class="pre">gsl_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">z</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428gsl_vector_complex_scaleIFCAP18gsl_vector_complex11gsl_complex" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>genutils.cpp</em></p>
<p>This function multiplies the complex elements of a vector by a complex number.</p>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector_complex* <strong>cv</strong></p>
<blockquote>
<div><p>Input/Output (scaled) GSL complex vector</p>
</div></blockquote>
<p>gsl_complex <strong>z</strong></p>
<blockquote>
<div><p>Input GSL complex number</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419gsl_vector_sqrtIFCAP10gsl_vectorP10gsl_vector">
<span id="_CPPv319gsl_vector_sqrtIFCAP10gsl_vectorP10gsl_vector"></span><span id="_CPPv219gsl_vector_sqrtIFCAP10gsl_vectorP10gsl_vector"></span><span id="gsl_vector_sqrtIFCA__gsl_vectorP.gsl_vectorP"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_vector_sqrtIFCA</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cvnew</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419gsl_vector_sqrtIFCAP10gsl_vectorP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>genutils.cpp</em></p>
<p>This function calculates the square root of the elements of a vector.</p>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>cv</strong></p>
<blockquote>
<div><p>Input GSL complex vector</p>
</div></blockquote>
<p>gsl_vector* <strong>cvnew</strong></p>
<blockquote>
<div><p>Output GSL vector with the square root values of the elements of <a class="reference internal" href="#_CPPv419gsl_vector_sqrtIFCAP10gsl_vectorP10gsl_vector" title="gsl_vector_sqrtIFCA::cv"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">cv</span></code></a></p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv423gsl_vector_SumsubvectorP10gsl_vectorllPd">
<span id="_CPPv323gsl_vector_SumsubvectorP10gsl_vectorllPd"></span><span id="_CPPv223gsl_vector_SumsubvectorP10gsl_vectorllPd"></span><span id="gsl_vector_Sumsubvector__gsl_vectorP.l.l.doubleP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gsl_vector_Sumsubvector</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">invector</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">offset</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">sum</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423gsl_vector_SumsubvectorP10gsl_vectorllPd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>genutils.cpp</em></p>
<p>This function returns the sum of some elements of the input vector.</p>
<p>The starting element of the sum is <a class="reference internal" href="#_CPPv423gsl_vector_SumsubvectorP10gsl_vectorllPd" title="gsl_vector_Sumsubvector::offset"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">offset</span></code></a> from the start of the input vector. It will sum up <a class="reference internal" href="#_CPPv423gsl_vector_SumsubvectorP10gsl_vectorllPd" title="gsl_vector_Sumsubvector::n"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">n</span></code></a> elements.</p>
<p><a class="reference internal" href="#_CPPv423gsl_vector_SumsubvectorP10gsl_vectorllPd" title="gsl_vector_Sumsubvector::offset"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">offset</span></code></a> can take values from 0 to <em>invector-&gt;size</em></p>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>invector</strong></p>
<blockquote>
<div><p>Input GSL vector</p>
</div></blockquote>
<p>long <strong>offset</strong></p>
<blockquote>
<div><p>It is the first element to be summed</p>
</div></blockquote>
<p>long <strong>n</strong></p>
<blockquote>
<div><p>Number of elements in the sum</p>
</div></blockquote>
<p>double* <strong>sum</strong></p>
<blockquote>
<div><p>Calculated output value (sum of the corresponding elements)</p>
</div></blockquote>
</dd></dl>

<span class="target" id="i"><span id="h"></span></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414inDataIteratorlllliP11iteratorColPv">
<span id="_CPPv314inDataIteratorlllliP11iteratorColPv"></span><span id="_CPPv214inDataIteratorlllliP11iteratorColPv"></span><span id="inDataIterator__l.l.l.l.i.iteratorColP.voidP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">inDataIterator</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">totalrows</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">offset</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">firstrow</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nrows</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ncols</span></span>, <span class="n"><span class="pre">iteratorCol</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">cols</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">user_strct</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414inDataIteratorlllliP11iteratorColPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>gennoisespec.cpp</em></p>
<p>This function takes the optimum number of rows to read the input FITS file and works iteratively</p>
<p>Steps:</p>
<ul class="simple">
<li><p>Declare variables</p></li>
<li><p>Allocate input GSL vectors</p></li>
<li><p>Read iterator</p></li>
<li><dl class="simple">
<dt>Processing each record</dt><dd><ul>
<li><p>Information has been read by blocks (with nrows per block)</p></li>
<li><p>Just in case the last record has been filled out with 0’s <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Last record discarded</p></li>
<li><p>Convert to the resistance space if necessary</p></li>
<li><p>To avoid taking into account the pulse tails at the beginning of a record as part of a pulse-free interval</p></li>
<li><p>Low-pass filtering</p></li>
<li><p>Differentiate</p></li>
<li><p>Finding the pulses: Pulses tstarts are found (call <a class="reference internal" href="#_CPPv415findPulsesNoiseP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPiPddididdd" title="findPulsesNoise"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">findPulsesNoise()</span></code></a>)</p></li>
<li><dl class="simple">
<dt>Finding the pulse-free intervals in each record</dt><dd><ul>
<li><p>If there are pulses <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Call <a class="reference internal" href="#_CPPv412findIntervaliP10gsl_vectorP10gsl_vectoriiiiPiPP10gsl_vector" title="findInterval"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">findInterval()</span></code></a></p></li>
<li><p>No pulses <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The whole event is going to be used (DIVIDING into intervals of intervalMinBins size) <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Call <a class="reference internal" href="#_CPPv413findIntervalNP10gsl_vectoriPiPP10gsl_vector" title="findIntervalN"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">findIntervalN()</span></code></a></p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Calculating the mean and sigma of the intervals without pulses together <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <em>BSLN0</em> and <em>NOISESTD</em></p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Preparing the CSD calculus (not filtered data)</p></li>
<li><p>Free allocated GSL vectors</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>long <strong>totalrows</strong></p>
<blockquote>
<div><p>Total number of rows processed</p>
</div></blockquote>
<p>long <strong>offset</strong></p>
<blockquote>
<div><p>If positive, this number of rows at the beginning of the table (or pixels in the image) will be skipped and will not be passed to the work function</p>
</div></blockquote>
<p>long <strong>firstrow</strong></p>
<blockquote>
<div><p>First row to read</p>
</div></blockquote>
<p>long <strong>nrows</strong></p>
<blockquote>
<div><p>It specifies the number of table rows that are to be passed to the work function on each iteration. If <em>nrows = 0</em> then CFITSIO will calculate the optimum number for greatest efficiency. If <em>nrows</em> is negative, then all the rows or pixels will be passed at one time, and the work function will only be called once. If any variable length arrays are being processed, then the <em>nrows</em> value is ignored, and the iterator will always process one row of the table at a time</p>
</div></blockquote>
<p>int <strong>ncols</strong></p>
<blockquote>
<div><p>Number of columns</p>
</div></blockquote>
<p>iteratorCol* <strong>cols</strong></p>
<blockquote>
<div><p>Structure of iteration</p>
</div></blockquote>
<p>void* <strong>user_strct</strong></p>
<blockquote>
<div><p>This is a user supplied pointer that can be used to pass ancillary information from the driver routine to the work function. It may point to a single number, an array, or to a structure containing an arbitrary set of parameters</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv430initializeReconstructionSIRENAP21ReconstructInitSIRENAPCcP8fitsfilePCcPCcidiidiiPcddPCcPcPcPcddPciiiicPcPcicdcciiPCciicidPCciiddPCcPCi">
<span id="_CPPv330initializeReconstructionSIRENAP21ReconstructInitSIRENAPCcP8fitsfilePCcPCcidiidiiPcddPCcPcPcPcddPciiiicPcPcicdcciiPCciicidPCciiddPCcPCi"></span><span id="_CPPv230initializeReconstructionSIRENAP21ReconstructInitSIRENAPCcP8fitsfilePCcPCcidiidiiPcddPCcPcPcPcddPciiiicPcPcicdcciiPCciicidPCciiddPCcPCi"></span><span id="initializeReconstructionSIRENA__ReconstructInitSIRENAP.cPC.fitsfileP.cPC.cPC.i.double.i.i.double.i.i.cP.double.double.cPC.cP.cP.cP.double.double.cP.i.i.i.i.c.cP.cP.i.c.double.c.c.i.i.cPC.i.i.c.i.double.cPC.i.i.double.double.cPC.iPC"></span><span class="n"><span class="pre">extern_C_void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">initializeReconstructionSIRENA</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">record_file</span></span>, <span class="n"><span class="pre">fitsfile</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">fptr</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">library_file</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">event_file</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pulse_length</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">scaleFactor</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samplesUp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samplesDown</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nSgms</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">detectSP</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">opmode</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">detectionMode</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">LrsT</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">LbT</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">noise_file</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">filter_domain</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">filter_method</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">energy_method</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">filtEev</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">Ifit</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ofnoise</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lagsornot</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nLags</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">Fitting35</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">ofiter</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">oflib</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ofinterp</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">oflength_strategy</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">oflength</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">preBuffer</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">monoenergy</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">hduPRECALWN</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">hduPRCLOFWM</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">largeFilter</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">interm</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">detectFile</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">errorT</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">Sum0Filt</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">clobber</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">maxPulsesPerRecord</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">SaturationValue</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">tstartPulse1</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">tstartPulse2</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">tstartPulse3</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">energyPCA1</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">energyPCA2</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">XMLFile</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">status</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430initializeReconstructionSIRENAP21ReconstructInitSIRENAPCcP8fitsfilePCcPCcidiidiiPcddPCcPcPcPcddPciiiicPcPcicdcciiPCciicidPCciiddPCcPCi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>integraSIRENA.cpp</em></p>
<p>This function initializes the structure <em>ReconstructInitSIRENA</em> with the variables required for SIRENA reconstruction. The values are taken from the input parameters.</p>
<ul class="simple">
<li><p>Load <em>LibraryCollection</em> structure if library file exists</p></li>
<li><p>Load <em>NoiseSpec</em> structure</p></li>
<li><p>Fill in the matrix <em>tstartPulse1_i</em> if <em>tstartPulse1</em> = nameFile Start time (in samples) of the first pulse (0  if detection should be performed by the system; greater than 0 if provided by the user) or file name containing the tstart (in seconds) of every pulse, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-tstartPulse1"><code class="xref std std-option docutils literal notranslate"><span class="pre">tstartPulse1</span></code></a></p></li>
<li><p>Fill in <em>reconstruct_init</em></p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA* <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values)</p>
</div></blockquote>
<p>char* const <strong>record_file</strong></p>
<blockquote>
<div><p>Filename of input data file with records, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-RecordFile"><code class="xref std std-option docutils literal notranslate"><span class="pre">RecordFile</span></code></a></p>
</div></blockquote>
<p>fitsfile* <strong>fptr</strong></p>
<blockquote>
<div><p>FITS object with pointer to data file</p>
</div></blockquote>
<p>char* const <strong>library_file</strong></p>
<blockquote>
<div><p>File name of calibration library, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-LibraryFile"><code class="xref std std-option docutils literal notranslate"><span class="pre">LibraryFile</span></code></a></p>
</div></blockquote>
<p>char* const <strong>event_file</strong></p>
<blockquote>
<div><p>File name of output events (with reconstructed energy), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-TesEventFile"><code class="xref std std-option docutils literal notranslate"><span class="pre">TesEventFile</span></code></a></p>
</div></blockquote>
<p>int <strong>pulse_length</strong></p>
<blockquote>
<div><p>Pulse length, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLengthNotPadded"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLengthNotPadded</span></code></a></p>
</div></blockquote>
<p>double <strong>scaleFactor</strong></p>
<blockquote>
<div><p>Detection scale factor for initial filtering, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-0"><code class="xref std std-option docutils literal notranslate"><span class="pre">scaleFactor</span></code></a></p>
</div></blockquote>
<p>int <strong>samplesUp</strong></p>
<blockquote>
<div><p>Number of samples for threshold trespassing, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-1"><code class="xref std std-option docutils literal notranslate"><span class="pre">samplesUp</span></code></a></p>
</div></blockquote>
<p>int <strong>samplesDown</strong></p>
<blockquote>
<div><p>Number of samples below the threshold to look for other pulse, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-samplesDown"><code class="xref std std-option docutils literal notranslate"><span class="pre">samplesDown</span></code></a></p>
</div></blockquote>
<p>double <strong>nSgms</strong></p>
<blockquote>
<div><p>Number of standard deviations in the kappa-clipping process for threshold estimation, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-2"><code class="xref std std-option docutils literal notranslate"><span class="pre">nSgms</span></code></a></p>
</div></blockquote>
<p>int <strong>detectSP</strong></p>
<blockquote>
<div><p>Detect secondary pulses (1) or not (0), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-detectSP"><code class="xref std std-option docutils literal notranslate"><span class="pre">detectSP</span></code></a></p>
</div></blockquote>
<p>int <strong>opmode</strong></p>
<blockquote>
<div><p>Calibration run (0) or energy reconstruction run (1), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a></p>
</div></blockquote>
<p>char* <strong>detectionMode</strong></p>
<blockquote>
<div><p>Adjusted Derivative (AD) or Single Threshold Crossing (STC), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-detectionMode"><code class="xref std std-option docutils literal notranslate"><span class="pre">detectionMode</span></code></a></p>
</div></blockquote>
<p>double <strong>LrsT</strong></p>
<blockquote>
<div><p>Running sum length for the RS raw energy estimation (seconds), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-LrsT"><code class="xref std std-option docutils literal notranslate"><span class="pre">LrsT</span></code></a></p>
</div></blockquote>
<p>double <strong>LbT</strong></p>
<blockquote>
<div><p>Baseline averaging length (seconds), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-LbT"><code class="xref std std-option docutils literal notranslate"><span class="pre">LbT</span></code></a></p>
</div></blockquote>
<p>char* const <strong>noise_file</strong></p>
<blockquote>
<div><p>Noise file, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-NoiseFile"><code class="xref std std-option docutils literal notranslate"><span class="pre">NoiseFile</span></code></a></p>
</div></blockquote>
<p>char* <strong>filter_domain</strong></p>
<blockquote>
<div><p>Filtering Domain: Time (<strong>T</strong>) or Frequency (<strong>F</strong>), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterDomain"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterDomain</span></code></a></p>
</div></blockquote>
<p>char* <strong>filter_method</strong></p>
<blockquote>
<div><p>Filtering Method: <strong>F0</strong> (deleting the zero frequency bin) or <strong>F0</strong> (deleting the baseline), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterMethod"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterMethod</span></code></a></p>
</div></blockquote>
<p>char* <strong>energy_method</strong></p>
<blockquote>
<div><p>Energy calculation Method: <strong>OPTFILT</strong>, <strong>WEIGHT</strong>, <strong>WEIGHTN</strong>, <strong>I2R</strong>, <strong>I2RFITTED</strong> or <strong>PCA</strong>, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a></p>
</div></blockquote>
<p>double <strong>filtEev</strong></p>
<blockquote>
<div><p>Energy of the filters of the library to be used to calculate energy (only for OPTFILT, I2R and I2RFITTED), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-filtEeV"><code class="xref std std-option docutils literal notranslate"><span class="pre">filtEeV</span></code></a></p>
</div></blockquote>
<p>double <strong>Ifit</strong></p>
<blockquote>
<div><p>Constant to apply the I2RFITTED conversion</p>
</div></blockquote>
<p>char* <strong>ofnoise</strong></p>
<blockquote>
<div><p>For optimal filtering:  <strong>NSD</strong> or <strong>WEIGHTM</strong>, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFNoise"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFNoise</span></code></a></p>
</div></blockquote>
<p>int <strong>lagsornot</strong></p>
<blockquote>
<div><p>Lags (1) or no lags (0), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-LagsOrNot"><code class="xref std std-option docutils literal notranslate"><span class="pre">LagsOrNot</span></code></a></p>
</div></blockquote>
<p>int <strong>nLags</strong></p>
<blockquote>
<div><p>Number of lags (positive odd number)</p>
</div></blockquote>
<p>int <strong>Fitting35</strong></p>
<blockquote>
<div><p>Number of lags to analytically calculate a parabola (3) or to fit a parabola (5)</p>
</div></blockquote>
<p>int <strong>ofiter</strong></p>
<blockquote>
<div><p>Iterate (1) or not iterate (0), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFIter"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFIter</span></code></a></p>
</div></blockquote>
<p>char <strong>oflib</strong></p>
<blockquote>
<div><p>Work or not with a library with optimal filters (1/0)</p>
</div></blockquote>
<p>char* <strong>ofinterp</strong></p>
<blockquote>
<div><p>Optimal Filter by using the Matched Filter or the DAB as matched filter (<em>MF</em>/<em>DAB</em>)
It has been fixed in <a class="reference internal" href="SIRENAcommandline.html#tesreconstruction"><span class="std std-ref">tesreconstruction</span></a> as <em>DAB</em></p>
</div></blockquote>
<p>char* <strong>oflength_strategy</strong></p>
<blockquote>
<div><p>Optimal Filter length Strategy: <strong>FREE</strong>, <strong>BYGRADE</strong> or <strong>FIXED</strong>, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFStrategy"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFStrategy</span></code></a></p>
</div></blockquote>
<p>int <strong>oflength</strong></p>
<blockquote>
<div><p>Optimal Filter length (taken into account if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFStrategy"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFStrategy</span></code></a> = <strong>FIXED</strong>), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLength</span></code></a></p>
</div></blockquote>
<p>char <strong>preBuffer</strong></p>
<blockquote>
<div><p>Some samples added or not before the starting time of a pulse (number of added samples read from the xml file)</p>
</div></blockquote>
<p>double <strong>monoenergy</strong></p>
<blockquote>
<div><p>Monochromatic energy of input file in eV (only for library creation, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-monoenergy"><code class="xref std std-option docutils literal notranslate"><span class="pre">monoenergy</span></code></a></p>
</div></blockquote>
<p>int <strong>hduPRECALWN</strong></p>
<blockquote>
<div><p>Add or not the <em>PRECALWN</em> HDU in the library file (yes/no) (only for library creation, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRECALWN"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRECALWN</span></code></a></p>
</div></blockquote>
<p>int <strong>hduPRCLOFWM</strong></p>
<blockquote>
<div><p>Add or not the <em>PRCLOFWM</em> HDU in the library file (yes/no) (only for library creation, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRCLOFWM"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRCLOFWM</span></code></a></p>
</div></blockquote>
<p>int <strong>largeFilter</strong></p>
<blockquote>
<div><p>Length of the longest fixed filters (only for library creation, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a></p>
</div></blockquote>
<p>int <strong>interm</strong></p>
<blockquote>
<div><p>Write or not intermediate files (1/0), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-intermediate"><code class="xref std std-option docutils literal notranslate"><span class="pre">intermediate</span></code></a></p>
</div></blockquote>
<p>char* const <strong>detectFile</strong></p>
<blockquote>
<div><p>Intermediate detections file (if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-intermediate"><code class="xref std std-option docutils literal notranslate"><span class="pre">intermediate</span></code></a> = 1), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-detectFile"><code class="xref std std-option docutils literal notranslate"><span class="pre">detectFile</span></code></a></p>
</div></blockquote>
<p>int <strong>errorT</strong></p>
<blockquote>
<div><p>Additional error (in samples) added to the detected time (logically, it changes the reconstructed energies)</p>
</div></blockquote>
<p>int <strong>Sum0Filt</strong></p>
<blockquote>
<div><p>0-padding: Subtract the sum of the filter (1) or not (0)</p>
</div></blockquote>
<p>char <strong>clobber</strong></p>
<blockquote>
<div><p>Overwrite or not output files if exist (yes/no), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-5"><code class="xref std std-option docutils literal notranslate"><span class="pre">clobber</span></code></a></p>
</div></blockquote>
<p>int <strong>maxPulsesPerRecord</strong></p>
<blockquote>
<div><p>Default size of the event list, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-EventListSize"><code class="xref std std-option docutils literal notranslate"><span class="pre">EventListSize</span></code></a></p>
</div></blockquote>
<p>double <strong>SaturationValue</strong></p>
<blockquote>
<div><p>Saturation level of the ADC curves</p>
</div></blockquote>
<p>int <strong>tstartPulse1</strong></p>
<blockquote>
<div><p>Start time (in samples) of the first pulse (0 if detection should be performed by the system; greater than 0 if provided by the user) or file name containing the tstart (in seconds) of every pulse, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-tstartPulse1"><code class="xref std std-option docutils literal notranslate"><span class="pre">tstartPulse1</span></code></a></p>
</div></blockquote>
<p>int <strong>tstartPulse2</strong></p>
<blockquote>
<div><p>Tstart (samples) of the second pulse, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-tstartPulse2"><code class="xref std std-option docutils literal notranslate"><span class="pre">tstartPulse2</span></code></a></p>
</div></blockquote>
<p>int <strong>tstartPulse3</strong></p>
<blockquote>
<div><p>Tstart (samples) of the third pulse (if 0 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> PAIRS, if not 0 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> TRIOS), <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-tstartPulse3"><code class="xref std std-option docutils literal notranslate"><span class="pre">tstartPulse3</span></code></a></p>
</div></blockquote>
<p>double <strong>energyPCA1</strong></p>
<blockquote>
<div><p>First energy (only for <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>PCA</strong>)</p>
</div></blockquote>
<p>double <strong>energyPCA2</strong></p>
<blockquote>
<div><p>Second energy (only for <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>PCA</strong>)</p>
</div></blockquote>
<p>char * const <strong>XMLFile</strong></p>
<blockquote>
<div><p>File name of the XML input file with instrument definition</p>
</div></blockquote>
<p>int* const <strong>status</strong></p>
<blockquote>
<div><p>Input/Output status</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417InitialTriggeringP10gsl_vectordddddPbPiPiPdi">
<span id="_CPPv317InitialTriggeringP10gsl_vectordddddPbPiPiPdi"></span><span id="_CPPv217InitialTriggeringP10gsl_vectordddddPbPiPiPdi"></span><span id="InitialTriggering__gsl_vectorP.double.double.double.double.double.bP.iP.iP.doubleP.i"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InitialTriggering</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">derivative</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nSgms</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">scalefactor</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samplingRate</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">stopcriteriamkc</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">kappamkc</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">triggerCondition</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tstart</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">flagTruncated</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">threshold</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">tstartProvided</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417InitialTriggeringP10gsl_vectordddddPbPiPiPdi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function finds the first pulse in the input vector, first derivative of the (low-pass filtered) record.</p>
<p>Steps:</p>
<ul>
<li><p>Declare variables</p></li>
<li><p>Stablish the <a class="reference internal" href="#_CPPv417InitialTriggeringP10gsl_vectordddddPbPiPiPdi" title="InitialTriggering::threshold"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">threshold</span></code></a></p></li>
<li><p>It is necessary to find the tstart of the first pulse…</p>
<p>Obtain tstart of the first pulse in the derivative if <img class="math" src="_images/math/8c93182fa76ae4f132c0e44e8de6d89c38a362b3.png" alt="derivative_i&gt;threshold"/></p>
</li>
<li><p>… Or to use the tstart provided as input parameter</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>derivative</strong></p>
<blockquote>
<div><p>First derivative of the (low-pass filtered) record</p>
</div></blockquote>
<p>double <strong>nSgms</strong></p>
<blockquote>
<div><p>Number of <em>Sigmas</em> to establish the threshold (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-2"><code class="xref std std-option docutils literal notranslate"><span class="pre">nSgms</span></code></a>)</p>
</div></blockquote>
<p>double <strong>scalefactor</strong></p>
<blockquote>
<div><p>Scale factor to calculate the LPF box-car length (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-0"><code class="xref std std-option docutils literal notranslate"><span class="pre">scaleFactor</span></code></a>)</p>
</div></blockquote>
<p>double <strong>samplingRate</strong></p>
<blockquote>
<div><p>Sampling rate</p>
</div></blockquote>
<p>double <strong>stopcriteriamkc</strong></p>
<blockquote>
<div><p>Used in <a class="reference internal" href="#_CPPv419medianKappaClippingP10gsl_vectordddiPd" title="medianKappaClipping"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">medianKappaClipping()</span></code></a> (%)</p>
</div></blockquote>
<p>double <strong>kappamkc</strong></p>
<blockquote>
<div><p>Used in <a class="reference internal" href="#_CPPv419medianKappaClippingP10gsl_vectordddiPd" title="medianKappaClipping"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">medianKappaClipping()</span></code></a></p>
</div></blockquote>
<p>bool* <strong>triggerCondition</strong></p>
<blockquote>
<div><p>True <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The algorithm has found the first event</p>
<p>False <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The algorithm has not found any event</p>
</div></blockquote>
<p>int* <strong>tstart</strong></p>
<blockquote>
<div><p>First event tstart (in samples)</p>
</div></blockquote>
<p>int* <strong>flagTruncated</strong></p>
<blockquote>
<div><p>Flag indicating if the event is truncated</p>
</div></blockquote>
<p>double* <strong>threshold</strong></p>
<blockquote>
<div><p>Calculated threshold  (output parameter because it is necessary out of the function)</p>
</div></blockquote>
<p>int <strong>tstartProvided</strong></p>
<blockquote>
<div><p>Tstart of the first pulse provided as input parameter</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv429IntegrafreeTesEventListSIRENAP12TesEventList">
<span id="_CPPv329IntegrafreeTesEventListSIRENAP12TesEventList"></span><span id="_CPPv229IntegrafreeTesEventListSIRENAP12TesEventList"></span><span id="IntegrafreeTesEventListSIRENA__TesEventListP"></span><span class="n"><span class="pre">extern_C_void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IntegrafreeTesEventListSIRENA</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TesEventList</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">event_list</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429IntegrafreeTesEventListSIRENAP12TesEventList" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file <em>integraSIRENA.cpp</em></p>
<p>This function frees the structure in the input parameter.</p>
<p><strong>Members/Variables</strong></p>
<p>TesEventList* <strong>event_list</strong></p>
<blockquote>
<div><p>Instance of <em>TesEventList</em> structure that contains the information of the reconstructed pulses</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415interactiveParsP7inparami6string">
<span id="_CPPv315interactiveParsP7inparami6string"></span><span id="_CPPv215interactiveParsP7inparami6string"></span><span id="interactivePars__inparamP.i.string"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">interactivePars</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">inparam</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">taskPars</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">np</span></span>, <span class="n"><span class="pre">string</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">task</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415interactiveParsP7inparami6string" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file <em>inoututils.cpp</em></p>
<p>This function reads input parameters interactively (provided by the user or taken as default values).
Used in tool <a class="reference internal" href="SIRENAcommandline.html#gennoisespec"><span class="std std-ref">gennoisespec</span></a>.</p>
<p><strong>Members/Variables</strong></p>
<p>inparam* <strong>taskPars</strong></p>
<blockquote>
<div><p>Instance of <em>inparam</em> structure storing input parameters</p>
</div></blockquote>
<p>int <strong>np</strong></p>
<blockquote>
<div><p>Number of parameters</p>
</div></blockquote>
<p>string <strong>task</strong></p>
<blockquote>
<div><p>Tool name</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414interpolatePOSP10gsl_vectorP10gsl_vectorldPP10gsl_vectorPP10gsl_vector">
<span id="_CPPv314interpolatePOSP10gsl_vectorP10gsl_vectorldPP10gsl_vectorPP10gsl_vector"></span><span id="_CPPv214interpolatePOSP10gsl_vectorP10gsl_vectorldPP10gsl_vectorPP10gsl_vector"></span><span id="interpolatePOS__gsl_vectorP.gsl_vectorP.l.double.gsl_vectorPP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">interpolatePOS</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x_in</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y_in</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">size</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">step</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x_out</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y_out</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414interpolatePOSP10gsl_vectorP10gsl_vectorldPP10gsl_vectorPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function interpolates an input vector (<a class="reference internal" href="#_CPPv414interpolatePOSP10gsl_vectorP10gsl_vectorldPP10gsl_vectorPP10gsl_vector" title="interpolatePOS::x_in"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">x_in</span></code></a>, <a class="reference internal" href="#_CPPv414interpolatePOSP10gsl_vectorP10gsl_vectorldPP10gsl_vectorPP10gsl_vector" title="interpolatePOS::y_in"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">y_in</span></code></a>), creating an output vector (<a class="reference internal" href="#_CPPv414interpolatePOSP10gsl_vectorP10gsl_vectorldPP10gsl_vectorPP10gsl_vector" title="interpolatePOS::x_out"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">x_out</span></code></a>, <a class="reference internal" href="#_CPPv414interpolatePOSP10gsl_vectorP10gsl_vectorldPP10gsl_vectorPP10gsl_vector" title="interpolatePOS::y_out"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">y_out</span></code></a>) with the size and frequency step given. <em>POS</em> comes from the fact that the input spectrum only has positive frequencies (in order to not handle the f=0 bin).</p>
<ul class="simple">
<li><p>Declare and initialize variables</p></li>
<li><p>GSL method applied for interpolatation</p></li>
<li><p>Generate the interpolated output vector</p></li>
<li><p>Free memory</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>x_in</strong></p>
<blockquote>
<div><p>GSL input vector with the abscissas of the vector which is going to be interpolated</p>
</div></blockquote>
<p>gsl_vector* <strong>y_in</strong></p>
<blockquote>
<div><p>GSL input vector with the ordinates of the vector which is going to be interpolated</p>
</div></blockquote>
<p>long <strong>size</strong></p>
<blockquote>
<div><p>Size of the interpolated output vector</p>
</div></blockquote>
<p>double <strong>step</strong></p>
<blockquote>
<div><p>Frequency step of the interpolated output vector</p>
</div></blockquote>
<p>gsl_vector** <strong>x_out</strong></p>
<blockquote>
<div><p>GSL output vector with the abscissas of the interpolated vector</p>
</div></blockquote>
<p>gsl_vector** <strong>y_out</strong></p>
<blockquote>
<div><p>GSL output vector with the ordinates of the interpolated vector</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417interpolate_modelPP10gsl_vectordP10gsl_vectordP10gsl_vectord">
<span id="_CPPv317interpolate_modelPP10gsl_vectordP10gsl_vectordP10gsl_vectord"></span><span id="_CPPv217interpolate_modelPP10gsl_vectordP10gsl_vectordP10gsl_vectord"></span><span id="interpolate_model__gsl_vectorPP.double.gsl_vectorP.double.gsl_vectorP.double"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">interpolate_model</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">modelFound</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">p_model</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">modelIn1</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">p_modelIn1</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">modelIn2</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">p_modelIn2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417interpolate_modelPP10gsl_vectordP10gsl_vectordP10gsl_vectord" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function interpolates the pulse model, <img class="math" src="_images/math/3ea8799a056633b2910c26ca9d9cdcb948ce47ea.png" alt="p(t,E)"/>, between two models of the pulse models library,
<img class="math" src="_images/math/498a9fa96216d0f91dd4afbad9975baf5dac968e.png" alt="p(t,E_1)"/> and <img class="math" src="_images/math/8869cf94a14e1ff2368e6d868a85677c8d87cc43.png" alt="p(t,E_2)"/>, being <img class="math" src="_images/math/cb92797a0b6712cbe97f6b6913bde2d5f33b4cab.png" alt="E_1&lt;E&lt;E_2"/>.</p>
<p>According to the interpolation method:</p>
<div class="math">
<p><img src="_images/math/b6109e8c0be577cfe67a22236f3043e2d7d5324b.png" alt="p(t,E)={\frac{E_2-E}{E_2-E_1}}p(t,E_1)+{\frac{E-E_1}{E_2-E_1}}p(t,E_2)"/></p>
</div><p><strong>Members/Variables</strong></p>
<p>gsl_vector** <strong>modelFound</strong></p>
<blockquote>
<div><p>Found model of the pulse whose <em>energy</em> or <em>maxDER</em> is <a class="reference internal" href="#_CPPv417interpolate_modelPP10gsl_vectordP10gsl_vectordP10gsl_vectord" title="interpolate_model::p_model"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">p_model</span></code></a></p>
</div></blockquote>
<p>double <strong>p_model</strong></p>
<blockquote>
<div><p>Parameter (<em>energy</em> or <em>maxDER</em>) of the pulse whose model is being sought</p>
</div></blockquote>
<p>gsl_vector* <strong>modelIn1</strong></p>
<blockquote>
<div><p>Model of the pulse whose parameter (<em>energy</em> or <em>maxDER</em>) is immediately lower than <a class="reference internal" href="#_CPPv417interpolate_modelPP10gsl_vectordP10gsl_vectordP10gsl_vectord" title="interpolate_model::p_model"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">p_model</span></code></a> in the library FITS file</p>
</div></blockquote>
<p>double <strong>p_modelIn1</strong></p>
<blockquote>
<div><p>Parameter (<em>energy</em> or <em>maxDER</em>) immediately lower than <a class="reference internal" href="#_CPPv417interpolate_modelPP10gsl_vectordP10gsl_vectordP10gsl_vectord" title="interpolate_model::p_model"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">p_model</span></code></a> in the library FITS file</p>
</div></blockquote>
<p>gsl_vector* <strong>modelIn2</strong></p>
<blockquote>
<div><p>Model of the pulse whose parameter (<em>energy</em> or <em>maxDER</em>) is immediately greater than <a class="reference internal" href="#_CPPv417interpolate_modelPP10gsl_vectordP10gsl_vectordP10gsl_vectord" title="interpolate_model::p_model"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">p_model</span></code></a> in the library FITS file</p>
</div></blockquote>
<p>double <strong>p_modelIn2</strong></p>
<blockquote>
<div><p>Parameter (<em>energy</em> or <em>maxDER</em>) immediately greater than <a class="reference internal" href="#_CPPv417interpolate_modelPP10gsl_vectordP10gsl_vectordP10gsl_vectord" title="interpolate_model::p_model"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">p_model</span></code></a> in the library FITS file</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv48isNumber6string">
<span id="_CPPv38isNumber6string"></span><span id="_CPPv28isNumber6string"></span><span id="isNumber__string"></span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">isNumber</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">string</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48isNumber6string" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>genutils.cpp</em></p>
<p>This function returns TRUE if the input string is a number or FALSE if not.</p>
<p><strong>Members/Variables</strong></p>
<p>string <strong>s</strong></p>
<blockquote>
<div><p>Input string</p>
</div></blockquote>
</dd></dl>

<span class="target" id="l"><span id="k"></span><span id="j"></span></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv410loadRecordP9TesRecordPdPP10gsl_vector">
<span id="_CPPv310loadRecordP9TesRecordPdPP10gsl_vector"></span><span id="_CPPv210loadRecordP9TesRecordPdPP10gsl_vector"></span><span id="loadRecord__TesRecordP.doubleP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">loadRecord</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TesRecord</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">record</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">time_record</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">adc_double</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410loadRecordP9TesRecordPdPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This fucntion loads the structure <a class="reference internal" href="#_CPPv410loadRecordP9TesRecordPdPP10gsl_vector" title="loadRecord::record"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">record</span></code></a> into the <a class="reference internal" href="#_CPPv410loadRecordP9TesRecordPdPP10gsl_vector" title="loadRecord::adc_double"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">adc_double</span></code></a> GSL vector.</p>
<p>It checks if the record has been filled out with 0’s <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> It only loads the first values (which are different from 0).</p>
<p><strong>Members/Variables</strong></p>
<p>TesRecord* <strong>record</strong></p>
<blockquote>
<div><p>Member of <em>TesRecord</em> structure that contains the input record</p>
</div></blockquote>
<p>double <strong>time_record</strong></p>
<blockquote>
<div><p>Starting time of the record (output)</p>
</div></blockquote>
<p>gsl_vector** <strong>adc_double</strong></p>
<blockquote>
<div><p>Storage of the record to be processed (input/output)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv410lpf_boxcarPP10gsl_vectorii">
<span id="_CPPv310lpf_boxcarPP10gsl_vectorii"></span><span id="_CPPv210lpf_boxcarPP10gsl_vectorii"></span><span id="lpf_boxcar__gsl_vectorPP.i.i"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">lpf_boxcar</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">invector</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">szVct</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">sampleRate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410lpf_boxcarPP10gsl_vectorii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function implements a low pass filtering as a box-car function in time.</p>
<p>The box-car function is a temporal average window:</p>
<div class="math">
<p><img src="_images/math/1e2f807e2949bc8fa26fcd36a0f7f45420cb3a88.png" alt="x_{i-1}=\sum_{0}^{n-1}\frac{I_i}{n}"/></p>
</div><div class="math">
<p><img src="_images/math/ad83ddfc04c6069db22b203e66c68c8d10b38c6b.png" alt="x_i=\sum_{1}^{n}\frac{I_i}{n}"/></p>
</div><p>If the cut frequency of the filter is <img class="math" src="_images/math/c8d7043cd790863297530ec1d9b6b8e7391c2aa9.png" alt="\mathit{f_c}"/>, the box-car length (<em>n</em>) is</p>
<div class="math">
<p><img src="_images/math/0af6f6c9325768bbd7532c203c7f56758547a7b3.png" alt="\frac{1}{f_c}samprate"/></p>
</div><p>Steps:</p>
<ul class="simple">
<li><p>Declare variables</p></li>
<li><p>Define the LPF (frequency domain) and the box-car function (time domain)</p></li>
<li><p>It is going to work with a longer vector to not have fake results for the last <em>boxLength</em> windows</p></li>
<li><p>Apply the box-car window by shifting it along the (lengthened) input vector</p></li>
<li><p>Free allocated GSL vectors</p></li>
</ul>
<p>The function returns:</p>
<blockquote>
<div><ul class="simple">
<li><p>1: Function cannot run</p></li>
<li><p>3: Cut-off frequency too high <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Equivalent to not filter</p></li>
<li><p>4: Cut-off frequency too low</p></li>
</ul>
</div></blockquote>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector** <strong>invector</strong></p>
<blockquote>
<div><p>Input/Output GSL vector (non-filtered input vector/filtered input vector)</p>
</div></blockquote>
<p>int <strong>szVct</strong></p>
<blockquote>
<div><p>Size of <a class="reference internal" href="#_CPPv410lpf_boxcarPP10gsl_vectorii" title="lpf_boxcar::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a></p>
</div></blockquote>
<p>int <strong>sampleRate</strong></p>
<blockquote>
<div><p>Sampling rate (samples/s)</p>
</div></blockquote>
</dd></dl>

<span class="target" id="m"></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413matrix2vectorP10gsl_matrixPP10gsl_vector">
<span id="_CPPv313matrix2vectorP10gsl_matrixPP10gsl_vector"></span><span id="_CPPv213matrix2vectorP10gsl_matrixPP10gsl_vector"></span><span id="matrix2vector__gsl_matrixP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">matrix2vector</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">matrixin</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vectorout</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413matrix2vectorP10gsl_matrixPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function converts an input square matrix <img class="math" src="_images/math/65c4484545603a3a8dfc82d595cc28b897032353.png" alt="[n \times n]"/> into an output <img class="math" src="_images/math/d8a059564f5703504a6a97d5b2b50b206645b996.png" alt="n^2"/> vector. It puts the first row of the matrix (<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> elements) in the first <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> elements of the vector (from <img class="math" src="_images/math/31fdf41b39df23c95e52c5aef07f59d9adf82f3c.png" alt="0"/> to <img class="math" src="_images/math/a44c09dc69d687fd66b7a1a12197c0299aa5db1c.png" alt="n-1"/>), the second row of the matrix in the elements from <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> to <img class="math" src="_images/math/559743c4738bf906182227658a62c8711f9319db.png" alt="2n-1"/> of the vector and so on.</p>
<p><strong>Members/Variables</strong></p>
<p>gsl_matrix* <strong>matrixin</strong></p>
<blockquote>
<div><p>GSL input square matrix <img class="math" src="_images/math/65c4484545603a3a8dfc82d595cc28b897032353.png" alt="[n \times n]"/></p>
</div></blockquote>
<p>gsl_vector** <strong>vectorout</strong></p>
<blockquote>
<div><p>GSL output vector whose length is <img class="math" src="_images/math/d8a059564f5703504a6a97d5b2b50b206645b996.png" alt="n^2"/></p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419medianKappaClippingP10gsl_vectordddiPd">
<span id="_CPPv319medianKappaClippingP10gsl_vectordddiPd"></span><span id="_CPPv219medianKappaClippingP10gsl_vectordddiPd"></span><span id="medianKappaClipping__gsl_vectorP.double.double.double.i.doubleP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">medianKappaClipping</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">invector</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">kappa</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">stopCriteria</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nSigmas</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">boxLPF</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">threshold</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419medianKappaClippingP10gsl_vectordddiPd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function calculates a threshold in the first derivative of the record by using a Kappa-clipping method
(replacing points beyond <img class="math" src="_images/math/0f4e9bc6f7b27710dc552d3cdd68b0f6a7a6db61.png" alt="mean\pm kappa \cdot sigma"/> with the median).</p>
<p>Mean and sigma are calculated and values of <a class="reference internal" href="#_CPPv419medianKappaClippingP10gsl_vectordddiPd" title="medianKappaClipping::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a> out of <img class="math" src="_images/math/41ce4cdb1e5cbd82cfd3c75dc6bdf460c056b05f.png" alt="(mean+kappa \cdot sigma,mean-kappa \cdot sigma)"/> are replaced
with the median (it is trying to look for the baseline). And this process is iteratively repeated until there are
no points beyond <img class="math" src="_images/math/ed10cfb754e6c026a5e3211214ecbb367545694b.png" alt="mean \pm kappa \cdot sigma"/>. Finally, the threshold is calculated as <img class="math" src="_images/math/844949ef5c6d2489cc213f232d8b76ed85b22354.png" alt="mean+nSigmas \cdot sigma"/> (‘+’ is used because
<cite>if there are pulses in the input invector they are always positive</cite>).</p>
<p>Steps:</p>
<ul class="simple">
<li><p>Declare variables</p></li>
<li><p>Calculate the median</p></li>
<li><p>Iterate until there are no points out of the maximum excursion ( <img class="math" src="_images/math/fc071dd9bdfea8594ae41578c64fd23098d665db.png" alt="kappa \cdot sigma"/>)</p></li>
<li><p>Establish the threshold as mean+nSigmas*sigma</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>invector</strong></p>
<blockquote>
<div><p>First derivative of the (filtered) record</p>
</div></blockquote>
<p>double <strong>kappa</strong></p>
<blockquote>
<div><p>Value to establish the range around of the mean</p>
</div></blockquote>
<p>double <strong>stopCriteria</strong></p>
<blockquote>
<div><p>It is given in %</p>
</div></blockquote>
<p>double <strong>nSigmas</strong></p>
<blockquote>
<div><p>Times sigma to calculate threshold as <img class="math" src="_images/math/844949ef5c6d2489cc213f232d8b76ed85b22354.png" alt="mean+nSigmas \cdot sigma"/></p>
</div></blockquote>
<p>int <strong>boxLPF</strong></p>
<blockquote>
<div><p>Length of the low-pass filtering box-car</p>
</div></blockquote>
<p>double* <strong>threshold</strong></p>
<blockquote>
<div><p>Calculated threshold</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv430medianKappaClipping_noiseSigmaP10gsl_vectordddPdPd">
<span id="_CPPv330medianKappaClipping_noiseSigmaP10gsl_vectordddPdPd"></span><span id="_CPPv230medianKappaClipping_noiseSigmaP10gsl_vectordddPdPd"></span><span id="medianKappaClipping_noiseSigma__gsl_vectorP.double.double.double.doubleP.doubleP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">medianKappaClipping_noiseSigma</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">invector</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">kappa</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">stopCriteria</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nSigmas</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">mean</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">sigma</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430medianKappaClipping_noiseSigmaP10gsl_vectordddPdPd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>gennoisespec.cpp</em></p>
<p>This function provides the mean and the sigma of an input vector (with noise sigmas) by using a Kappa-clipping
method (replacing points beyond <img class="math" src="_images/math/0f4e9bc6f7b27710dc552d3cdd68b0f6a7a6db61.png" alt="mean\pm kappa \cdot sigma"/> with the median).</p>
<p>First, mean and sigma are calculated and <a class="reference internal" href="#_CPPv430medianKappaClipping_noiseSigmaP10gsl_vectordddPdPd" title="medianKappaClipping_noiseSigma::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a> values out of <img class="math" src="_images/math/41ce4cdb1e5cbd82cfd3c75dc6bdf460c056b05f.png" alt="(mean+kappa \cdot sigma,mean-kappa \cdot sigma)"/> are replaced
with the median (it is trying to look for the baseline). And this process is iteratively repeated until there are
no points beyond <img class="math" src="_images/math/ed10cfb754e6c026a5e3211214ecbb367545694b.png" alt="mean \pm kappa \cdot sigma"/>. Finally, the mean and sigma of the resulting vector are provided.</p>
<p>Steps:</p>
<ul class="simple">
<li><p>Declare variables</p></li>
<li><p>Calculate the median</p></li>
<li><p>Iterate until there are no points out of the maximum excursion ( <img class="math" src="_images/math/fc071dd9bdfea8594ae41578c64fd23098d665db.png" alt="kappa \cdot sigma"/>)</p></li>
<li><p>Calculate mean and sigma</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>invector</strong></p>
<blockquote>
<div><p>First derivative of the (filtered) record</p>
</div></blockquote>
<p>double <strong>kappa</strong></p>
<blockquote>
<div><p>Value to establish the range around of the mean</p>
</div></blockquote>
<p>double <strong>stopCriteria</strong></p>
<blockquote>
<div><p>It is given in %</p>
</div></blockquote>
<p>double <strong>nSigmas</strong></p>
<blockquote>
<div><p>Times sigma to calculate threshold as <img class="math" src="_images/math/844949ef5c6d2489cc213f232d8b76ed85b22354.png" alt="mean+nSigmas \cdot sigma"/></p>
</div></blockquote>
<p>double* <strong>mean</strong></p>
<blockquote>
<div><p>Mean value of the <a class="reference internal" href="#_CPPv430medianKappaClipping_noiseSigmaP10gsl_vectordddPdPd" title="medianKappaClipping_noiseSigma::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a> (no points beyond <img class="math" src="_images/math/ed10cfb754e6c026a5e3211214ecbb367545694b.png" alt="mean \pm kappa \cdot sigma"/>)</p>
</div></blockquote>
<p>double* <strong>sigma</strong></p>
<blockquote>
<div><p>Sigma value of the <a class="reference internal" href="#_CPPv430medianKappaClipping_noiseSigmaP10gsl_vectordddPdPd" title="medianKappaClipping_noiseSigma::invector"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">invector</span></code></a> (no points beyond <img class="math" src="_images/math/ed10cfb754e6c026a5e3211214ecbb367545694b.png" alt="mean \pm kappa \cdot sigma"/>)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv48MyAssertiPc">
<span id="_CPPv38MyAssertiPc"></span><span id="_CPPv28MyAssertiPc"></span><span id="MyAssert__i.cP"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">MyAssert</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">expr</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">msg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48MyAssertiPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tesreconstruction.c</em></p>
<p>This function displays an error message if the condition in <a class="reference internal" href="#_CPPv48MyAssertiPc" title="MyAssert::expr"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">expr</span></code></a> is true.</p>
<p><strong>Members/Variables</strong></p>
<p>int <strong>expr</strong></p>
<blockquote>
<div><p>Condition to be true in order to display the error message</p>
</div></blockquote>
<p>char* msg</p>
<blockquote>
<div><p>Message to be displayed</p>
</div></blockquote>
</dd></dl>

<span class="target" id="n"></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422newOptimalFilterSIRENAPCi">
<span id="_CPPv322newOptimalFilterSIRENAPCi"></span><span id="_CPPv222newOptimalFilterSIRENAPCi"></span><span id="newOptimalFilterSIRENA__iPC"></span><span class="n"><span class="pre">extern_C_OptimalFilterSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">newOptimalFilterSIRENA</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">status</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422newOptimalFilterSIRENAPCi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>integraSIRENA.cpp</em></p>
<p>Constructor. It returns a pointer to an empty <em>OptimalFilterSIRENA</em> data structure.</p>
<p><strong>Members/Variables</strong></p>
<p>int* const <strong>status</strong></p>
<blockquote>
<div><p>Input/output status</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419newPulsesCollectionPCi">
<span id="_CPPv319newPulsesCollectionPCi"></span><span id="_CPPv219newPulsesCollectionPCi"></span><span id="newPulsesCollection__iPC"></span><span class="n"><span class="pre">extern_C_PulsesCollection</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">newPulsesCollection</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">status</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419newPulsesCollectionPCi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>integraSIRENA.cpp</em></p>
<p>Constructor. It returns a pointer to an empty <em>PulsesCollection</em> data structure.</p>
<p><strong>Members/Variables</strong></p>
<p>int* const <strong>status</strong></p>
<blockquote>
<div><p>Input/output status</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424newReconstructInitSIRENAPCi">
<span id="_CPPv324newReconstructInitSIRENAPCi"></span><span id="_CPPv224newReconstructInitSIRENAPCi"></span><span id="newReconstructInitSIRENA__iPC"></span><span class="n"><span class="pre">extern_C_ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">newReconstructInitSIRENA</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">status</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424newReconstructInitSIRENAPCi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file <em>integraSIRENA.cpp</em></p>
<p>Constructor. It returns a pointer to an empty <em>ReconstructInitSIRENA</em> data structure.</p>
<p><strong>Members/Variables</strong></p>
<p>int* const <strong>status</strong></p>
<blockquote>
<div><p>Input/output status</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv48noDetectP10gsl_vectorP21ReconstructInitSIRENAPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vector">
<span id="_CPPv38noDetectP10gsl_vectorP21ReconstructInitSIRENAPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vector"></span><span id="_CPPv28noDetectP10gsl_vectorP21ReconstructInitSIRENAPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vector"></span><span id="noDetect__gsl_vectorP.ReconstructInitSIRENAP.iP.gsl_vectorPP.gsl_vectorPP.gsl_vectorPP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">noDetect</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">der</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">numberPulses</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tstartgsl</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">flagTruncated</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">maxDERgsl</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">samp1DERgsl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48noDetectP10gsl_vectorP21ReconstructInitSIRENAPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function runs if the starting time of the pulses are agiven as input parameters (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-tstartPulse1"><code class="xref std std-option docutils literal notranslate"><span class="pre">tstartPulse1</span></code></a> != 0).
It looks for the maximum of the derivative of the pulse and the average of the first 4 samples of the derivative of the pulse.</p>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>der</strong></p>
<blockquote>
<div><p>First derivative of the (low-pass filtered) record</p>
</div></blockquote>
<p>ReconstructInitSIRENA* <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values)</p>
</div></blockquote>
<p>int* <strong>numberPulses</strong></p>
<blockquote>
<div><p>Number of events</p>
</div></blockquote>
<p>gsl_vector** <strong>tstartgsl</strong></p>
<blockquote>
<div><p>Starting time of the events (in samples)</p>
</div></blockquote>
<p>gsl_vector** <strong>flagTruncated</strong></p>
<blockquote>
<div><p>Flag indicating if the event is truncated (inside this function only initial truncated pulses are classified)</p>
</div></blockquote>
<p>gsl_vector** <strong>maxDERgsl</strong></p>
<blockquote>
<div><p>Maximum of the derivative of the event</p>
</div></blockquote>
<p>gsl_vector** <strong>samp1DERgsl</strong></p>
<blockquote>
<div><p>Average of the first 4 samples of the derivative of the event</p>
</div></blockquote>
</dd></dl>

<span class="target" id="p"><span id="o"></span></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419obtainRiseFallTimesP10gsl_vectordP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectoriPP10gsl_vectorPP10gsl_vector">
<span id="_CPPv319obtainRiseFallTimesP10gsl_vectordP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectoriPP10gsl_vectorPP10gsl_vector"></span><span id="_CPPv219obtainRiseFallTimesP10gsl_vectordP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectoriPP10gsl_vectorPP10gsl_vector"></span><span id="obtainRiseFallTimes__gsl_vectorP.double.gsl_vectorP.gsl_vectorP.gsl_vectorP.gsl_vectorP.i.gsl_vectorPP.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">obtainRiseFallTimes</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">recordNOTFILTERED</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samprate</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tstartgsl</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tendgsl</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">Bgsl</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">Lbgsl</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">numPulses</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tauRisegsl</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tauFallgsl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419obtainRiseFallTimesP10gsl_vectordP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectoriPP10gsl_vectorPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function provides an estimation of the rise and fall time of the detected pulses in a record.</p>
<ul class="simple">
<li><p>Find the maximum of each pulse: <em>amax</em></p></li>
<li><p>Baseline of each pulse: <em>abase</em></p></li>
<li><dl class="simple">
<dt>Find the first sample in the rising part above the 10% and 50%: <em>t10</em> and <em>t50</em></dt><dd><ul>
<li><p>Line by using 2 points: <em>(t10,a10)</em> and <em>(t50,a50)</em></p></li>
<li><p><em>t0 (t0,abase)</em></p></li>
<li><p><em>tmax (tmax,amax)</em></p></li>
<li><p>Rise time = <em>tmax-t0</em></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Find the first sample in the decreasing part below the 50% and 10%: <em>t50</em> and <em>t10</em></dt><dd><ul>
<li><p>Line by using 2 points: <em>(t50,a50)</em> and <em>(t10,a10)</em></p></li>
<li><p><em>t0 (t0,abase)</em></p></li>
<li><p><em>tmax (tmax,amax)</em></p></li>
<li><p>Fall time = <em>t0-tmax</em></p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>recordNOTFILTERED</strong></p>
<blockquote>
<div><p>Record neither low-pass filtered nor differentiated</p>
</div></blockquote>
<p>double <strong>samprate</strong></p>
<blockquote>
<div><p>Sampling rate</p>
</div></blockquote>
<p>gsl_vector* <strong>tstartgsl</strong></p>
<blockquote>
<div><p>Starting time of the detected pulses in the record (samples)</p>
</div></blockquote>
<p>gsl_vector* <strong>tendgsl</strong></p>
<blockquote>
<div><p>Ending time of the detected pulses in the record (samples)</p>
</div></blockquote>
<p>gsl_vector* <strong>Bgsl</strong></p>
<blockquote>
<div><p>In general, sum of the <em>Lb</em> digitized data samples of a pulse-free interval immediately before each pulse</p>
</div></blockquote>
<p>gsl_vector* <strong>Lbgsl</strong></p>
<blockquote>
<div><p>Number of samples added in <em>Bgsl</em> for each pulse</p>
</div></blockquote>
<p>int <strong>numPulses</strong></p>
<blockquote>
<div><p>Number of detected pulses in the record</p>
</div></blockquote>
<p>gsl_vector** <strong>tauRisegsl</strong></p>
<blockquote>
<div><p>Rise time of the detected pulses in the record (seconds)</p>
</div></blockquote>
<p>gsl_vector** <strong>tauFallgsl</strong></p>
<blockquote>
<div><p>Fall time of the detected pulses in the record (seconds)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412parabola3PtsP10gsl_vectorP10gsl_vectorPdPdPd">
<span id="_CPPv312parabola3PtsP10gsl_vectorP10gsl_vectorPdPdPd"></span><span id="_CPPv212parabola3PtsP10gsl_vectorP10gsl_vectorPdPdPd"></span><span id="parabola3Pts__gsl_vectorP.gsl_vectorP.doubleP.doubleP.doubleP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">parabola3Pts</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412parabola3PtsP10gsl_vectorP10gsl_vectorPdPdPd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>genutils.cpp</em></p>
<p>This function calculates the equation of a parabola given 3 points.</p>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>x</strong></p>
<blockquote>
<div><p>Input GSL with <em>x</em> vector</p>
</div></blockquote>
<p>gsl_vector* <strong>y</strong></p>
<blockquote>
<div><p>Input GSL with <em>y</em> vector</p>
</div></blockquote>
<p>double* <strong>a</strong></p>
<blockquote>
<div><p>Fit coefficient of the quadratic term</p>
</div></blockquote>
<p>double* <strong>b</strong></p>
<blockquote>
<div><p>Fit coefficient of the linear term</p>
</div></blockquote>
<p>double* <strong>c</strong></p>
<blockquote>
<div><p>Fit coefficient (independent term)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv47polyFitP10gsl_vectorP10gsl_vectorPdPdPd">
<span id="_CPPv37polyFitP10gsl_vectorP10gsl_vectorPdPdPd"></span><span id="_CPPv27polyFitP10gsl_vectorP10gsl_vectorPdPdPd"></span><span id="polyFit__gsl_vectorP.gsl_vectorP.doubleP.doubleP.doubleP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">polyFit</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x_fit</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y_fit</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv47polyFitP10gsl_vectorP10gsl_vectorPdPdPd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>genutils.cpp</em></p>
<p>This function makes a polynomial fitting <img class="math" src="_images/math/d4bf44b2cab9be5a5a36ff7b17464b67de2e9fa6.png" alt="ax^2+bx+c"/> using the regression quadratic analysis. To measure how well model agrees with the data, the chi-square merit function is used, which in this case is</p>
<div class="math">
<p><img src="_images/math/d3e5feebedf21d6a7d9f5e3ecaa307b8bffd2058.png" alt="\chi^2 (a,b,c)= \sum_{i=1}^{N}\left(\frac{y_i-a-bx_i-c{x_i}^2}{\sigma_i}\right)^2"/></p>
</div><p>This equation is minimized to determine <em>a</em>, <em>b</em> and <em>c</em>. Then</p>
<div class="math">
<p><img src="_images/math/9b059aefe9ea35e6ce8ad31c50b8e76dfa15d049.png" alt="\begin{array}{ccc}
S_{(x,x)}=\sum{{x_i}^2}-\frac{(\sum{x_i})^2}{N} &amp; S_{(x^2,y)}=\sum{{x_i}^2y_i}-\frac{\sum{{x_i}^2}\cdot\sum{y_i}}{N}\\
S_{(x,y)}=\sum{x_iy_i}-\frac{\sum{x_i}\cdot\sum{y_i}}{N} &amp; S_{(x^2,x^2)}=\sum{{x_i}^4}-\frac{\left(\sum{{x_i}^2}\right)^2}{N}\\
S_{(x,x^2)}=\sum{{x_i}^3}-\frac{\sum{x_i}\cdot\sum{{x_i}^2}}{N} &amp; \\
\end{array}"/></p>
</div><div class="math">
<p><img src="_images/math/64fa0f1c8c7b2a15058f8b06ffa21cbf644b7d18.png" alt="a = \frac{S_{(x^2,y)}S_{(x,x)}-S_{(x,y)}S_{(x,x^2)}}{S_{(x,x)}S_{(x^2,x^2)} -{\vert S_{(x,x^2)} \vert}^2}"/></p>
</div><div class="math">
<p><img src="_images/math/6355355ddc9c372e9f823fe80d16a880165215b9.png" alt="b = \frac{S_{(x,y)}S_{(x^2,x^2)}-S_{(x^2,y)}S_{(x,x^2)}}{S_{(x,x)}S_{(x^2,x^2)} -{\vert S_{(x,x^2)} \vert}^2}"/></p>
</div><div class="math">
<p><img src="_images/math/18f8ffd9266fbe4056d531db0687af7f18898887.png" alt="c = \frac{\sum{y_i}}{N}-b\frac{\sum{x_i}}{N}-a\frac{\sum{{x_i}^2}}{N}"/></p>
</div><p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>x_fit</strong></p>
<blockquote>
<div><p>Input GSL with <em>x</em> vector</p>
</div></blockquote>
<p>gsl_vector* <strong>y_fit</strong></p>
<blockquote>
<div><p>Input GSL with <em>y</em> vector</p>
</div></blockquote>
<p>double* <strong>a</strong></p>
<blockquote>
<div><p>Fit coefficient of the quadratic term</p>
</div></blockquote>
<p>double* <strong>b</strong></p>
<blockquote>
<div><p>Fit coefficient of the linear term</p>
</div></blockquote>
<p>double* <strong>c</strong></p>
<blockquote>
<div><p>Fit coefficient (independent term)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413polyFitLinearP10gsl_vectorP10gsl_vectorPdPd">
<span id="_CPPv313polyFitLinearP10gsl_vectorP10gsl_vectorPdPd"></span><span id="_CPPv213polyFitLinearP10gsl_vectorP10gsl_vectorPdPd"></span><span id="polyFitLinear__gsl_vectorP.gsl_vectorP.doubleP.doubleP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">polyFitLinear</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x_fit</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y_fit</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">a</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413polyFitLinearP10gsl_vectorP10gsl_vectorPdPd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>genutils.cpp</em></p>
<p>This function makes a linear fitting <img class="math" src="_images/math/a9511f0c5a1c1732ea17b37dbe9b9988f96e3f4c.png" alt="ax+b"/> using the regression linear analysis. To measure how well model agrees with the data, the chi-square merit function is used, which in this case is</p>
<div class="math">
<p><img src="_images/math/4b99e41b5888e3e2d0eeaf1c04bff6f0c625c069.png" alt="\chi^2 (a,b)= \sum_{i=1}^{N}\left(\frac{y_i-a-bx_i}{\sigma_i}\right)^2"/></p>
</div><p>This equation is minimized to determine <em>a</em> and <em>b</em>. Then</p>
<div class="math">
<p><img src="_images/math/f9a9af785ff165873cd135d42e146e89e9a6a70b.png" alt="a = \frac{N \sum{x_i y_i}- \sum{x_i}\sum{y_i}}{N \sum{x_i^2} - {\left(\sum{x_i}\right)}^2}"/></p>
</div><div class="math">
<p><img src="_images/math/18c40c859f83af1229972c2eb25f6327dbb4628e.png" alt="b = \frac{\sum{y_i}}{N}-a \frac{\sum{x_i}}{N}"/></p>
</div><p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>x_fit</strong></p>
<blockquote>
<div><p>Input GSL with <em>x</em> vector</p>
</div></blockquote>
<p>gsl_vector* <strong>y_fit</strong></p>
<blockquote>
<div><p>Input GSL with <em>y</em> vector</p>
</div></blockquote>
<p>double* <strong>a</strong></p>
<blockquote>
<div><p>Fit coefficient of the linear term</p>
</div></blockquote>
<p>double* <strong>b</strong></p>
<blockquote>
<div><p>Fit coefficient (independent term)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411print_errorPCKc6stringi">
<span id="_CPPv311print_errorPCKc6stringi"></span><span id="_CPPv211print_errorPCKc6stringi"></span><span id="print_error__cCPC.string.i"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">print_error</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">func</span></span>, <span class="n"><span class="pre">string</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">message</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">status</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411print_errorPCKc6stringi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>genutils.cpp</em></p>
<p>This function prints out error messages.</p>
<p><strong>Members/Variables</strong></p>
<p>const char* const <strong>func</strong></p>
<blockquote>
<div><p>Function name whose error is printed</p>
</div></blockquote>
<p>string <strong>msg</strong></p>
<blockquote>
<div><p>Error message to be printed</p>
</div></blockquote>
<p>int <strong>status</strong></p>
<blockquote>
<div><p>Status</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv410procRecordPP21ReconstructInitSIRENAddP8fitsfileP10gsl_vectorP10gsl_vectorP16PulsesCollectionliP10gsl_vectoriid">
<span id="_CPPv310procRecordPP21ReconstructInitSIRENAddP8fitsfileP10gsl_vectorP10gsl_vectorP16PulsesCollectionliP10gsl_vectoriid"></span><span id="_CPPv210procRecordPP21ReconstructInitSIRENAddP8fitsfileP10gsl_vectorP10gsl_vectorP16PulsesCollectionliP10gsl_vectoriid"></span><span id="procRecord__ReconstructInitSIRENAPP.double.double.fitsfileP.gsl_vectorP.gsl_vectorP.PulsesCollectionP.l.i.gsl_vectorP.i.i.double"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">procRecord</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">tstartRecord</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samprate</span></span>, <span class="n"><span class="pre">fitsfile</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dtcObject</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">record</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">recordWithoutConvert2R</span></span>, <span class="n"><span class="pre">PulsesCollection</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">foundPulses</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_previousDetectedPulses</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pixid</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">phid</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">oscillations</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nrecord</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">tstartPrevPulse</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv410procRecordPP21ReconstructInitSIRENAddP8fitsfileP10gsl_vectorP10gsl_vectorP16PulsesCollectionliP10gsl_vectoriid" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function processes the input record (detecting the pulses):</p>
<ol class="arabic">
<li><p>Declare and initialize variables</p></li>
<li><p>Allocate GSL vectors</p></li>
<li><p>(Low-pass filtering and) differentiation</p></li>
<li><p>If there are weird oscillations in the record, it is not processed =&gt; numPulses = 0</p></li>
<li><p>Find the events (pulses) in the record</p>
<ul>
<li><p>If production mode (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 1):</p>
<blockquote>
<div><ul>
<li><p>No detect if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-tstartPulse1"><code class="xref std std-option docutils literal notranslate"><span class="pre">tstartPulse1</span></code></a> != 0: ‘noDetect’</p></li>
<li><p>Detect (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-tstartPulse1"><code class="xref std std-option docutils literal notranslate"><span class="pre">tstartPulse1</span></code></a> != 0):</p>
<blockquote>
<div><ul class="simple">
<li><p>‘InitialTriggering’</p></li>
<li><p>‘FindSecondaries’ (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-detectionMode"><code class="xref std std-option docutils literal notranslate"><span class="pre">detectionMode</span></code></a> = AD) or ‘FindSecondariesSTC’ (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-detectionMode"><code class="xref std std-option docutils literal notranslate"><span class="pre">detectionMode</span></code></a> = STC)</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p>If calibration mode (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0): ‘findPulsesCAL’</p></li>
</ul>
</li>
<li><p>Calculate the end time of the found pulses and check if the pulse is saturated</p></li>
<li><p>Calculate the baseline (mean and standard deviation) before a pulse (in general <em>before</em>) <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> To be written in <strong>BSLN</strong> and <strong>RMSBSLN</strong> columns in the output FITS file</p></li>
<li><p>Obtain the approximate rise and fall times of each pulse</p></li>
<li><p>Load the found pulses data in the input/output <em>foundPulses</em> structure</p></li>
<li><p>Write test info (if <em>reconstruct_init-&gt;intermediate</em> = 1)</p></li>
<li><p>Write pulses info in intermediate output FITS file (if <em>reconstruct_init-&gt;intermediate</em> = 1)</p></li>
<li><p>Free allocated GSL vectors</p></li>
</ol>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values)</p>
</div></blockquote>
<p>double <strong>tstartRecord</strong></p>
<blockquote>
<div><p>Starting time of the record (in order to calculate absolute times)</p>
</div></blockquote>
<p>double <strong>samprate</strong></p>
<blockquote>
<div><p>Sampling rate (in order to low-pass filter)</p>
</div></blockquote>
<p>fitsfile* <strong>dtcObject</strong></p>
<blockquote>
<div><p>Object which contains information of the intermediate FITS file (to be written if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-intermediate"><code class="xref std std-option docutils literal notranslate"><span class="pre">intermediate</span></code></a> = 1)</p>
</div></blockquote>
<p>gsl_vector* <strong>record</strong></p>
<blockquote>
<div><p>GSL vector with signal values of input record</p>
</div></blockquote>
<p>gsl_vector* <strong>recordWithoutConvert2R</strong></p>
<blockquote>
<div><p>GSL vector with original signal values of input record (without being converted to R space)</p>
</div></blockquote>
<p>PulsesCollection* <strong>foundPulses</strong></p>
<blockquote>
<div><p>Input/output structure where the info about found pulses is stored</p>
</div></blockquote>
<p>long <strong>num_previousDetectedPulses</strong></p>
<blockquote>
<div><p>Number of previous detected pulses (to know the index to get the proper element from <em>tstartPulse1_i</em> in case <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-tstartPulse1"><code class="xref std std-option docutils literal notranslate"><span class="pre">tstartPulse1</span></code></a> was a file name)</p>
</div></blockquote>
<p>int <strong>pixid</strong></p>
<blockquote>
<div><p>Pixel ID (from the input file) to be propagated</p>
</div></blockquote>
<p>gsl_vector* <strong>phid</strong></p>
<blockquote>
<div><p>Photon ID (from the input file) to be propagated</p>
</div></blockquote>
<p>int <strong>oscillations</strong></p>
<blockquote>
<div><p>1 (there are weird oscillations in the record) or 0 (record without weird oscillations)</p>
</div></blockquote>
<p>int <strong>nrecord</strong></p>
<blockquote>
<div><p>Current record index</p>
</div></blockquote>
<p>double <strong>tstartPrevPulse</strong></p>
<blockquote>
<div><p>tstart of the previous pulse (last pulse of the previous record) (seconds)</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412pulseGradingP21ReconstructInitSIRENAiiiPiPli">
<span id="_CPPv312pulseGradingP21ReconstructInitSIRENAiiiPiPli"></span><span id="_CPPv212pulseGradingP21ReconstructInitSIRENAiiiPiPli"></span><span id="pulseGrading__ReconstructInitSIRENAP.i.i.i.iP.lP.i"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pulseGrading</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">tstart</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">grade1</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">grade2</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulseGrade</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">OFlength</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nrecord</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412pulseGradingP21ReconstructInitSIRENAiiiPiPli" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function provides the pulse grade (Pileup=-2, Rejected=-1, HighRes=1, MidRes=2, LimRes=3, LowRes=4) and the optimal filter length by taking into account the info read from the XML file and the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFStrategy"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFStrategy</span></code></a> (<strong>FREE</strong>, <strong>BYGRADE</strong> or <strong>FIXED</strong>).</p>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>int <strong>tstart</strong></p>
<blockquote>
<div><p>Start time (samples)</p>
</div></blockquote>
<p>int <strong>grade1</strong></p>
<blockquote>
<div><p>Pulse duration (length of optimal filter applied)</p>
</div></blockquote>
<p>int <strong>grade2</strong></p>
<blockquote>
<div><p>Difference between the start time of the pulse and the start time of the previous pulse</p>
</div></blockquote>
<p>int* <strong>pulseGrade</strong></p>
<blockquote>
<div><p>Pulse grade (output)</p>
</div></blockquote>
<p>long* <strong>OFlength</strong></p>
<blockquote>
<div><p>Optimal filter length (= <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLength</span></code></a> only if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFStrategy"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFStrategy</span></code></a> = <strong>FIXED</strong> and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLength</span></code></a> &lt;= grade1) (output)</p>
</div></blockquote>
</dd></dl>

<span class="target" id="r"><span id="q"></span></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418readAddOrderParamsP21ReconstructInitSIRENAPP8fitsfiledidP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_vector">
<span id="_CPPv318readAddOrderParamsP21ReconstructInitSIRENAPP8fitsfiledidP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_vector"></span><span id="_CPPv218readAddOrderParamsP21ReconstructInitSIRENAPP8fitsfiledidP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_vector"></span><span id="readAddOrderParams__ReconstructInitSIRENAP.fitsfilePP.double.i.double.gsl_vectorP.gsl_matrixP.gsl_matrixP.gsl_vectorP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readAddOrderParams</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="n"><span class="pre">fitsfile</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">inLibObject</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samprate</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">eventcntLib</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">estenergy</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulsetemplate</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">covariance</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">weight</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulsetemplateMaxLengthFixedFilter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418readAddOrderParamsP21ReconstructInitSIRENAPP8fitsfiledidP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function reads the library data, add new data (a new row) and sort the data according to an energy-ascending order.</p>
<ul class="simple">
<li><p>Declare variables</p></li>
<li><p>Load values already in the library</p></li>
<li><p>Add new values</p></li>
<li><p>Realign</p></li>
<li><p>Add intermeadiate values</p></li>
<li><p>Recalculate intermediate values of some new pairs</p></li>
<li><p>Write values in the library</p></li>
<li><p>Free allocated GSL vectors</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>fitsfile** <strong>inLibObject</strong></p>
<blockquote>
<div><p>FITS object containing information of the library FITS file</p>
</div></blockquote>
<p>double <strong>samprate</strong></p>
<blockquote>
<div><p>Sampling rate</p>
</div></blockquote>
<p>int <strong>eventcntLib</strong></p>
<blockquote>
<div><p>Number of templates in the library</p>
</div></blockquote>
<p>double <strong>estenergy</strong></p>
<blockquote>
<div><p>Pulse height of the template whose energy is going to be added to the library</p>
</div></blockquote>
<p>gsl_vector* <strong>pulsetemplate</strong></p>
<blockquote>
<div><p>GSL vector with the pulse template whose energy is going to be added to the library</p>
</div></blockquote>
<p>gsl_matrix* <strong>covariance</strong></p>
<blockquote>
<div><p>GSL matrix with covariance matrix of the energy which is going to be added to the library</p>
</div></blockquote>
<p>gsl_matrix* <strong>weight</strong></p>
<blockquote>
<div><p>GSL matrix with weight matrix of the energy which is going to be added to the library</p>
</div></blockquote>
<p>gsl_vector* <strong>pulsetemplateMaxLengthFixedFilter</strong></p>
<blockquote>
<div><p>GSL vector with the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a>-length template whose energy is going to be added to the library</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415readFitsComplex6IODataPP10gsl_matrix">
<span id="_CPPv315readFitsComplex6IODataPP10gsl_matrix"></span><span id="_CPPv215readFitsComplex6IODataPP10gsl_matrix"></span><span id="readFitsComplex__IOData.gsl_matrixPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readFitsComplex</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">IOData</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">obj</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415readFitsComplex6IODataPP10gsl_matrix" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>inoututils.cpp</em></p>
<p>This function reads values of a complex column of a FITS file. After that, the function puts them into a GSL matrix for an easier processing.</p>
<p><strong>Members/Variables</strong></p>
<p>IOData <strong>obj</strong></p>
<blockquote>
<div><p>Input object for complex FITS column</p>
</div></blockquote>
<p>gsl_matrix** <strong>result</strong></p>
<blockquote>
<div><p>Output GSL matrix</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414readFitsSimple6IODataPP10gsl_vector">
<span id="_CPPv314readFitsSimple6IODataPP10gsl_vector"></span><span id="_CPPv214readFitsSimple6IODataPP10gsl_vector"></span><span id="readFitsSimple__IOData.gsl_vectorPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">readFitsSimple</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">IOData</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">obj</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">result</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414readFitsSimple6IODataPP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>inoututils.cpp</em></p>
<p>This function reads values of a simple column of a FITS file. After that, the function puts them into a GSL vector for an easier processing.</p>
<p><strong>Members/Variables</strong></p>
<p>IOData <strong>obj</strong></p>
<blockquote>
<div><p>Input object for simple FITS column</p>
</div></blockquote>
<p>gsl_vector** <strong>result</strong></p>
<blockquote>
<div><p>Output GSL vector</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv423reconstructRecordSIRENAP9TesRecordP12TesEventListP21ReconstructInitSIRENAiiPP16PulsesCollectionPP19OptimalFilterSIRENAPCi">
<span id="_CPPv323reconstructRecordSIRENAP9TesRecordP12TesEventListP21ReconstructInitSIRENAiiPP16PulsesCollectionPP19OptimalFilterSIRENAPCi"></span><span id="_CPPv223reconstructRecordSIRENAP9TesRecordP12TesEventListP21ReconstructInitSIRENAiiPP16PulsesCollectionPP19OptimalFilterSIRENAPCi"></span><span id="reconstructRecordSIRENA__TesRecordP.TesEventListP.ReconstructInitSIRENAP.i.i.PulsesCollectionPP.OptimalFilterSIRENAPP.iPC"></span><span class="n"><span class="pre">extern_C_void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">reconstructRecordSIRENA</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TesRecord</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">record</span></span>, <span class="n"><span class="pre">TesEventList</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">event_list</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lastRecord</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nRecord</span></span>, <span class="n"><span class="pre">PulsesCollection</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulsesAll</span></span>, <span class="n"><span class="pre">OptimalFilterSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">optimalFilter</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">status</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423reconstructRecordSIRENAP9TesRecordP12TesEventListP21ReconstructInitSIRENAiiPP16PulsesCollectionPP19OptimalFilterSIRENAPCi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>integraSIRENA.cpp</em></p>
<p>This function is the main wrapper function to detect, grade and calculate the energy of the pulses in the input records.</p>
<ul class="simple">
<li><p>Inititalize <em>PulsesCollection</em> structure</p></li>
<li><p>Check consistency of some input parameters</p></li>
<li><p>If first record, read the necessary keywords and columns from the input file in order to convert from current to quasi-resistance space</p></li>
<li><p>In case of running with threading</p></li>
<li><p>Detect pulses in input record (<a class="reference internal" href="#_CPPv49runDetectP9TesRecordiiiP16PulsesCollectionPP21ReconstructInitSIRENAPP16PulsesCollection" title="runDetect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">runDetect()</span></code></a>).</p></li>
<li><dl class="simple">
<dt>If reconstruction (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 1) and not PCA:</dt><dd><ul>
<li><p>Filter and calculate energy of pulses (<a class="reference internal" href="#_CPPv49runEnergyP9TesRecordiiiPP21ReconstructInitSIRENAPP16PulsesCollectionPP19OptimalFilterSIRENA" title="runEnergy"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">runEnergy()</span></code></a>)</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Fill in the <a class="reference internal" href="#_CPPv423reconstructRecordSIRENAP9TesRecordP12TesEventListP21ReconstructInitSIRENAiiPP16PulsesCollectionPP19OptimalFilterSIRENAPCi" title="reconstructRecordSIRENA::pulsesAll"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">pulsesAll</span></code></a> structure</p></li>
<li><p>Populate output event list with pulses energies, arrival time and grading</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>TesRecord* <strong>record</strong></p>
<blockquote>
<div><p>Instance of <em>TesRecord</em> structure that contains the input record</p>
</div></blockquote>
<p>int <strong>trig_reclength</strong></p>
<blockquote>
<div><p>Record size (just in case threading and input files with different <strong>ADC</strong> lengths but the same record size indeed)</p>
</div></blockquote>
<p>TesEventList* <strong>event_list</strong></p>
<blockquote>
<div><p>Instance of <em>TesEventList</em> structure that contains the information of the reconstructed pulses</p>
</div></blockquote>
<p>ReconstructInitSIRENA* <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values)</p>
</div></blockquote>
<p>int <strong>lastRecord</strong></p>
<blockquote>
<div><p>If record being analyzed is the last one, <a class="reference internal" href="#_CPPv423reconstructRecordSIRENAP9TesRecordP12TesEventListP21ReconstructInitSIRENAiiPP16PulsesCollectionPP19OptimalFilterSIRENAPCi" title="reconstructRecordSIRENA::lastRecord"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">lastRecord</span></code></a> = 1. Otherwise it is equal to 0</p>
</div></blockquote>
<p>int <strong>nRecord</strong></p>
<blockquote>
<div><p>Input record number</p>
</div></blockquote>
<p>PulsesCollection** <strong>pulsesAll</strong></p>
<blockquote>
<div><p>Member of <em>PulsesCollection</em> structure to successively store all the pulses used to create the library. Re-populated after each processed record.</p>
</div></blockquote>
<p>OptimalFilterSIRENA** <strong>optimalFilter</strong></p>
<blockquote>
<div><p>Optimal filters used in reconstruction</p>
</div></blockquote>
<p>int* const <strong>status</strong></p>
<blockquote>
<div><p>Input/output status</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv49RS_filterP10gsl_vectordddPd">
<span id="_CPPv39RS_filterP10gsl_vectordddPd"></span><span id="_CPPv29RS_filterP10gsl_vectordddPd"></span><span id="RS_filter__gsl_vectorP.double.double.double.doubleP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">RS_filter</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vector</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lrs</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lb</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">B</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulseheight</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49RS_filterP10gsl_vectordddPd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>pulseprocess.cpp</em></p>
<p>This function uses the running sum filter to find the pulse height. It always works in time domain.</p>
<p>A running sum filter, <em>RS</em>, is the sum of <a class="reference internal" href="#_CPPv49RS_filterP10gsl_vectordddPd" title="RS_filter::lrs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">lrs</span></code></a> digitized data samples. It is continuously updated upon the arrival of
new data point. Simultaneously a baseline filter, <a class="reference internal" href="#_CPPv49RS_filterP10gsl_vectordddPd" title="RS_filter::B"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">B</span></code></a>, is the sum of <a class="reference internal" href="#_CPPv49RS_filterP10gsl_vectordddPd" title="RS_filter::lb"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">lb</span></code></a> digitized data samples without pulses. The
algorithm looks for the time when <em>RS/lrs</em> reaches its maximum. At that time <em>RS</em> is stored, <img class="math" src="_images/math/2e3824ca6f3ce55c232644582bdfee24b86a336d.png" alt="RS_{max}"/>, and the baseline
is scaled with <a class="reference internal" href="#_CPPv49RS_filterP10gsl_vectordddPd" title="RS_filter::lrs"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">lrs</span></code></a>, <em>Bp</em> ( <img class="math" src="_images/math/48c37d93438b7eac97ebf57a3941cf3b8c20bd2f.png" alt="Bp=B \cdot lrs/lb"/>). Then, the pulse height related to the pulse pseudoenergy is given by:</p>
<div class="math">
<p><img src="_images/math/f8e14831d63a1fc7df97a3de1e302fe3fa5ca432.png" alt="Pulse height=\frac{RS_{max}-B_p}{lrs}"/></p>
</div><p><strong>Members/Variables</strong></p>
<p>gsl_vector* <strong>vector</strong></p>
<blockquote>
<div><p>Not filtered pulse (extracted from the record in <a class="reference internal" href="#_CPPv414getPulseHeightP10gsl_vectorddidddiPd" title="getPulseHeight"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">getPulseHeight()</span></code></a>)</p>
</div></blockquote>
<p>double <strong>lrs</strong></p>
<blockquote>
<div><p>Running sum length (samples)</p>
</div></blockquote>
<p>double <strong>lb</strong></p>
<blockquote>
<div><p>Baseline averaging length (samples)</p>
</div></blockquote>
<p>double <strong>B</strong></p>
<blockquote>
<div><p>In general, sum of the <a class="reference internal" href="#_CPPv49RS_filterP10gsl_vectordddPd" title="RS_filter::lb"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">lb</span></code></a> digitized data samples of a pulse-free interval immediately before the current pulse</p>
</div></blockquote>
<p>double* <strong>pulseheight</strong></p>
<blockquote>
<div><p>Pulseheight of the input pulse</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv49runDetectP9TesRecordiiiP16PulsesCollectionPP21ReconstructInitSIRENAPP16PulsesCollection">
<span id="_CPPv39runDetectP9TesRecordiiiP16PulsesCollectionPP21ReconstructInitSIRENAPP16PulsesCollection"></span><span id="_CPPv29runDetectP9TesRecordiiiP16PulsesCollectionPP21ReconstructInitSIRENAPP16PulsesCollection"></span><span id="runDetect__TesRecordP.i.i.i.PulsesCollectionP.ReconstructInitSIRENAPP.PulsesCollectionPP"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">runDetect</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TesRecord</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">record</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">trig_reclength</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lastRecord</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nrecord</span></span>, <span class="n"><span class="pre">PulsesCollection</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulsesAll</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="n"><span class="pre">PulsesCollection</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulsesInRecord</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49runDetectP9TesRecordiiiP16PulsesCollectionPP21ReconstructInitSIRENAPP16PulsesCollection" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function is responsible for the <strong>detection</strong> in SIRENA, record by record. It is used both for library creation (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0) and energy reconstruction (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 1) runnings.</p>
<p>Conditions:</p>
<blockquote>
<div><ul class="simple">
<li><p>If first record and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 1  <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/>  Run <a class="reference internal" href="#_CPPv413filderLibraryPP21ReconstructInitSIRENAd" title="filderLibrary"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">filderLibrary()</span></code></a></p></li>
<li><p>If last record and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Run <a class="reference internal" href="#_CPPv417calculateTemplateP21ReconstructInitSIRENAP16PulsesCollectionP16PulsesCollectiondPP10gsl_vectorPdPP10gsl_matrixPP10gsl_matrixPP10gsl_vector" title="calculateTemplate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">calculateTemplate()</span></code></a> and <a class="reference internal" href="#_CPPv412writeLibraryP21ReconstructInitSIRENAddP10gsl_vectorP10gsl_matrixP10gsl_matrixbPP8fitsfileP10gsl_vector" title="writeLibrary"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">writeLibrary()</span></code></a></p></li>
<li><p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-intermediate"><code class="xref std std-option docutils literal notranslate"><span class="pre">intermediate</span></code></a> = 1 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> <a class="reference internal" href="#_CPPv413writeTestInfoP21ReconstructInitSIRENAP10gsl_vectordP8fitsfile" title="writeTestInfo"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">writeTestInfo()</span></code></a> and <a class="reference internal" href="#_CPPv411writePulsesPP21ReconstructInitSIRENAddP10gsl_vectoriP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectorP8fitsfile" title="writePulses"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">writePulses()</span></code></a></p></li>
<li><p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Find pulses by using <a class="reference internal" href="#_CPPv413findPulsesCALP10gsl_vectorP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPiPdddidddP21ReconstructInitSIRENAdd" title="findPulsesCAL"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">findPulsesCAL()</span></code></a></p></li>
<li><p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 1 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Find pulses by <a class="reference internal" href="#_CPPv417InitialTriggeringP10gsl_vectordddddPbPiPiPdi" title="InitialTriggering"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">InitialTriggering()</span></code></a> and <a class="reference internal" href="#_CPPv415FindSecondariesiP10gsl_vectordP21ReconstructInitSIRENAiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="FindSecondaries"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">FindSecondaries()</span></code></a> or <a class="reference internal" href="#_CPPv418FindSecondariesSTCiP10gsl_vectordP21ReconstructInitSIRENAiPiPP10gsl_vectorPP10gsl_vectorPP10gsl_vectorPP10gsl_vector" title="FindSecondariesSTC"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">FindSecondariesSTC()</span></code></a></p></li>
</ul>
</div></blockquote>
<p>Steps:</p>
<blockquote>
<div><ol class="arabic">
<li><p>Create library file if it is necessary: calibration (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0) and last record (run <a class="reference internal" href="#_CPPv413createLibraryP21ReconstructInitSIRENAPbPP8fitsfile" title="createLibrary"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">createLibrary()</span></code></a>)</p></li>
<li><p>Create intermediate output FITS file if required (<a class="reference internal" href="#_CPPv416createDetectFileP21ReconstructInitSIRENAdPP8fitsfilei" title="createDetectFile"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">createDetectFile()</span></code></a>)</p></li>
<li><p>(Filter and) differentiate the <em>models</em> of the library (only for the first record in <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 1). Run  (<a class="reference internal" href="#_CPPv413filderLibraryPP21ReconstructInitSIRENAd" title="filderLibrary"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">filderLibrary()</span></code></a>)</p></li>
<li><p>Store the input record in <em>invector</em> (<a class="reference internal" href="#_CPPv410loadRecordP9TesRecordPdPP10gsl_vector" title="loadRecord"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">loadRecord()</span></code></a>)</p></li>
<li><p>Detect weird oscillations in some GSFC records providing a warning (no pulses detected in that record)</p></li>
<li><p>Convert <em>I</em> into <em>R</em> if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>I2R</strong> or <strong>I2RFITTED</strong> (<a class="reference internal" href="#_CPPv410convertI2RPcddddddddPP10gsl_vector" title="convertI2R"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">convertI2R()</span></code></a>)</p></li>
<li><p>Process each record (<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">proceRecord()</span></code>):</p>
<blockquote>
<div><ul class="simple">
<li><p>(Low-pass filter and) differentiate</p></li>
<li><p>Find pulses</p></li>
<li><p>Load the found pulses data in the input/output <em>foundPulses</em> structure</p></li>
<li><p>Write test info in intermediate output FITS file if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-intermediate"><code class="xref std std-option docutils literal notranslate"><span class="pre">intermediate</span></code></a> = 1 (<a class="reference internal" href="#_CPPv413writeTestInfoP21ReconstructInitSIRENAP10gsl_vectordP8fitsfile" title="writeTestInfo"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">writeTestInfo()</span></code></a>)</p></li>
<li><p>Write pulses info in intermediate output FITS file if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-intermediate"><code class="xref std std-option docutils literal notranslate"><span class="pre">intermediate</span></code></a> = 1 (<a class="reference internal" href="#_CPPv411writePulsesPP21ReconstructInitSIRENAddP10gsl_vectoriP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectorP8fitsfile" title="writePulses"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">writePulses()</span></code></a>)</p></li>
</ul>
</div></blockquote>
</li>
</ol>
<p><strong>From this point forward, I2R and I2RFITTED are completely equivalent to OPTFILT</strong></p>
<ol class="arabic" start="8">
<li><p>If last record in <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0 run:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#_CPPv417calculateTemplateP21ReconstructInitSIRENAP16PulsesCollectionP16PulsesCollectiondPP10gsl_vectorPdPP10gsl_matrixPP10gsl_matrixPP10gsl_vector" title="calculateTemplate"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">calculateTemplate()</span></code></a> (and <a class="reference internal" href="#_CPPv412weightMatrixP21ReconstructInitSIRENAbP16PulsesCollectionP16PulsesCollectionlP10gsl_vectorP10gsl_vectorPP10gsl_matrixPP10gsl_matrix" title="weightMatrix"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">weightMatrix()</span></code></a>)</p></li>
<li><p><a class="reference internal" href="#_CPPv412writeLibraryP21ReconstructInitSIRENAddP10gsl_vectorP10gsl_matrixP10gsl_matrixbPP8fitsfileP10gsl_vector" title="writeLibrary"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">writeLibrary()</span></code></a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>If last record and PCA:</p>
<blockquote>
<div><ul class="simple">
<li><p>In order to not have restrictions when providing (*reconstruct_init)-&gt;energyPCAx</p></li>
<li><p>Covariance data</p></li>
<li><p>Eigenvalues and eigenvectors</p></li>
<li><p>RSxN (S=2)</p></li>
<li><p>AE straight line: Pto0(x,y) and Pto10(x,y)</p></li>
<li><p>Calculus of the rotation angle</p></li>
<li><p>Rotation</p></li>
<li><p>Histograms of the two clusters (two energies)</p></li>
<li><p>Conversion factor from arbitrary unit to eV</p></li>
<li><p>Energy calculation</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Close intermediate output FITS file if it is necessary</p></li>
</ol>
</div></blockquote>
<p><strong>Members/Variables</strong></p>
<p>TesRecord* <strong>record</strong></p>
<blockquote>
<div><p>Member of <em>TesRecord</em> structure that contains the input record</p>
</div></blockquote>
<p>int <strong>trig_reclength</strong></p>
<blockquote>
<div><p>Record size (just in case threading and input files with different <strong>ADC</strong> lengths but the same record size indeed)</p>
</div></blockquote>
<p>int <strong>lastRecord</strong></p>
<blockquote>
<div><p>Integer to verify whether <em>record</em> is the last one (=1) to be read (and thus if library file will be created)</p>
</div></blockquote>
<p>PulsesCollection* <strong>pulsesAll</strong></p>
<blockquote>
<div><p>Member of <em>PulsesCollection</em> structure to successively store all the pulses used to create the library. Re-populated after each processed record</p>
</div></blockquote>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values)</p>
</div></blockquote>
<p>PulsesCollection** <strong>pulsesInRecord</strong></p>
<blockquote>
<div><p>Member of <em>PulsesCollection</em> structure to store all the pulses found in the input record</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv49runEnergyP9TesRecordiiiPP21ReconstructInitSIRENAPP16PulsesCollectionPP19OptimalFilterSIRENA">
<span id="_CPPv39runEnergyP9TesRecordiiiPP21ReconstructInitSIRENAPP16PulsesCollectionPP19OptimalFilterSIRENA"></span><span id="_CPPv29runEnergyP9TesRecordiiiPP21ReconstructInitSIRENAPP16PulsesCollectionPP19OptimalFilterSIRENA"></span><span id="runEnergy__TesRecordP.i.i.i.ReconstructInitSIRENAPP.PulsesCollectionPP.OptimalFilterSIRENAPP"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">runEnergy</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TesRecord</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">record</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lastRecord</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nrecord</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">trig_reclength</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="n"><span class="pre">PulsesCollection</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulsesInRecord</span></span>, <span class="n"><span class="pre">OptimalFilterSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">optimalFilter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49runEnergyP9TesRecordiiiPP21ReconstructInitSIRENAPP16PulsesCollectionPP19OptimalFilterSIRENA" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function calculates the pulse energy applying different methods (from <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFNoise"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFNoise</span></code></a>).
It only runs in RECONSTRUCTION mode (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = <em>1</em>) (except to <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>PCA</strong>).</p>
<ul>
<li><p>Declare variables</p></li>
<li><p>Store the <a class="reference internal" href="#_CPPv49runEnergyP9TesRecordiiiPP21ReconstructInitSIRENAPP16PulsesCollectionPP19OptimalFilterSIRENA" title="runEnergy::record"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">record</span></code></a> in <em>invector</em> (<a class="reference internal" href="#_CPPv410loadRecordP9TesRecordPdPP10gsl_vector" title="loadRecord"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">loadRecord()</span></code></a>)</p></li>
<li><p>Subtract the baseline if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>OPTFILT</strong> and <em>runF0orB0val</em> = 1 (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterMethod"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterMethod</span></code></a> = <strong>B0</strong>)</p></li>
<li><p>Subtract the baseline if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>WEIGHT</strong></p></li>
<li><p>Check Quality</p></li>
<li><p>For each pulse:</p>
<blockquote>
<div><ul>
<li><p>Establish the pulse grade (for example VeryHighRes=1, HighRes=2, IntRes=3, MedRes=4, LimRes=5, LowRes=6, Rejected=-1, Pileup=-2) and the optimal filter length</p></li>
<li><p>Pulse: Load the proper piece of the record in <em>pulse</em></p></li>
<li><dl class="simple">
<dt>Get the low resolution energy estimator by filtering with a 8-samples-length (with lags) filter:</dt><dd><ul class="simple">
<li><p>Load the low resolution pulse in <em>pulse_lowres</em></p></li>
<li><p>Get the filter</p></li>
<li><p>Calculate the low resolution estimator</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFIter"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFIter</span></code></a> = 1, in the first iteration ( <em>numiteration</em> = 0) the values of <em>maxDER</em> and <em>maxDERs</em> are used in
<a class="reference internal" href="#_CPPv421find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_matchedfilterDAB"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">find_matchedfilterDAB()</span></code></a>, <a class="reference internal" href="#_CPPv421find_optimalfilterDABdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_optimalfilterDAB"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">find_optimalfilterDAB()</span></code></a> or <a class="reference internal" href="#_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd" title="find_Esboundary"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">find_Esboundary()</span></code></a> getting the values of the <em>energies</em> which straddle the <em>maxDER</em> (<em>Ealpha</em> and <em>Ebeta</em>). It will have more iterations if the calculated <em>energy</em> is out of <em>[Ealpha, Ebeta]</em>. If <em>energy</em> is in <em>[Ealpha, Ebeta]</em> the iterative process stops.</p>
<blockquote>
<div><ul>
<li><p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>OPTFILT</strong> (or <strong>I2R</strong>, <strong>I2RFITTED</strong>) and <em>reconstruct_init-&gt;OFLib</em> = 0 and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFNoise"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFNoise</span></code></a> = <strong>NSD</strong>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Find the matched filter and load it in <em>filter</em> (<a class="reference internal" href="#_CPPv421find_matchedfilterDABidP10gsl_vectoriP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_matchedfilterDAB"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">find_matchedfilterDAB()</span></code></a>)</p></li>
<li><p>Calculate the optimal filter</p></li>
</ul>
</div></blockquote>
</li>
<li><p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>OPTFILT</strong> (or <strong>I2R</strong>, <strong>I2RFITTED</strong>) and <em>reconstruct_init-&gt;OFLib</em> = 1 and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFNoise"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFNoise</span></code></a> = <strong>NSD</strong>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If it is necessary, choose the base-2 system value closest (lower than or equal) to the pulse length</p></li>
<li><p>Find the optimal filter and load it in <em>filter</em> (<a class="reference internal" href="#_CPPv421find_optimalfilterDABdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_optimalfilterDAB"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">find_optimalfilterDAB()</span></code></a>)</p></li>
</ul>
</div></blockquote>
</li>
<li><p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>WEIGHT</strong> or <strong>WEIGHTN</strong>:</p>
<blockquote>
<div><ul>
<li><p>Get the indexes of the two energies which straddle the pulse (<a class="reference internal" href="#_CPPv415find_EsboundarydP10gsl_vectorP21ReconstructInitSIRENAPiPiPdPdd" title="find_Esboundary"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">find_Esboundary()</span></code></a>)</p></li>
<li><p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>WEIGHTN</strong> and <em>reconstruct_init-&gt;OFLib</em> = 1:</p>
<blockquote>
<div><ul class="simple">
<li><p>Choose the base-2 system value closest (lower than or equal) to the pulse length</p></li>
<li><p><a class="reference internal" href="#_CPPv411find_prclwndP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPP10gsl_vectorPdPdd" title="find_prclwn"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">find_prclwn()</span></code></a> to find the appropriate values of the <em>PRECALWN</em> HDU (<strong>PCLx</strong> columns)</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>OPTFILT</strong> (or <strong>I2R</strong>, <strong>I2RFITTED</strong>) and <em>reconstruct_init-&gt;OFLib</em> = 1 and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFNoise"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFNoise</span></code></a> = <strong>WEIGHTM</strong>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Choose the base-2 system value closest (lower than or equal) to the pulse length</p></li>
<li><p><a class="reference internal" href="#_CPPv413find_prclofwmdP10gsl_vectorP21ReconstructInitSIRENAPP10gsl_vectorPdPdd" title="find_prclofwm"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">find_prclofwm()</span></code></a> to find the appropriate values of the <em>PRCLOFWM</em> HDU (<strong>OFWx</strong> columns)</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Subtract the sum of the filter if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>OPTFILT</strong>, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFNoise"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFNoise</span></code></a> = <strong>NSD</strong>, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterDomain"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterDomain</span></code></a> = <strong>T</strong>, 0-padding and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-Sum0Filt"><code class="xref std std-option docutils literal notranslate"><span class="pre">Sum0Filt</span></code></a> =1</p></li>
<li><p>Calculate the energy of each pulse</p></li>
<li><p>If using lags, it is necessary to modify the tstart of the pulse</p></li>
</ul>
</div></blockquote>
</li>
<li><p>In order to subtract the pulse model, it has to be located in the tstart with jitter and know its values in the digitized samples</p></li>
<li><p>Subtract the pulse model from the record</p></li>
<li><p>Write info of the pulse in the output intemediate file if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-intermediate"><code class="xref std std-option docutils literal notranslate"><span class="pre">intermediate</span></code></a> = 1</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Free allocated GSL vectors</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>TesRecord** <strong>record</strong></p>
<blockquote>
<div><p>Structure that contains the input ADC record</p>
</div></blockquote>
<p>int <strong>lastRecord</strong></p>
<blockquote>
<div><p>If record being analyzed is the last one, <a class="reference internal" href="#_CPPv49runEnergyP9TesRecordiiiPP21ReconstructInitSIRENAPP16PulsesCollectionPP19OptimalFilterSIRENA" title="runEnergy::lastRecord"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">lastRecord</span></code></a> = 1. Otherwise it is equal to 0</p>
</div></blockquote>
<p>int <strong>nRecord</strong></p>
<blockquote>
<div><p>Input record number</p>
</div></blockquote>
<p>int <strong>trig_reclength</strong></p>
<blockquote>
<div><p>Record size (just in case threading and input files with different <strong>ADC</strong> lengths but the same record size indeed)</p>
</div></blockquote>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values)</p>
</div></blockquote>
<p>PulsesCollection* <strong>pulsesInRecord</strong></p>
<blockquote>
<div><p>Collection of pulses found in the current record</p>
</div></blockquote>
<p>OptimalFilterSIRENA** <strong>optimalFilter</strong></p>
<blockquote>
<div><blockquote>
<div><p>Optimal filters used in reconstruction</p>
</div></blockquote>
<p>PulsesCollection* <strong>pulsesAll</strong></p>
<blockquote>
<div><p>Member of <em>PulsesCollection</em> structure to store all the pulses found in the input FITS file. To know the index to get the proper element from <em>tstartPulse1_i</em> in case <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-tstartPulse1"><code class="xref std std-option docutils literal notranslate"><span class="pre">tstartPulse1</span></code></a> was a file name</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412th_runEnergyP9TesRecordiiiPP21ReconstructInitSIRENAPP16PulsesCollectionPP19OptimalFilterSIRENA">
<span id="_CPPv312th_runEnergyP9TesRecordiiiPP21ReconstructInitSIRENAPP16PulsesCollectionPP19OptimalFilterSIRENA"></span><span id="_CPPv212th_runEnergyP9TesRecordiiiPP21ReconstructInitSIRENAPP16PulsesCollectionPP19OptimalFilterSIRENA"></span><span id="th_runEnergy__TesRecordP.i.i.i.ReconstructInitSIRENAPP.PulsesCollectionPP.OptimalFilterSIRENAPP"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">th_runEnergy</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TesRecord</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">record</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lastRecord</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nrecord</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">trig_reclength</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="n"><span class="pre">PulsesCollection</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulsesInRecord</span></span>, <span class="n"><span class="pre">OptimalFilterSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">optimalFilter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412th_runEnergyP9TesRecordiiiPP21ReconstructInitSIRENAPP16PulsesCollectionPP19OptimalFilterSIRENA" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function is responsible for the <strong>reconstruction</strong> in SIRENA (instead of <a class="reference internal" href="#_CPPv49runEnergyP9TesRecordiiiPP21ReconstructInitSIRENAPP16PulsesCollectionPP19OptimalFilterSIRENA" title="runEnergy"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">runEnergy()</span></code></a>) when the <strong>THREADING</strong> running option has been chosen (hardcoded at this moment).</p>
</dd></dl>

<span class="target" id="s"></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv46shiftmP10gsl_vectorP10gsl_vectori">
<span id="_CPPv36shiftmP10gsl_vectorP10gsl_vectori"></span><span id="_CPPv26shiftmP10gsl_vectorP10gsl_vectori"></span><span id="shiftm__gsl_vectorP.gsl_vectorP.i"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">shiftm</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vectorin</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vectorout</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv46shiftmP10gsl_vectorP10gsl_vectori" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function returns as <a class="reference internal" href="#_CPPv46shiftmP10gsl_vectorP10gsl_vectori" title="shiftm::vectorout"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vectorout</span></code></a> the <a class="reference internal" href="#_CPPv46shiftmP10gsl_vectorP10gsl_vectori" title="shiftm::vectorin"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vectorin</span></code></a> delayed <a class="reference internal" href="#_CPPv46shiftmP10gsl_vectorP10gsl_vectori" title="shiftm::m"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">m</span></code></a> samples.</p>
<p><strong>Members/Variables</strong></p>
<p>int <strong>m</strong></p>
<blockquote>
<div><p>Delay in samples</p>
</div></blockquote>
<p>gsl_vector* <strong>vectorin</strong></p>
<blockquote>
<div><p>GSL vector with input vector</p>
</div></blockquote>
<p>gsl_vector* <strong>vectorout</strong></p>
<blockquote>
<div><p>GSL with input vector (<a class="reference internal" href="#_CPPv46shiftmP10gsl_vectorP10gsl_vectori" title="shiftm::vectorin"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vectorin</span></code></a>) delayed <a class="reference internal" href="#_CPPv46shiftmP10gsl_vectorP10gsl_vectori" title="shiftm::m"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">m</span></code></a> samples</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv47shift_mP10gsl_vectorP10gsl_vectori">
<span id="_CPPv37shift_mP10gsl_vectorP10gsl_vectori"></span><span id="_CPPv27shift_mP10gsl_vectorP10gsl_vectori"></span><span id="shift_m__gsl_vectorP.gsl_vectorP.i"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">shift_m</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vectorin</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vectorout</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv47shift_mP10gsl_vectorP10gsl_vectori" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function returns as <a class="reference internal" href="#_CPPv47shift_mP10gsl_vectorP10gsl_vectori" title="shift_m::vectorout"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vectorout</span></code></a> the <a class="reference internal" href="#_CPPv47shift_mP10gsl_vectorP10gsl_vectori" title="shift_m::vectorin"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vectorin</span></code></a> moved forward by <a class="reference internal" href="#_CPPv47shift_mP10gsl_vectorP10gsl_vectori" title="shift_m::m"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">m</span></code></a> samples.</p>
<p><strong>Members/Variables</strong></p>
<p>int <strong>m</strong></p>
<blockquote>
<div><p>Advance in samples</p>
</div></blockquote>
<p>gsl_vector* <strong>vectorin</strong></p>
<blockquote>
<div><p>GSL vector with input vector</p>
</div></blockquote>
<p>gsl_vector* <strong>vectorout</strong></p>
<blockquote>
<div><p>GSL with input vector (<a class="reference internal" href="#_CPPv47shift_mP10gsl_vectorP10gsl_vectori" title="shift_m::vectorin"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">vectorin</span></code></a>) moved forward <a class="reference internal" href="#_CPPv47shift_mP10gsl_vectorP10gsl_vectori" title="shift_m::m"><code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">m</span></code></a> samples</p>
</div></blockquote>
</dd></dl>

<span class="target" id="t"></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv422tesreconstruction_mainv">
<span id="_CPPv322tesreconstruction_mainv"></span><span id="_CPPv222tesreconstruction_mainv"></span><span id="tesreconstruction_main"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">tesreconstruction_main</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422tesreconstruction_mainv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tesreconstruction.c</em></p>
<p>This function is mainly a wrapper to pass a data file to the SIRENA tasks in order to reconstruct the energy of the incoming X-ray photons after their detection.</p>
<p>It can run the SIRENA tasks or the Philippe Peille’s tasks depending on the ‘Rcmethod’ selected.</p>
<p>Steps:</p>
<ul class="simple">
<li><p>Register HEATOOL</p></li>
<li><p>Reading all programm parameters by using PIL</p></li>
<li><p>Read XML info</p></li>
<li><p>Sixt standard keywords structure</p></li>
<li><p>Open output FITS file</p></li>
<li><p>Initialize PP data structures needed for pulse filtering</p></li>
<li><p>Initialize SIRENA data structures needed for pulse filtering</p></li>
<li><p>Read the grading data from the XML file and store it in ‘reconstruct_init_sirena-&gt;grading’</p></li>
<li><dl class="simple">
<dt>Obtain the samplig rate and the ‘trig_reclength’:</dt><dd><ul>
<li><dl class="simple">
<dt>If Rcmethod starts with ‘&#64;’ <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> List of record input FITS files. For every FITS file:</dt><dd><ul>
<li><p>Open FITS file</p></li>
<li><p>Check if input FITS file have been simulated with TESSIM or XIFUSIM</p></li>
<li><dl class="simple">
<dt>If it is a xifusim simulated file</dt><dd><ul>
<li><p>Obtain ‘trig_reclength’ from the <code class="docutils literal notranslate"><span class="pre">HISTORY</span></code> block</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>If Rcemethod doesn’t start with ‘&#64;’ <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Single record input FITS file</dt><dd><ul>
<li><p>Open FITS file</p></li>
<li><p>Check if input FITS file have been simulated with TESSIM or XIFUSIM</p></li>
<li><dl class="simple">
<dt>If it is a xifusim simulated file</dt><dd><ul>
<li><p>Obtain ‘trig_reclength’ from the <code class="docutils literal notranslate"><span class="pre">HISTORY</span></code> block</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p>Build up TesEventList to recover the results of the reconstruction</p></li>
<li><dl class="simple">
<dt>Reconstruct the input record FITS file:</dt><dd><ul>
<li><dl class="simple">
<dt>If Rcmethod starts with ‘&#64;’ <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> List of record input FITS files. For every FITS file:</dt><dd><ul>
<li><p>Open record file</p></li>
<li><p>Initialize: initializeReconstruction or initializeReconstructionSIRENA</p></li>
<li><p>Build up TesRecord to read the file</p></li>
<li><dl class="simple">
<dt>Iterate of records and do the reconstruction</dt><dd><ul>
<li><p>Reconstruct: reconstructRecord or reconstructRecordSIRENA</p></li>
<li><p>Save events to the event_list</p></li>
<li><p>Copy trigger keywords to event file</p></li>
<li><p>Close file</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>If Rcemethod doesn’t start with ‘&#64;’ <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Single record input FITS file</dt><dd><ul>
<li><p>Open record file</p></li>
<li><p>Initialize: initializeReconstruction or initializeReconstructionSIRENA</p></li>
<li><p>Build up TesRecord to read the file</p></li>
<li><dl class="simple">
<dt>Iterate of records and do the reconstruction</dt><dd><ul>
<li><p>Reconstruct: reconstructRecord or reconstructRecordSIRENA</p></li>
<li><p>Save events to the event_list</p></li>
<li><p>Copy trigger keywords to event file</p></li>
<li><p>Close file</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p>Save GTI extension to event file</p></li>
<li><p>Free memory</p></li>
</ul>
<p>The user must supply the following input parameters (<em>tesreconstruction.par</em> file).</p>
<p>Common parameters:</p>
<p>char <strong>Rcmethod</strong></p>
<blockquote>
<div><p>Reconstruction method (<strong>PP</strong> or <strong>SIRENA</strong>). If SIRENA <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> If Rcmethod starts with ‘&#64;’ it provides a file text containing several record input FITS files</p>
</div></blockquote>
<p>char <strong>RecordFile</strong></p>
<blockquote>
<div><p>Record FITS file</p>
</div></blockquote>
<p>char <strong>TesEventFile</strong></p>
<blockquote>
<div><p>Output event list file</p>
</div></blockquote>
<p>int <strong>OFLengthNotPadded</strong></p>
<blockquote>
<div><p>Filter length not padded with 0s (only necessary when reconstructing with 0-padding)</p>
</div></blockquote>
<p>int <strong>EventListSize</strong></p>
<blockquote>
<div><p>Default size of the event list</p>
</div></blockquote>
<p>char <strong>clobber</strong></p>
<blockquote>
<div><p>Overwrite or not output files if exist (yes/no)</p>
</div></blockquote>
<p>char <strong>history</strong></p>
<blockquote>
<div><p>Write program parameters into output file</p>
</div></blockquote>
<p>PP parameters:</p>
<p>double <strong>SaturationValue</strong></p>
<blockquote>
<div><p>Saturation level of the ADC curves</p>
</div></blockquote>
<p>char <strong>OptimalFilterFile</strong></p>
<blockquote>
<div><p>Optimal filters file</p>
</div></blockquote>
<p>char <strong>PulseTemplateFile</strong></p>
<blockquote>
<div><p>Pulse template file</p>
</div></blockquote>
<p>double <strong>Threshold</strong></p>
<blockquote>
<div><p>Threshold level</p>
</div></blockquote>
<p>double <strong>Calfac</strong></p>
<blockquote>
<div><p>Calibration factor (should be read from the xml file)</p>
</div></blockquote>
<p>int <strong>NormalExclusion</strong></p>
<blockquote>
<div><p>Minimal distance before using OFs after a misreconstruction</p>
</div></blockquote>
<p>int <strong>DerivateExclusion</strong></p>
<blockquote>
<div><p>Minimal distance before reconstructing any event after a misreconstruction</p>
</div></blockquote>
<p>SIRENA parameters:</p>
<p>char <strong>LibraryFile</strong></p>
<blockquote>
<div><p>File with calibration library</p>
</div></blockquote>
<p>double <strong>scaleFactor</strong></p>
<blockquote>
<div><p>Detection scale factor for initial filtering</p>
</div></blockquote>
<p>int <strong>samplesUp</strong></p>
<blockquote>
<div><p>Number of consecutive samples up for threshold trespassing (only used in calibration run, and in production run with <strong>STC</strong> detection mode)</p>
</div></blockquote>
<p>int <strong>samplesDown</strong></p>
<blockquote>
<div><p>Number of consecutive samples below the threshold to look for other pulse (only used in production run with <strong>STC</strong> detection mode)</p>
</div></blockquote>
<p>double <strong>nSgms</strong></p>
<blockquote>
<div><p>Number of quiescent-signal standard deviations to establish the threshold through the kappa-clipping algorithm</p>
</div></blockquote>
<p>int <strong>detectSP</strong></p>
<blockquote>
<div><p>Detect secondary pulses (1) or not (0)</p>
</div></blockquote>
<p>double <strong>LrsT</strong></p>
<blockquote>
<div><p>Running sum length for the RS raw energy estimation (seconds) (only for library creation)</p>
</div></blockquote>
<p>double <strong>LbT</strong></p>
<blockquote>
<div><p>Baseline averaging length (seconds)</p>
</div></blockquote>
<p>double <strong>monoenergy</strong></p>
<blockquote>
<div><p>Monochromatic energy of the pulses in the input FITS file in eV (only for library creation)</p>
</div></blockquote>
<p>char <strong>hduPRECALWN</strong></p>
<blockquote>
<div><p>Add or not the PRECALWN HDU in the library file (yes/no) (only for library creation)</p>
</div></blockquote>
<p>char <strong>hduPRCLOFWM</strong></p>
<blockquote>
<div><p>Add or not the PRCLOFWM HDU in the library file (yes/no) (only for library creation)</p>
</div></blockquote>
<p>int <strong>largeFilter</strong></p>
<blockquote>
<div><p>Length of the longest fixed filter (only for library creation)</p>
</div></blockquote>
<p>int <strong>opmode</strong></p>
<blockquote>
<div><p>Calibration run (0) or energy reconstruction run (1)</p>
</div></blockquote>
<p>char <strong>detectionMode</strong></p>
<blockquote>
<div><p>Adjusted Derivative (<strong>AD</strong>) or Single Threshold Crossing (<strong>STC</strong>)</p>
</div></blockquote>
<p>char <strong>NoiseFile</strong></p>
<blockquote>
<div><p>Noise FITS file with noise spectrum</p>
</div></blockquote>
<p>char <strong>FilterDomain</strong></p>
<blockquote>
<div><p>Filtering Domain: Time (<strong>T</strong>) or Frequency (<strong>F</strong>)</p>
</div></blockquote>
<p>char <strong>FilterMethod</strong></p>
<blockquote>
<div><p>Filtering Method: <strong>F0</strong> (deleting the zero frequency bin) or <strong>B0</strong> (deleting the baseline)</p>
</div></blockquote>
<p>char <strong>EnergyMethod</strong></p>
<blockquote>
<div><p>Energy calculation Method: <strong>OPTFILT</strong>, <strong>WEIGHT</strong>, <strong>WEIGHTN</strong>, <strong>I2R</strong>, <strong>I2RFITTED</strong> or <strong>PCA</strong></p>
</div></blockquote>
<p>double <strong>filtEeV</strong></p>
<blockquote>
<div><p>Energy of the filters of the library to be used to calculate energy (only for <strong>OPTFILT</strong>, <strong>I2R</strong> and <strong>I2RFITTED</strong>)</p>
</div></blockquote>
<p>double <strong>Ifit</strong></p>
<blockquote>
<div><p>Constant to apply the I2RFITTED conversion</p>
</div></blockquote>
<p>char <strong>OFNoise</strong></p>
<blockquote>
<div><p>Noise to use with Optimal Filtering: <strong>NSD</strong> or <strong>WEIGHTM</strong></p>
</div></blockquote>
<p>int <strong>LagsOrNot</strong></p>
<blockquote>
<div><p>Lags or no lags (1/0)</p>
</div></blockquote>
<p>int <strong>nLags</strong></p>
<blockquote>
<div><p>Number of lags (positive odd number)</p>
</div></blockquote>
<p>int <strong>Fitting35</strong></p>
<blockquote>
<div><p>Number of lags to analytically calculate a parabola (3) or to fit a parabola (5)</p>
</div></blockquote>
<p>int <strong>OFIter</strong></p>
<blockquote>
<div><p>Iterate or not iterate (1/0)</p>
</div></blockquote>
<p>int <strong>OFLib</strong></p>
<blockquote>
<div><p>Work or not with a library with optimal filters (yes/no)</p>
</div></blockquote>
<p>char <strong>OFStrategy</strong></p>
<blockquote>
<div><p>Optimal Filter length Strategy: <strong>FREE</strong>, <strong>BYGRADE</strong> or <strong>FIXED</strong></p>
</div></blockquote>
<p>int <strong>OFLength</strong></p>
<blockquote>
<div><p>Optimal Filter length (taken into account if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFStrategy"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFStrategy</span></code></a> = <strong>FIXED</strong>)</p>
</div></blockquote>
<p>char <strong>preBuffer</strong></p>
<blockquote>
<div><p>Some samples added or not before the starting time of a pulse (number of added samples read from the xml file)</p>
</div></blockquote>
<p>int <strong>intermediate</strong></p>
<blockquote>
<div><p>Write or not intermediate files (1/0)</p>
</div></blockquote>
<p>char <strong>detectFile</strong></p>
<blockquote>
<div><p>Intermediate detections file (if intermediate*=1)</p>
</div></blockquote>
<p>int <strong>errorT</strong></p>
<blockquote>
<div><p>Additional error (in samples) added to the detected time (Logically, it changes the reconstructed energies )</p>
</div></blockquote>
<p>int <strong>Sum0Filt</strong></p>
<blockquote>
<div><p>0-padding: Subtract the sum of the filter (1) or not (0)</p>
</div></blockquote>
<p>char <strong>tstartPulse1</strong></p>
<blockquote>
<div><p>Integer number: Sample where the first pulse starts or nameFile: File where the tstart (seconds) of every pulse is</p>
</div></blockquote>
<p>int <strong>tstartPulse2</strong></p>
<blockquote>
<div><p>Tstart (samples) of the second pulse</p>
</div></blockquote>
<p>int <strong>tstartPulse3</strong></p>
<blockquote>
<div><p>Tstart (samples) of the third pulse (if 0 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> PAIRS, if not 0 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> TRIOS)</p>
</div></blockquote>
<p>double <strong>energyPCA1</strong></p>
<blockquote>
<div><p>First energy (only for PCA)</p>
</div></blockquote>
<p>double <strong>energyPCA2</strong></p>
<blockquote>
<div><p>Second energy (only for PCA)</p>
</div></blockquote>
<p>char <strong>XMLFile</strong></p>
<blockquote>
<div><p>XML input FITS file with instrument definition</p>
</div></blockquote>
<p>PP parameters:</p>
<p>SIRENA parameters:</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412th_runDetectP9TesRecordiiiP16PulsesCollectionPP21ReconstructInitSIRENAPP16PulsesCollection">
<span id="_CPPv312th_runDetectP9TesRecordiiiP16PulsesCollectionPP21ReconstructInitSIRENAPP16PulsesCollection"></span><span id="_CPPv212th_runDetectP9TesRecordiiiP16PulsesCollectionPP21ReconstructInitSIRENAPP16PulsesCollection"></span><span id="th_runDetect__TesRecordP.i.i.i.PulsesCollectionP.ReconstructInitSIRENAPP.PulsesCollectionPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">th_runDetect</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TesRecord</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">record</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">trig_reclength</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">lastRecord</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nrecord</span></span>, <span class="n"><span class="pre">PulsesCollection</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulsesAll</span></span>, <span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="n"><span class="pre">PulsesCollection</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulsesInRecord</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412th_runDetectP9TesRecordiiiP16PulsesCollectionPP21ReconstructInitSIRENAPP16PulsesCollection" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function is responsible for the <strong>detection</strong> in SIRENA (instead of <a class="reference internal" href="#_CPPv49runDetectP9TesRecordiiiP16PulsesCollectionPP21ReconstructInitSIRENAPP16PulsesCollection" title="runDetect"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">runDetect()</span></code></a>) when the <strong>THREADING</strong> running option has been chosen (hardcoded at this moment). It is used both for library creation (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0) and energy reconstruction (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 1) runnings.</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411toGslMatrixPPvPP10gsl_matrixliii">
<span id="_CPPv311toGslMatrixPPvPP10gsl_matrixliii"></span><span id="_CPPv211toGslMatrixPPvPP10gsl_matrixliii"></span><span id="toGslMatrix__voidPP.gsl_matrixPP.l.i.i.i"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toGslMatrix</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">buffer</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">matrix</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">numCol</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">numRow</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">type</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">eventini</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411toGslMatrixPPvPP10gsl_matrixliii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>inoututils.cpp</em></p>
<p>The function puts the values of the input buffer into an output GSL matrix. Columns and rows are input parameters.</p>
<p><strong>Members/Variables</strong></p>
<p>void** <strong>buffer</strong></p>
<blockquote>
<div><p>Input buffer with data</p>
</div></blockquote>
<p>gsl_matrix** <strong>matrix</strong></p>
<blockquote>
<div><p>Output GSL matrix</p>
</div></blockquote>
<p>long <strong>numCol</strong></p>
<blockquote>
<div><p>Number of columns</p>
</div></blockquote>
<p>int <strong>numRow</strong></p>
<blockquote>
<div><p>Number of rows</p>
</div></blockquote>
<p>int <strong>type</strong></p>
<blockquote>
<div><p>FITS type (TINT, TSHORT, TDOUBLE, etc.)</p>
</div></blockquote>
<p>int <strong>eventini</strong></p>
<blockquote>
<div><p>Initial event to start writing</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411toGslVectorPPvPP10gsl_vectorlii">
<span id="_CPPv311toGslVectorPPvPP10gsl_vectorlii"></span><span id="_CPPv211toGslVectorPPvPP10gsl_vectorlii"></span><span id="toGslVector__voidPP.gsl_vectorPP.l.i.i"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">toGslVector</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">buffer</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">array</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nevent</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">eventini</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411toGslVectorPPvPP10gsl_vectorlii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>inoututils.cpp</em></p>
<p>The function puts the values of the input buffer into an output GSL vector.</p>
<p><strong>Members/Variables</strong></p>
<p>void** <strong>buffer</strong></p>
<blockquote>
<div><p>Input buffer with data</p>
</div></blockquote>
<p>gsl_vector** <strong>array</strong></p>
<blockquote>
<div><p>Output GSL vector</p>
</div></blockquote>
<p>long <strong>nevent</strong></p>
<blockquote>
<div><p>Number of elements to store</p>
</div></blockquote>
<p>int <strong>eventini</strong></p>
<blockquote>
<div><p>Initial element number</p>
</div></blockquote>
<p>int <strong>type</strong></p>
<blockquote>
<div><p>FITS type (TINT, TSHORT, TDOUBLE, etc.)</p>
</div></blockquote>
</dd></dl>

<span class="target" id="v"><span id="u"></span></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413vector2matrixP10gsl_vectorPP10gsl_matrix">
<span id="_CPPv313vector2matrixP10gsl_vectorPP10gsl_matrix"></span><span id="_CPPv213vector2matrixP10gsl_vectorPP10gsl_matrix"></span><span id="vector2matrix__gsl_vectorP.gsl_matrixPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">vector2matrix</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vectorin</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">matrixout</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413vector2matrixP10gsl_vectorPP10gsl_matrix" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function converts an input <img class="math" src="_images/math/d8a059564f5703504a6a97d5b2b50b206645b996.png" alt="n^2"/> vector into an output square matrix <img class="math" src="_images/math/65c4484545603a3a8dfc82d595cc28b897032353.png" alt="[n \times n]"/>. It puts the first <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> elements of the vector in the first row of the matrix, the second group of <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> elements (from <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> to <img class="math" src="_images/math/559743c4738bf906182227658a62c8711f9319db.png" alt="2n-1"/>) of the vector in the second row and so on.</p>
<p><strong>Members/Variables</strong></p>
<p>gsl_vector** <strong>vectorin</strong></p>
<blockquote>
<div><p>GSL input vector whose length is <img class="math" src="_images/math/d8a059564f5703504a6a97d5b2b50b206645b996.png" alt="n^2"/></p>
</div></blockquote>
<p>gsl_matrix* <strong>matrixout</strong></p>
<blockquote>
<div><p>GSL output square matrix <img class="math" src="_images/math/65c4484545603a3a8dfc82d595cc28b897032353.png" alt="[n \times n]"/></p>
</div></blockquote>
</dd></dl>

<span class="target" id="w"></span><dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412weightMatrixP21ReconstructInitSIRENAbP16PulsesCollectionP16PulsesCollectionlP10gsl_vectorP10gsl_vectorPP10gsl_matrixPP10gsl_matrix">
<span id="_CPPv312weightMatrixP21ReconstructInitSIRENAbP16PulsesCollectionP16PulsesCollectionlP10gsl_vectorP10gsl_vectorPP10gsl_matrixPP10gsl_matrix"></span><span id="_CPPv212weightMatrixP21ReconstructInitSIRENAbP16PulsesCollectionP16PulsesCollectionlP10gsl_vectorP10gsl_vectorPP10gsl_matrixPP10gsl_matrix"></span><span id="weightMatrix__ReconstructInitSIRENAP.b.PulsesCollectionP.PulsesCollectionP.l.gsl_vectorP.gsl_vectorP.gsl_matrixPP.gsl_matrixPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">weightMatrix</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">saturatedPulses</span></span>, <span class="n"><span class="pre">PulsesCollection</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulsesAll</span></span>, <span class="n"><span class="pre">PulsesCollection</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulsesInRecord</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nonpileupPulses</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">nonpileup</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulseaverage</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">covariance</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">weight</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412weightMatrixP21ReconstructInitSIRENAbP16PulsesCollectionP16PulsesCollectionlP10gsl_vectorP10gsl_vectorPP10gsl_matrixPP10gsl_matrix" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p><span id="id2">[<a class="reference internal" href="zreferences.html#id8" title="D. J. Fixsen and others. Pulse estimation in nonlinear detectors with nonstationary noise. Nuclear Instruments and Methods in Physics Research A, 520:555-558, March 2004. doi:10.1016/j.nima.2003.11.313.">Fixsen+04</a>]</span></p>
<p>This function calculates the weight matrix by using the non piled-up pulses found in all the records, stored in <em>pulsesAll</em> (previous records) and <em>pulsesInRecord</em> (current record). The weight matrix of each energy (and other intermediate values) will be stored in the library by the function <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">fillInLibraryData()</span></code>.</p>
<p>Definitions:</p>
<blockquote>
<div><p><img class="math" src="_images/math/d821970b0cd4694230470d76bb1191e969b74fd8.png" alt="S_i^p"/>: Value of the ith-sample of the pulse number <em>p</em></p>
<p><img class="math" src="_images/math/11b6c9081951416177d36444fca62c76a9a1f03b.png" alt="M_i^p"/>: Value of the ith-sample of the model number <em>p</em> (model= <em>pulseaverage</em>):</p>
<div class="math">
<p><img src="_images/math/f5cae7fbd6fee49e292900817f4922ca139f89f8.png" alt="M_i = &lt;S_i&gt; = (1/N)\sum_{p=1}^{N}S_i^p"/></p>
</div><p>N: number of non piled-up pulses</p>
<div class="math">
<p><img src="_images/math/0630828451fea1a2f4657d36350e53d3effc83d8.png" alt="&amp; D_i = S_i - M_i \\
&amp; V_{ij} = &lt;D_iD_j&gt; = E[(S_i-M_i)(S_j-M_j)] = (1/N)\sum_{p=1}^{N}(S_i^p-M_i^p)(S_j^p-M_j^p) \\
&amp; V = \left[\begin{matrix} &lt;D_1D_1&gt; &amp; &lt;D_1D_2&gt; &amp; ... &amp; &lt;D_1D_n&gt; \\
&lt;D_2D_1&gt; &amp; &lt;D_2D_2&gt; &amp; ... &amp; &lt;D_2D_n&gt; \\
....  &amp;  ....  &amp; ... &amp;  ....  \\
&lt;D_nD_1&gt; &amp; &lt;D_nD_2&gt; &amp; ... &amp; &lt;D_nD_n&gt;\end{matrix}\right]"/></p>
</div><p>where <em>n</em> is the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLengthNotPadded"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLengthNotPadded</span></code></a> and thus <img class="math" src="_images/math/ef438dcdad8117f68c1f07ebaee17e6237c9cb25.png" alt="V = [n \times n]"/>.</p>
<p>The weight matrix <img class="math" src="_images/math/dadfd0c1c291e3beb691aaec067bfc0ae6915769.png" alt="W = [V]^{-1}"/>.</p>
</div></blockquote>
<p>Steps:</p>
<blockquote>
<div><ul>
<li><p>Calculate the elements of the diagonal of the covariance matrix</p></li>
<li><p>Calculate the elements out of the diagonal of the covariance matrix</p></li>
<li><p>If saturated pulses <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Covariance matrix is a singular matrix <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Non invertible</p>
<p>In order to allow the covariance matrix to be inverted <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Replacing 0’s (0’s are due to the saturated values, equal in the pulse and in the model)</p>
<ul class="simple">
<li><p>Elements of the diagonal: Generating a random double <img class="math" src="_images/math/0464a071da3203b9d565701f510a766ae52f3016.png" alt="f_1"/> between a range <em>(fMin,fMax)</em> (-NoiseStd,NoiseStd) to replace 0’s with <img class="math" src="_images/math/5618eb243e1e817e1d2728a5044d5d1944859f2c.png" alt="f_1^2"/></p></li>
<li><p>Elements out of the diagonal: Generating two random doubles <img class="math" src="_images/math/0464a071da3203b9d565701f510a766ae52f3016.png" alt="f_1"/> and <img class="math" src="_images/math/8bba708bfd9e1df2575d817c79ab6ae0139b20c6.png" alt="f_2"/> between a range <em>(fMin,fMax)</em> (-NoiseStd,NoiseStd) to replace 0’s with <img class="math" src="_images/math/9a9ea6213f15f7db292a06229e467bf789827ec6.png" alt="f_1 \cdot f_2"/></p></li>
</ul>
</li>
<li><p>Calculate the weight matrix</p></li>
</ul>
</div></blockquote>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values)</p>
</div></blockquote>
<p>bool <strong>saturatedPulses</strong></p>
<blockquote>
<div><p>If <em>true</em>, all the pulses ( <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a> = 0 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> all the pulses have the same energy) are saturated</p>
</div></blockquote>
<p>PulsesCollection* <strong>pulsesAll</strong></p>
<blockquote>
<div><p>Collection of pulses found in the previous records</p>
</div></blockquote>
<p>PulsesCollection* <strong>pulsesInRecord</strong></p>
<blockquote>
<div><p>Collection of pulses found in the current record</p>
</div></blockquote>
<p>long <strong>nonpileupPulses</strong></p>
<blockquote>
<div><p>Number of non piled-up pulses</p>
</div></blockquote>
<p>gsl_vector* <strong>nonpileup</strong></p>
<blockquote>
<div><p>GSL vector containing info about all the pulses informing if they are piled-up or not</p>
</div></blockquote>
<p>gsl_vector** <strong>pulseaverage</strong></p>
<blockquote>
<div><p>GSL vector with the pulseaverage (= template = model) of the non piled-up pulses</p>
</div></blockquote>
<p>gsl_matrix** <strong>covariance</strong></p>
<blockquote>
<div><p>GSL matrix with covariance matrix</p>
</div></blockquote>
<p>gsl_matrix** <strong>weight</strong></p>
<blockquote>
<div><p>GSL matrix with weight matrix</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417weightMatrixNoiseP10gsl_matrixPP10gsl_matrix">
<span id="_CPPv317weightMatrixNoiseP10gsl_matrixPP10gsl_matrix"></span><span id="_CPPv217weightMatrixNoiseP10gsl_matrixPP10gsl_matrix"></span><span id="weightMatrixNoise__gsl_matrixP.gsl_matrixPP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">weightMatrixNoise</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">intervalMatrix</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">weight</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417weightMatrixNoiseP10gsl_matrixPP10gsl_matrix" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>gennoisespec.cpp</em></p>
<p>This function calculates the weight matrix of the noise</p>
<blockquote>
<div><p><img class="math" src="_images/math/c493811970fe3f0f8605b0cd1b63a11ad19ca165.png" alt="D_i"/>: Pulse free interval
<img class="math" src="_images/math/e4762cec46619bf7781cae62216214f909395368.png" alt="V"/>: Covariance matrix</p>
<blockquote>
<div><p><img class="math" src="_images/math/2b49d0667e1c339489b924c4bb35c2a1c8df7a86.png" alt="V_{ij} = E[DiDj]-E[Di]E[Dj]"/></p>
</div></blockquote>
<p><img class="math" src="_images/math/031b32dcdb0546b094670b0a9b21f72f63ac06d6.png" alt="Di^p"/>: Value of the pth-sample of the pulse-free interval i
<img class="math" src="_images/math/3bfb3a64189a14b2704f4610827762d5e3145114.png" alt="N"/>: Number of samples</p>
<div class="math">
<p><img src="_images/math/1d218585bbb0f237c54f4118d633c19936d6aff3.png" alt="&amp; V_{ij} =  &lt;D_iD_j&gt; = E[D_iD_j] = (1/N)sum_{p=1}^{N}(Di^p)(Dj^p) \\
&amp; V = \left[\begin{matrix} &lt;D_1D_1&gt; &amp; &lt;D_1D_2&gt; &amp; ... &amp; &lt;D_1D_n&gt; \\
&lt;D_2D_1&gt; &amp; &lt;D_2D_2&gt; &amp; ... &amp; &lt;D_2D_n&gt; \\
....  &amp;  ....  &amp; ... &amp;  ....  \\
&lt;D_nD_1&gt; &amp; &lt;D_nD_2&gt; &amp; ... &amp; &lt;D_nD_n&gt;\end{matrix}\right]"/></p>
</div><p>where <em>n</em> is the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLengthNotPadded"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLengthNotPadded</span></code></a> and thus <img class="math" src="_images/math/ef438dcdad8117f68c1f07ebaee17e6237c9cb25.png" alt="V = [n \times n]"/>.</p>
<p>The weight matrix <img class="math" src="_images/math/4329fc9fd354bb4930e7186d69c6b6f544b5b54a.png" alt="W = 1/V"/>.</p>
</div></blockquote>
<p>Steps:</p>
<ul class="simple">
<li><p>Calculate the elements of the diagonal of the covariance matrix</p></li>
<li><p>Calculate the elements out of the diagonal of the covariance matrix</p></li>
<li><p>Calculate the weight matrix</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>gsl_matrix* <strong>intervalMatrix</strong></p>
<blockquote>
<div><p>GSL matrix containing pulse-free intervals whose baseline is 0 (baseline previously subtracted) [nintervals x intervalMinSamples]</p>
</div></blockquote>
<p>gsl_matrix** <strong>weight</strong></p>
<blockquote>
<div><p>GSL matrix with weight matrix</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414writeFilterHDUPP21ReconstructInitSIRENAidP10gsl_vectorPP8fitsfile">
<span id="_CPPv314writeFilterHDUPP21ReconstructInitSIRENAidP10gsl_vectorPP8fitsfile"></span><span id="_CPPv214writeFilterHDUPP21ReconstructInitSIRENAidP10gsl_vectorPP8fitsfile"></span><span id="writeFilterHDU__ReconstructInitSIRENAPP.i.double.gsl_vectorP.fitsfilePP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">writeFilterHDU</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">pulse_index</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">energy</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">optimalfilter</span></span>, <span class="n"><span class="pre">fitsfile</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dtcObject</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414writeFilterHDUPP21ReconstructInitSIRENAidP10gsl_vectorPP8fitsfile" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function runs in RECONSTRUCTION mode and writes the optimal filter info (in the <em>FILTER</em> HDU) for each pulse
if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-intermediate"><code class="xref std std-option docutils literal notranslate"><span class="pre">intermediate</span></code></a> = 1 and either <em>reconstruct_init-&gt;OFLib</em> = 0 or <em>reconstruct_init-&gt;OFLib</em> = 1, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-filtEeV"><code class="xref std std-option docutils literal notranslate"><span class="pre">filtEeV</span></code></a> = 0 and the the number of energies in the library FITS file is greater than 1.</p>
<ul class="simple">
<li><p>Declare variables</p></li>
<li><p>Open intermediate FITS file</p></li>
<li><dl class="simple">
<dt>If (<em>reconstruct_init-&gt;OFLib</em> = 0) or (<em>reconstruct_init-&gt;OFLib</em> = 1, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-filtEeV"><code class="xref std std-option docutils literal notranslate"><span class="pre">filtEeV</span></code></a> = 0 and the the number of energies in the library FITS file is greater than 1):</dt><dd><ul>
<li><p>Create the <em>FILTER</em> HDU if it is the first pulse</p></li>
<li><dl class="simple">
<dt>Write data:</dt><dd><ul>
<li><p><strong>OPTIMALF</strong> or <strong>OPTIMALFF</strong> column (in time or frequency domain)</p></li>
<li><p><strong>OFLENGTH</strong> column</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p>Write <strong>ENERGY</strong> column in <em>PULSES</em> HDU</p></li>
<li><p>Close intermediate output FITS file if it is necessary</p></li>
<li><p>Free memory</p></li>
</ul>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>int <strong>pulse_index</strong></p>
<blockquote>
<div><p>Index of the pulse whose info is going to be written (to know if it is the first pulse)</p>
</div></blockquote>
<p>double <strong>energy</strong></p>
<blockquote>
<div><p>Estimated energy (eV)</p>
</div></blockquote>
<p>gsl_vector* <strong>optimalfilter</strong></p>
<blockquote>
<div><p>Optimal filter (in time or frequency domain)</p>
</div></blockquote>
<p>fitsfile** <strong>dtcObject</strong></p>
<blockquote>
<div><p>Fitsfile object for intermeadiate file name</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416writeFitsComplex6IODataP10gsl_matrix">
<span id="_CPPv316writeFitsComplex6IODataP10gsl_matrix"></span><span id="_CPPv216writeFitsComplex6IODataP10gsl_matrix"></span><span id="writeFitsComplex__IOData.gsl_matrixP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">writeFitsComplex</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">IOData</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">obj</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">matrix</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416writeFitsComplex6IODataP10gsl_matrix" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>inoututils.cpp</em></p>
<p>This function reads values of a GSL matrix. After that, the function puts them into a complex column of the output FITS file.</p>
<p><strong>Members/Variables</strong></p>
<p>IOData <strong>obj</strong></p>
<blockquote>
<div><p>Object for FITS column to be written</p>
</div></blockquote>
<p>gsl_matrix* <strong>matrix</strong></p>
<blockquote>
<div><p>Input GSL matrix with data</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415writeFitsSimple6IODataP10gsl_vector">
<span id="_CPPv315writeFitsSimple6IODataP10gsl_vector"></span><span id="_CPPv215writeFitsSimple6IODataP10gsl_vector"></span><span id="writeFitsSimple__IOData.gsl_vectorP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">writeFitsSimple</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">IOData</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">obj</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vector</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415writeFitsSimple6IODataP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located  in file: <em>inoututils.cpp</em></p>
<p>This function reads values of a GSL vector. After that, the function puts them into a column of the output FITS file.</p>
<p><strong>Members/Variables</strong></p>
<p>IOData <strong>obj</strong></p>
<blockquote>
<div><p>Object for FITS column to be written</p>
</div></blockquote>
<p>gsl_vector* <strong>vector</strong></p>
<blockquote>
<div><p>Input GSL vector with data</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv412writeLibraryP21ReconstructInitSIRENAddP10gsl_vectorP10gsl_matrixP10gsl_matrixbPP8fitsfileP10gsl_vector">
<span id="_CPPv312writeLibraryP21ReconstructInitSIRENAddP10gsl_vectorP10gsl_matrixP10gsl_matrixbPP8fitsfileP10gsl_vector"></span><span id="_CPPv212writeLibraryP21ReconstructInitSIRENAddP10gsl_vectorP10gsl_matrixP10gsl_matrixbPP8fitsfileP10gsl_vector"></span><span id="writeLibrary__ReconstructInitSIRENAP.double.double.gsl_vectorP.gsl_matrixP.gsl_matrixP.b.fitsfilePP.gsl_vectorP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">writeLibrary</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samprate</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">estenergy</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulsetemplate</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">covariance</span></span>, <span class="n"><span class="pre">gsl_matrix</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">weight</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">appendToLibrary</span></span>, <span class="n"><span class="pre">fitsfile</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">inLibObject</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pulsetemplateMaxLengthFixedFilter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412writeLibraryP21ReconstructInitSIRENAddP10gsl_vectorP10gsl_matrixP10gsl_matrixbPP8fitsfileP10gsl_vector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function writes the library (reordering if it is necesary and calculating some intermediate parameters)</p>
<blockquote>
<div><ul class="simple">
<li><p>Adding a new row to the library if <em>appendToLibrary = true</em> (<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">readAddSortParams()</span></code>)</p></li>
<li><p>Write the first row of the library if <em>appendToLibrary = false</em> (<a class="reference internal" href="#_CPPv411addFirstRowP21ReconstructInitSIRENAPP8fitsfilediP10gsl_vectorP10gsl_vectorP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrixP10gsl_matrix" title="addFirstRow"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">addFirstRow()</span></code></a>)</p></li>
<li><p>In both cases, the keywords <code class="docutils literal notranslate"><span class="pre">CREADATE</span></code> and <code class="docutils literal notranslate"><span class="pre">SIRENAV</span></code> with the date and SIRENA version are written</p></li>
</ul>
</div></blockquote>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values)</p>
</div></blockquote>
<p>double <strong>samprate</strong></p>
<blockquote>
<div><p>Sampling rate</p>
</div></blockquote>
<p>double <strong>estenergy</strong></p>
<blockquote>
<div><p>Pulse height of the template whose energy is going to be added to the library</p>
</div></blockquote>
<p>gsl_vector* <strong>pulsetemplate</strong></p>
<blockquote>
<div><p>GSL vector with the pulse template whose energy is going to be added to the library</p>
</div></blockquote>
<p>gsl_matrix** <strong>covariance</strong></p>
<blockquote>
<div><p>GSL matrix with covariance matrix</p>
</div></blockquote>
<p>gsl_matrix** <strong>weight</strong></p>
<blockquote>
<div><p>GSL matrix with weight matrix</p>
</div></blockquote>
<p>bool <strong>appendToLibrary</strong></p>
<blockquote>
<div><p><em>true</em> if adding a new row to the library and <em>false</em> if it is the first row to be added</p>
</div></blockquote>
<p>fitsfile** <strong>inLibObject</strong></p>
<blockquote>
<div><p>FITS object containing information of the library FITS file</p>
</div></blockquote>
<p>gsl_vector* <strong>pulsetemplateMaxLengthFixedFilter</strong></p>
<blockquote>
<div><p>GSL vector with the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a>-length pulse template whose energy is going to be added to the library</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv48writeLogP4FILE6stringi6string">
<span id="_CPPv38writeLogP4FILE6stringi6string"></span><span id="_CPPv28writeLogP4FILE6stringi6string"></span><span id="writeLog__FILEP.string.i.string"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">writeLog</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">fileRef</span></span>, <span class="n"><span class="pre">string</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">type</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">verbosity</span></span>, <span class="n"><span class="pre">string</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">message</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48writeLogP4FILE6stringi6string" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located  in file: <em>inoututils.cpp</em></p>
<p>This function includes the processing of the each level of message in the log file and the output screen:</p>
<blockquote>
<div><ul class="simple">
<li><p>Verbosity = 0 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The log file and the output screen include Errors</p></li>
<li><p>Verbosity = 1 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The log file and the output screen include Errors and Warnings</p></li>
<li><p>Verbosity = 2 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The log file and the output screen include Errors, Warnings and Alerts</p></li>
<li><p>Verbosity = 3 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> The log file and the output screen include Errors, Warnings, Alerts and Log messages</p></li>
</ul>
</div></blockquote>
<p><strong>Members/Variables</strong></p>
<p>FILE* <strong>fileRef</strong></p>
<blockquote>
<div><p>File reference to log file</p>
</div></blockquote>
<p>string <strong>type</strong></p>
<blockquote>
<div><blockquote>
<div><p>String to indicate error type “Error”, “Warning”, “Alert”,”Log” or “OK”</p>
</div></blockquote>
<p>int <strong>verbosity</strong></p>
<blockquote>
<div><p>Integer value for verbosity</p>
</div></blockquote>
<p>string <strong>message</strong></p>
<blockquote>
<div><p>String message to print</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411writePulsesPP21ReconstructInitSIRENAddP10gsl_vectoriP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectorP8fitsfile">
<span id="_CPPv311writePulsesPP21ReconstructInitSIRENAddP10gsl_vectoriP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectorP8fitsfile"></span><span id="_CPPv211writePulsesPP21ReconstructInitSIRENAddP10gsl_vectoriP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectorP8fitsfile"></span><span id="writePulses__ReconstructInitSIRENAPP.double.double.gsl_vectorP.i.gsl_vectorP.gsl_vectorP.gsl_vectorP.gsl_vectorP.gsl_vectorP.fitsfileP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">writePulses</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">samprate</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">initialtime</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">invectorNOTFIL</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">numPulsesRecord</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tstart</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">tend</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">quality</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">taurise</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">taufall</span></span>, <span class="n"><span class="pre">fitsfile</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dtcObject</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411writePulsesPP21ReconstructInitSIRENAddP10gsl_vectoriP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectorP10gsl_vectorP8fitsfile" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function writes the data of the pulses found in the record in the intermediate FITS file (in the <em>PULSES</em> HDU). The pulses info given is: <strong>TSTART</strong>, <strong>I0</strong> (the pulse itself), <strong>TEND</strong>, <strong>TAURISE</strong>, <strong>TAUFALL</strong> and <strong>QUALITY</strong>.</p>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values).</p>
</div></blockquote>
<p>double <strong>samprate</strong></p>
<blockquote>
<div><p>Sampling rate (to convert samples to seconds)</p>
</div></blockquote>
<p>double <strong>initialtime</strong></p>
<blockquote>
<div><p>Starting time of the record (in order to calculate absolute times)</p>
</div></blockquote>
<p>gsl_vector* <strong>invectorNOTFIL</strong></p>
<blockquote>
<div><p>GSL vector with the original record (neither low-pass filtered nor differentiated)</p>
</div></blockquote>
<p>int <strong>numPulsesRecord</strong></p>
<blockquote>
<div><p>Number of pulses found in the record</p>
</div></blockquote>
<p>gsl_vector* <strong>tstart</strong></p>
<blockquote>
<div><p>GSL vector with the start times of the found pulses</p>
</div></blockquote>
<p>gsl_vector* <strong>tend</strong></p>
<blockquote>
<div><p>GSL vector with the end times of the found pulses</p>
</div></blockquote>
<p>gsl_vector* <strong>quality</strong></p>
<blockquote>
<div><p>GSL vector with the quality of the found pulses</p>
<p>0 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Standard (good) pulses</p>
<p>1 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Truncated pulses at the beginning</p>
<p>2 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Truncated pulses at the end</p>
<p>10 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Saturated pulses</p>
<p>11 <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Truncated and saturated pulses</p>
</div></blockquote>
<p>gsl_vector* <strong>taurise</strong></p>
<blockquote>
<div><p>GSL vector with the rise time constants of the found pulses (to be done)</p>
</div></blockquote>
<p>gsl_vector* <strong>taufall</strong></p>
<blockquote>
<div><p>GSL vector with the fall time constants of the found pulses (to be done)</p>
</div></blockquote>
<p>fitsfile* <strong>dtcObject</strong></p>
<blockquote>
<div><p>Object which contains information of the intermediate FITS file</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv413writeTestInfoP21ReconstructInitSIRENAP10gsl_vectordP8fitsfile">
<span id="_CPPv313writeTestInfoP21ReconstructInitSIRENAP10gsl_vectordP8fitsfile"></span><span id="_CPPv213writeTestInfoP21ReconstructInitSIRENAP10gsl_vectordP8fitsfile"></span><span id="writeTestInfo__ReconstructInitSIRENAP.gsl_vectorP.double.fitsfileP"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">writeTestInfo</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ReconstructInitSIRENA</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">reconstruct_init</span></span>, <span class="n"><span class="pre">gsl_vector</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">recordDERIVATIVE</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">threshold</span></span>, <span class="n"><span class="pre">fitsfile</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dtcObject</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv413writeTestInfoP21ReconstructInitSIRENAP10gsl_vectordP8fitsfile" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>tasksSIRENA.cpp</em></p>
<p>This function writes the <em>TESTINFO</em> HDU in the intermediate FITS file. The written columns are <strong>FILDER</strong> (low-pass filtered and differentiated record) and <strong>THRESHOLD</strong>.</p>
<p><strong>Members/Variables</strong></p>
<p>ReconstructInitSIRENA** <strong>reconstruct_init</strong></p>
<blockquote>
<div><p>Member of <em>ReconstructInitSIRENA</em> structure to initialize the reconstruction parameters (pointer and values)</p>
</div></blockquote>
<p>gsl_vector* <strong>recordDERIVATIVE</strong></p>
<blockquote>
<div><p>GSL vector with input record (low-pass filtered and) differentiated</p>
</div></blockquote>
<p>double <strong>threshold</strong></p>
<blockquote>
<div><p>Threshold value used to find pulses</p>
</div></blockquote>
<p>fitsfile <strong>dtcObject</strong></p>
<blockquote>
<div><p>Object which contains information of the intermediate FITS file</p>
</div></blockquote>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417writeTPSreprExtenv">
<span id="_CPPv317writeTPSreprExtenv"></span><span id="_CPPv217writeTPSreprExtenv"></span><span id="writeTPSreprExten"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">writeTPSreprExten</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417writeTPSreprExtenv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Located in file: <em>gennoisespec.cpp</em></p>
<p>This function writes the noisespec output FITS file.</p>
<p>Steps:</p>
<ul class="simple">
<li><p>Allocate GSL vectors</p></li>
<li><p>Write the data in the output FITS file (print only half of FFT to prevent aliasing)</p></li>
<li><p><em>NOISE</em> HDU only contains positive frequencies (<img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> Multiply by 2 the amplitude)</p></li>
<li><p><em>NOISEALL</em> HDU contains negative and positive frequencies <img class="math" src="_images/math/d1a55bc0d5f4b30060db724826d79f376a4cd4d4.png" alt="\Rightarrow"/> It is the HDU read to build the optimal filters</p></li>
<li><p><em>WEIGHTMS</em> HDU</p></li>
</ul>
</dd></dl>

<span class="target" id="z"><span id="y"></span><span id="x"></span></span></section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="zreferences.html" title="References"
             >next</a> |</li>
        <li class="right" >
          <a href="SIRENAcommandline.html" title="SIRENA Tools CLI"
             >previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>

        <li class="nav-item nav-item-this"><a href="">SIRENA functions</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Bea Cobo &amp; Maite Ceballos (IFCA).
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>