
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SIRENA description &#8212; SIRENA 4.0 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="_static/_themes/themes_overrides.css" />
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="SIRENA Tools CLI" href="SIRENAcommandline.html" />
    <link rel="prev" title="SIRENA documentation" href="index.html" /> 
  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="index.html"><img src="_static/SIRENA_black.png" border="0" alt="py4sci"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="SIRENAcommandline.html" title="SIRENA Tools CLI"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="SIRENA documentation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>

        <li class="nav-item nav-item-this"><a href="">SIRENA description</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/SIRENA_black.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">SIRENA description</a><ul>
<li><a class="reference internal" href="#purpose">Purpose</a></li>
<li><a class="reference internal" href="#files">Files</a><ul>
<li><a class="reference internal" href="#auxiliary-files">Auxiliary Files</a><ul>
<li><a class="reference internal" href="#noise-file"><span class="pageblue">Noise file</span></a></li>
<li><a class="reference internal" href="#template-library"><span class="pageblue">Template Library</span></a></li>
</ul>
</li>
<li><a class="reference internal" href="#input-files">Input Files</a></li>
<li><a class="reference internal" href="#output-files">Output Files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reconstruction-process">Reconstruction Process</a><ul>
<li><a class="reference internal" href="#event-detection">Event Detection</a><ul>
<li><a class="reference internal" href="#adjusted-derivative"><span class="pageblue">Adjusted Derivative</span></a></li>
<li><a class="reference internal" href="#single-threshold-crossing"><span class="pageblue">Single Threshold Crossing</span></a></li>
</ul>
</li>
<li><a class="reference internal" href="#event-grading">Event Grading</a></li>
<li><a class="reference internal" href="#event-energy-determination-methods">Event Energy Determination: methods</a><ul>
<li><a class="reference internal" href="#optimal-filtering-by-using-the-noise-spectral-density"><span class="pageblue">Optimal Filtering by using the noise spectral density</span></a></li>
<li><a class="reference internal" href="#optimal-filtering-by-using-the-noise-weight-matrix-from-noise-intervals"><span class="pageblue">Optimal Filtering by using the noise weight matrix from noise intervals</span></a></li>
<li><a class="reference internal" href="#quasi-resistance-space"><span class="pageblue">Quasi Resistance Space</span></a></li>
<li><a class="reference internal" href="#two-experimental-approaches-adding-a-prebuffer-or-0-padding"><span class="pageblue">Two experimental approaches: adding a preBuffer or 0-padding</span></a></li>
<li><a class="reference internal" href="#covariance-matrices"><span class="pageblue">Covariance matrices</span></a></li>
<li><a class="reference internal" href="#covariance-matrices-0-n"><span class="pageblue">Covariance matrices 0(n)</span></a></li>
<li><a class="reference internal" href="#principal-component-analysis-pca"><span class="pageblue">Principal Component Analysis (PCA)</span></a></li>
</ul>
</li>
<li><a class="reference internal" href="#use-of-library-columns-in-the-different-reconstruction-methods">Use of library columns in the different reconstruction methods</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">SIRENA documentation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="SIRENAcommandline.html"
                        title="next chapter">SIRENA Tools CLI</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/SIRENA.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="sirena-description">
<span id="sirena"></span><h1>SIRENA description<a class="headerlink" href="#sirena-description" title="Permalink to this headline">¶</a></h1>
<div class="section" id="purpose">
<h2>Purpose<a class="headerlink" href="#purpose" title="Permalink to this headline">¶</a></h2>
<p>SIRENA (<em>Software Ifca for Reconstruction of EveNts for Athena X-IFU</em>) is a software package developed to reconstruct the energy of the incoming X-ray photons after their detection in the <a class="reference external" href="http://x-ifu.irap.omp.eu/">X-IFU</a> TES detector. This is done by means of a tool called <a class="reference internal" href="SIRENAcommandline.html#tesreconstruction"><span class="std std-ref">tesreconstruction</span></a>, which is mainly a wrapper to pass a data file to the SIRENA tasks.</p>
<p>SIRENA is integrated in the <a class="reference external" href="http://www.sternwarte.uni-erlangen.de/research/sixte">SIXTE</a> end-to-end simulations environment where it currently runs over SIXTE or XIFUSIM (available for the XIFU consortium members upon request at <a class="reference external" href="mailto:sixte-xifusim&#37;&#52;&#48;lists&#46;fau&#46;de">sixte-xifusim<span>&#64;</span>lists<span>&#46;</span>fau<span>&#46;</span>de</a>) simulated data. In the <img class="math" src="_images/math/92de66f8b672e3fb14b85d1abef1022c5109c20e.png" alt="\mathit{sixte/scripts/SIRENA}"/> folder of the SIXTE environment, a straightforward SIRENA tutorial and a set of scripts can be found with the aim of providing the user with a first approach running SIRENA.</p>
<p>The SIRENA software is regularly updated in the SIXTE environment and beta versions are often uploaded to a (<a class="reference external" href="https://github.com/bcobo/SIRENA">SIRENA GitHub repository</a>).</p>
</div>
<div class="section" id="files">
<h2>Files<a class="headerlink" href="#files" title="Permalink to this headline">¶</a></h2>
<div class="section" id="auxiliary-files">
<span id="auxiliary"></span><h3>Auxiliary Files<a class="headerlink" href="#auxiliary-files" title="Permalink to this headline">¶</a></h3>
<p>All the <a class="reference internal" href="#reconmethods"><span class="std std-ref">reconstruction methods</span></a> used by SIRENA software rely on the existence of a <em>library</em> created from a set of data calibration files. In addition, some methods require also a file with the <em>noise data</em>. Let’s describe these auxiliary files in detail.</p>
<div class="section" id="noise-file">
<span id="noise"></span><h4><span class="pageblue">Noise file</span><a class="headerlink" href="#noise-file" title="Permalink to this headline">¶</a></h4>
<p>The detector <strong>noise file</strong> is currently obtained from a long stream of pulse-free (noise) simulated data. This stream is ingested in the tool <a class="reference internal" href="SIRENAcommandline.html#gennoisespec"><span class="std std-ref">gennoisespec</span></a>, which generates the spectrum of this simulated noise.</p>
<p><strong>1) Calibration Stream Simulation</strong></p>
<p>The first step is creating a photon list (not required if is already available one with no pulses):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tesconstpileup</span></code> (SIXTE):  which creates a <a class="reference internal" href="#piximpactfig"><span class="std std-ref">piximpact file</span></a> of zero-energy events.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">tesconstpileup</span> <span class="n">PixImpList</span><span class="o">=</span><span class="n">noise</span><span class="o">.</span><span class="n">piximpact</span> <span class="n">XMLFile</span><span class="o">=</span><span class="n">tes</span><span class="o">.</span><span class="n">XML</span> <span class="n">tstop</span><span class="o">=</span><span class="n">simulationTime</span> <span class="n">energy</span><span class="o">=</span><span class="mi">0</span> \
<span class="n">pulseDistance</span><span class="o">=</span><span class="mi">1</span> <span class="n">triggersize</span><span class="o">=</span><span class="mi">10000</span>
</pre></div>
</div>
<div class="figure align-center" id="piximpactfig">
<a class="reference internal image-reference" href="_images/NoisePiximpact1.png"><img alt="_images/NoisePiximpact1.png" src="_images/NoisePiximpact1.png" style="width: 50%;" /></a>
</div>
<div class="figure align-center" id="id36">
<a class="reference internal image-reference" href="_images/NoisePiximpact2.png"><img alt="_images/NoisePiximpact2.png" src="_images/NoisePiximpact2.png" style="width: 50%;" /></a>
<p class="caption"><span class="caption-text">Piximpact file of no events.</span><a class="headerlink" href="#id36" title="Permalink to this image">¶</a></p>
</div>
<p>The second step is simulating the noise stream. This can be done by choosing either a SIXTE tool (<code class="docutils literal notranslate"><span class="pre">tessim</span></code>) or a XIFUSIM tool (<code class="docutils literal notranslate"><span class="pre">xifusim</span></code>), both of them simulating the fake impacts through the detector’s physics and creating data stream splitted into records:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tessim</span></code> (<a class="bibtex reference internal" href="zreferences.html#wilms2016" id="id1">[Wilms+16]</a>)(SIXTE): use option <cite>triggertype=noise</cite>.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&gt; tessim PixID=pixelNumber PixImpList=noise.piximpact Streamfile=noise.fits tstart=0. \
tstop=simulationTime triggertype=noise triggersize=10000 prebuffer=0 \
PixType=file:${SIXTE}/share/sixte/instruments/athena-xifu/newpix_LPA75um.fits \
acbias=yes
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xifusim</span></code> (XIFUSIM): use option <cite>simnoise=y</cite>.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">xifusim</span> <span class="n">PixImpList</span><span class="o">=</span><span class="n">noise</span><span class="o">.</span><span class="n">piximpact</span> <span class="n">Streamfile</span><span class="o">=</span><span class="n">noise</span><span class="o">.</span><span class="n">fits</span> <span class="n">tstop</span><span class="o">=</span><span class="n">simulationTime</span> <span class="n">acbias</span><span class="o">=</span><span class="n">no</span>\
<span class="n">XMLfilename</span><span class="o">=</span><span class="n">myfileXF</span><span class="o">.</span><span class="n">xml</span> <span class="n">trig_reclength</span><span class="o">=</span><span class="mi">10000</span> <span class="n">sample_rate</span><span class="o">=</span><span class="mi">156250</span> <span class="n">simnoise</span><span class="o">=</span><span class="n">y</span>
</pre></div>
</div>
<div class="figure align-center" id="id37">
<span id="noise-records"></span><a class="reference internal image-reference" href="_images/stream2triggers.png"><img alt="_images/stream2triggers.png" src="_images/stream2triggers.png" style="width: 678.0px; height: 447.5px;" /></a>
<p class="caption"><span class="caption-text">Noise file triggered into records of 10000 samples by using <code class="docutils literal notranslate"><span class="pre">tessim</span></code> <a class="footnote-reference brackets" href="#id3" id="id2">1</a> .</span><a class="headerlink" href="#id37" title="Permalink to this image">¶</a></p>
</div>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">xifusim</span></code> (XIFUSIM) is used, the noise records are in the <em>TESRECORDS</em> HDU (Header Data Unit) among others HDUs such as <em>GEOCHANNELPARAM</em>, <em>TESPARAM</em>, <em>SQUIDPARAM</em>,…</p>
</dd>
</dl>
<p><strong>2) Noise spectrum and weight matrices generation</strong></p>
<p>In <a class="reference internal" href="SIRENAcommandline.html#gennoisespec"><span class="std std-ref">gennoisespec</span></a>, the data is analysed record by record: if there are events present, this tool <a class="reference internal" href="#detect"><span class="std std-ref">finds</span></a> and rejects them, keeping only the pulse-free intervals of a size given by the input parameter <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-intervalMinSamples"><code class="xref std std-option docutils literal notranslate"><span class="pre">intervalMinSamples</span></code></a> (the hidden <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-pulse_length"><code class="xref std std-option docutils literal notranslate"><span class="pre">pulse_length</span></code></a> input parameter establishes which part of the record is rejected due to a found pulse). If no events are present, the record is divided into pulse-free intervals sized also by this parameter.</p>
<p>Once the pulse-free intervals have been defined, a long noise interval is built by putting together these pulse-free intervals in order to calculate the noise baseline. Moreover, if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-rmNoiseInterval"><code class="xref std std-option docutils literal notranslate"><span class="pre">rmNoiseInterval</span></code></a> = yes the noise intervals whose standard deviation is too high are discarded.</p>
<p>On one hand, the tool calculates the FFT of the non-discarded pulse-free intervals (over the unfiltered data) and averages them. Only a specific number of intervals (input parameter <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-nintervals"><code class="xref std std-option docutils literal notranslate"><span class="pre">nintervals</span></code></a>) will be used. The noise spectrum density is stored in the <em>NOISE</em> and <em>NOISEALL</em> HDUs in the <em>noise data</em> file.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">gennoisespec</span> <span class="n">inFile</span><span class="o">=</span><span class="n">noise</span><span class="o">.</span><span class="n">fits</span> <span class="n">outFile</span><span class="o">=</span><span class="n">noiseSpec</span><span class="o">.</span><span class="n">fits</span> <span class="n">intervalMinSamples</span><span class="o">=</span><span class="n">pulseLength</span> \
<span class="n">nintervals</span><span class="o">=</span><span class="mi">1000</span> <span class="n">pulse_length</span><span class="o">=</span><span class="n">pulseLength</span>
</pre></div>
</div>
<div class="figure align-center" id="id38">
<span id="noisespec"></span><a class="reference internal image-reference" href="_images/NoiseSpec.png"><img alt="_images/NoiseSpec.png" src="_images/NoiseSpec.png" style="width: 662.5px; height: 421.5px;" /></a>
<p class="caption"><span class="caption-text">Noise spectrum (see noise file <a class="reference internal" href="SIRENAcommandline.html#outnoise"><span class="std std-ref">description</span></a>)</span><a class="headerlink" href="#id38" title="Permalink to this image">¶</a></p>
</div>
<p>On the other hand, if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-weightMS"><code class="xref std std-option docutils literal notranslate"><span class="pre">weightMS</span></code></a> = <em>yes</em> the tool calculates the covariance matrix of the noise, <img class="math" src="_images/math/e4762cec46619bf7781cae62216214f909395368.png" alt="V"/>, whose elements are expectation values (<img class="math" src="_images/math/d8806491007c294e559fd064039b48081ffb240c.png" alt="E[·]"/>) of two-point products for a pulse-free data sequence <img class="math" src="_images/math/7766a0df5593146ca0464a1cf0557b923eadf57f.png" alt="{di}"/> (over the unfiltered data) (<a class="bibtex reference internal" href="zreferences.html#fowler2015" id="id4">[FowlerAlpertDoriese+15]</a>)</p>
<div class="math">
<p><img src="_images/math/02195ae06cdbdae8f551ef1893cc35622b70e3b6.png" alt="V_{ij}=E[d_i d_j]-E[d_i]E[d_j]"/></p>
</div><p>The weight matrix is the inverse of the covariance matrix, <img class="math" src="_images/math/48f762b92daad44c14c8b664be2ea2880f6b46b5.png" alt="V^{-1}"/>. The weight matrixes, <strong>Wx</strong>, for different lenghts are stored in the <em>WEIGHTMS</em> HDU in the <em>noise data</em> file. The lengths x will be base-2 values and will vary from the base-2 system value closest-lower than or equal-to the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-intervalMinSamples"><code class="xref std std-option docutils literal notranslate"><span class="pre">intervalMinSamples</span></code></a> decreasing until 2.</p>
<div class="figure align-center" id="id39">
<span id="noisespec2"></span><a class="reference internal image-reference" href="_images/WeightMatrix.png"><img alt="_images/WeightMatrix.png" src="_images/WeightMatrix.png" style="width: 355.20000000000005px; height: 365.6px;" /></a>
<p class="caption"><span class="caption-text">Noise weight matrix (see noise file <a class="reference internal" href="SIRENAcommandline.html#outnoise"><span class="std std-ref">description</span></a>)</span><a class="headerlink" href="#id39" title="Permalink to this image">¶</a></p>
</div>
<p><a class="reference internal" href="SIRENAcommandline.html#gennoisespec"><span class="std std-ref">gennoisespec</span></a> also adds the <code class="docutils literal notranslate"><span class="pre">BSLN0</span></code> and <code class="docutils literal notranslate"><span class="pre">NOISESTD</span></code> keywords to the <em>NOISE</em> HDU in the <em>noise data</em> file. They store the mean and the standard deviation of the noise (by working with the long noise interval).</p>
<p>If the noise spectrum or the weight matrixes are to be created from a data stream containing pulses, care should be taken with the parameters <a class="reference internal" href="SIRENAcommandline.html#scalefactor-gennoisespec"><span class="std std-ref">scaleFactor</span></a>, <a class="reference internal" href="SIRENAcommandline.html#samplesup-gennoisespec"><span class="std std-ref">samplesUp</span></a> and <a class="reference internal" href="SIRENAcommandline.html#nsgms-gennoisespec"><span class="std std-ref">nSgms</span></a> responsible of the detection process.</p>
<p>The sampling rate is calculated by using some keywords in the input FITS file. In case of <code class="docutils literal notranslate"><span class="pre">tessim</span></code> simulated data files, using the <code class="docutils literal notranslate"><span class="pre">DELTAT</span></code> keyword <em>samplingRate=1/deltat</em>. In case of <code class="docutils literal notranslate"><span class="pre">xifusim</span></code> simulated data files, every detector type defines a master clock-rate <code class="docutils literal notranslate"><span class="pre">TCLOCK</span></code> and the sampling rate is calculated either from a given decimation factor <code class="docutils literal notranslate"><span class="pre">DEC_FAC</span></code> (FDM and NOMUX) as <em>samplingRate=1/(tclock·dec_fac)</em>, or from the row period  <code class="docutils literal notranslate"><span class="pre">P_ROW</span></code> and the number of rows <code class="docutils literal notranslate"><span class="pre">NUMROW</span></code> (TDM) as <em>samplingRate=1/(tclock·numrow·p_row)</em>. In case of old simulated files, the sampling rate could be read from the <code class="docutils literal notranslate"><span class="pre">HISTORY</span></code> keyword in the <em>Primary</em> HDU. If the sampling frequency can not be get from the input file after all, a message will ask the user to include the <code class="docutils literal notranslate"><span class="pre">DELTAT</span></code> keyword (inverse of the sampling rate) in the input FITS file before running again.</p>
</div>
<div class="section" id="template-library">
<span id="library"></span><h4><span class="pageblue">Template Library</span><a class="headerlink" href="#template-library" title="Permalink to this headline">¶</a></h4>
<p>The <strong>library</strong> purpose is to store detector pulse magnitudes (templates, covariance matrices, optimal filters) at different calibration energies, so that they could be used afterwards for the
reconstruction of input pulses of unknown energy.</p>
<p>To build this library, a bunch of monochromatic pulses at different energies are simulated by <code class="docutils literal notranslate"><span class="pre">tesconstpileup</span></code> (which now creates a <em>piximpact</em> file with pairs of constant separation pulses) and either <code class="docutils literal notranslate"><span class="pre">tessim</span></code> or <code class="docutils literal notranslate"><span class="pre">xifusim</span></code> (which simulate the detector physics).</p>
<p><strong>1) Calibration Files simulation</strong></p>
<p>Typical run commands to create these calibration files for a given energy <em>monoEkeV</em> and a given (large) <em>separation</em> in samples between the pulses would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">tesconstpileup</span> <span class="n">PixImpList</span><span class="o">=</span><span class="n">calib</span><span class="o">.</span><span class="n">piximpact</span> <span class="n">XMLFile</span><span class="o">=</span><span class="n">tes</span><span class="o">.</span><span class="n">XML</span> <span class="n">timezero</span><span class="o">=</span><span class="mf">3.E-7</span>\
<span class="n">tstop</span><span class="o">=</span><span class="n">simulationTime</span> <span class="n">offset</span><span class="o">=-</span><span class="mi">1</span> <span class="n">energy</span><span class="o">=</span><span class="n">monoEkeV</span> <span class="n">pulseDistance</span><span class="o">=</span><span class="n">separation</span>\
<span class="n">TriggerSize</span><span class="o">=</span><span class="n">tsize</span> <span class="n">sample_freq</span><span class="o">=</span><span class="mi">156250</span>
</pre></div>
</div>
<p>where <em>simulationTime</em> should be large enough to simulate around 20000 isolated pulses and <em>tsize</em> is the size of every simulation stream containing the two separated pulses.</p>
<p>As in the noise simulation, either SIXTE (<code class="docutils literal notranslate"><span class="pre">tessim</span></code>) or XIFUSIM (<code class="docutils literal notranslate"><span class="pre">xifusim</span></code>) are eligible:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&gt; tessim PixID=pixelNumber PixImpList=calib.piximpact Streamfile=calib.fits tstart=0. \
tstop=simulationTime triggertype=&#39;diff:3:100:supress&#39; triggerSize=recordSize \
PixType=file:${SIXTE}/share/sixte/instruments/athena-xifu/newpix_LPA75um.fits acbias=yes
</pre></div>
</div>
<p>where <em>suppress</em> is the time (in samples) after the triggering of an event, during which <cite>tessim</cite> will avoid triggering again (see figure below).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">xifusim</span> <span class="n">PixImpList</span><span class="o">=</span><span class="n">calib</span><span class="o">.</span><span class="n">piximpact</span> <span class="n">Streamfile</span><span class="o">=</span><span class="n">calib</span><span class="o">.</span><span class="n">fits</span> <span class="n">tstart</span><span class="o">=</span><span class="mf">0.</span> <span class="n">tstop</span><span class="o">=</span><span class="mf">5000.</span> \
<span class="n">XMLfilename</span><span class="o">=</span><span class="n">myfileXF</span><span class="o">.</span><span class="n">xml</span> <span class="n">trig_reclength</span><span class="o">=</span><span class="n">tsize</span> <span class="n">trig_n_pre</span><span class="o">=</span><span class="mi">1000</span> <span class="n">trig_thresh</span><span class="o">=</span><span class="mf">60.</span> \
<span class="n">trig_n_suppress</span><span class="o">=</span><span class="mi">8192</span> <span class="n">acbias</span><span class="o">=</span><span class="n">no</span> <span class="n">sample_rate</span><span class="o">=</span><span class="mi">156250</span> <span class="n">simnoise</span><span class="o">=</span><span class="n">y</span>
</pre></div>
</div>
<div class="figure align-center" id="id40">
<a class="reference internal image-reference" href="_images/triggering.png"><img alt="_images/triggering.png" src="_images/triggering.png" style="width: 561.5px; height: 397.0px;" /></a>
<p class="caption"><span class="caption-text">Parameters involved in triggering into records from <code class="docutils literal notranslate"><span class="pre">tesconstpileup</span></code> to <code class="docutils literal notranslate"><span class="pre">tessim</span></code> <a class="footnote-reference brackets" href="#id6" id="id5">2</a>.</span><a class="headerlink" href="#id40" title="Permalink to this image">¶</a></p>
</div>
<dl class="footnote brackets">
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id5">2</a></span></dt>
<dd><p>Previous figure is equivalent in <code class="docutils literal notranslate"><span class="pre">xifusim</span></code> replacing <em>triggerSize</em>, <em>suppress</em> and <em>PreBufferSize</em> by <em>trig_reclength</em>, <em>trig_n_suppress</em> and <em>trig_n_pre</em> respectively.</p>
</dd>
</dl>
<p>The SIXTE simulated calibration files are now FITS files with only one HDU called <em>RECORDS</em> <a class="footnote-reference brackets" href="#id8" id="id7">3</a> populated with four columns: <strong>TIME</strong> (arrival time of the event), <strong>ADC</strong> (digitized current), <strong>PIXID</strong> (pixel identification) and <strong>PH_ID</strong> (photon identification, for debugging purposes only).</p>
<div class="figure align-center" id="id41">
<a class="reference internal image-reference" href="_images/records.png"><img alt="_images/records.png" src="_images/records.png" style="width: 554.0px; height: 448.0px;" /></a>
<p class="caption"><span class="caption-text">Records in calibration file by using <code class="docutils literal notranslate"><span class="pre">tessim</span></code>.</span><a class="headerlink" href="#id41" title="Permalink to this image">¶</a></p>
</div>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id7">3</a></span></dt>
<dd><p>If XIFUSIM is used, the calibration files have not only the <em>TESRECORDS</em> HDU with the events records but also others such as <em>GEOCHANNELPARAM</em>, <em>TESPARAM</em>, <em>SQUIDPARAM</em>, <em>WFEEPARAM</em>, <em>DREPARAM</em>, <em>ADCPARAM</em> and <em>TRIGGERPARAM</em>.</p>
</dd>
</dl>
<p><strong>2) Library construction</strong></p>
<p>Once the calibration files (for all the 1..N calibration energies) have been created, the library is built through the wrapper tool <code class="docutils literal notranslate"><span class="pre">tesreconstruction</span></code>. To run it using SIRENA code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">tesreconstruction</span> <span class="n">Recordfile</span><span class="o">=</span><span class="n">calib</span><span class="o">.</span><span class="n">fits</span> <span class="n">TesEventFile</span><span class="o">=</span><span class="n">evtcal</span><span class="o">.</span><span class="n">fits</span> <span class="n">largeFilter</span><span class="o">=</span><span class="mi">8192</span> \
<span class="n">LibraryFile</span><span class="o">=</span><span class="n">library</span><span class="o">.</span><span class="n">fits</span> <span class="n">opmode</span><span class="o">=</span><span class="mi">0</span> <span class="n">clobber</span><span class="o">=</span><span class="n">yes</span> <span class="n">monoenergy</span><span class="o">=</span><span class="n">monoEeV_1</span> <span class="n">EventListSize</span><span class="o">=</span><span class="mi">1000</span>\
<span class="n">NoiseFile</span><span class="o">=</span><span class="n">noiseSpec</span><span class="o">.</span><span class="n">fits</span> <span class="n">scaleFactor</span><span class="o">=</span><span class="n">sF</span> <span class="n">samplesUp</span><span class="o">=</span><span class="n">sU</span> <span class="n">nSgms</span><span class="o">=</span><span class="n">nS</span> \
<span class="n">hduPRECALWN</span><span class="o">=</span><span class="n">yes</span><span class="o">/</span><span class="n">no</span> <span class="n">hduPRCLOFWM</span><span class="o">=</span><span class="n">yes</span><span class="o">/</span><span class="n">no</span>

<span class="p">[</span><span class="o">.....</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="n">tesreconstruction</span> <span class="n">Recordfile</span><span class="o">=</span><span class="n">calib</span><span class="o">.</span><span class="n">fits</span> <span class="n">TesEventFile</span><span class="o">=</span><span class="n">evtcal</span><span class="o">.</span><span class="n">fits</span> <span class="n">largeFile</span><span class="o">=</span><span class="mi">8192</span>\
<span class="n">LibraryFile</span><span class="o">=</span><span class="n">library</span><span class="o">.</span><span class="n">fits</span> <span class="n">opmode</span><span class="o">=</span><span class="mi">0</span> <span class="n">clobber</span><span class="o">=</span><span class="n">yes</span> <span class="n">monoenergy</span><span class="o">=</span><span class="n">monoEeV_N</span> <span class="n">EventListSize</span><span class="o">=</span><span class="mi">1000</span>\
<span class="n">NoiseFile</span><span class="o">=</span><span class="n">noiseSpec</span><span class="o">.</span><span class="n">fits</span> <span class="n">scaleFactor</span><span class="o">=</span><span class="n">sF</span> <span class="n">samplesUp</span><span class="o">=</span><span class="n">sU</span> <span class="n">nSgms</span><span class="o">=</span><span class="n">nS</span> \
<span class="n">hduPRECALWN</span><span class="o">=</span><span class="n">yes</span><span class="o">/</span><span class="n">no</span> <span class="n">hduPRCLOFWM</span><span class="o">=</span><span class="n">yes</span><span class="o">/</span><span class="n">no</span>
</pre></div>
</div>
<p>The parameters of <code class="docutils literal notranslate"><span class="pre">tesreconstruction</span></code>  for the library creation process are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-opmode"><code class="xref std std-option docutils literal notranslate"><span class="pre">opmode</span></code></a>: should be set to 0 if tool is used for library creation.</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-RecordFile"><code class="xref std std-option docutils literal notranslate"><span class="pre">RecordFile</span></code></a>: record FITS file.</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-TesEventFile"><code class="xref std std-option docutils literal notranslate"><span class="pre">TesEventFile</span></code></a>: output event list FITS file.</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-NoiseFile"><code class="xref std std-option docutils literal notranslate"><span class="pre">NoiseFile</span></code></a>: noise spectrum FITS file.</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-LibraryFile"><code class="xref std std-option docutils literal notranslate"><span class="pre">LibraryFile</span></code></a>: calibration library FITS file.</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-0"><code class="xref std std-option docutils literal notranslate"><span class="pre">scaleFactor</span></code></a>, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-1"><code class="xref std std-option docutils literal notranslate"><span class="pre">samplesUp</span></code></a> and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-2"><code class="xref std std-option docutils literal notranslate"><span class="pre">nSgms</span></code></a>: parameters involved in the pulse detection process.</p></li>
</ul>
<ul class="simple">
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a>: length (in samples) of the longest fixed filter. If the interval size (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-intervalMinSamples"><code class="xref std std-option docutils literal notranslate"><span class="pre">intervalMinSamples</span></code></a>) used to create the noise is larger that this value, noise will be decimated accordingly when used to pre-calculate the optimal filters or the covariance matrices. If it is shorter, an error will be raised.</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-preBuffer"><code class="xref std std-option docutils literal notranslate"><span class="pre">preBuffer</span></code></a>: some samples added before the starting time of a pulse.</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-5"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a>: energy calculation Method: OPTFILT (Optimal filtering), WEIGHT (Covariance matrices), WEIGHTN (Covariance matrices, first order), I2R and I2RFITTED (Linear Transformations), or PCA (Principal Component Analysis).</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-6"><code class="xref std std-option docutils literal notranslate"><span class="pre">Ifit</span></code></a>: constant to apply the I2RFITTED conversion</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-monoenergy"><code class="xref std std-option docutils literal notranslate"><span class="pre">monoenergy</span></code></a>: the monochromatic energy of the calibration pulses used to create the current row in the library.</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRECALWN"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRECALWN</span></code></a> and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRCLOFWM"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRCLOFWM</span></code></a>: parameters to create or not the corresponding HDUs.</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-3"><code class="xref std std-option docutils literal notranslate"><span class="pre">LrsT</span></code></a> and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-4"><code class="xref std std-option docutils literal notranslate"><span class="pre">LbT</span></code></a>: running sum filter length and baseline averaging length.</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-tstartPulse1"><code class="xref std std-option docutils literal notranslate"><span class="pre">tstartPulse1</span></code></a> and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-tstartPulse2"><code class="xref std std-option docutils literal notranslate"><span class="pre">tstartPulse2</span></code></a> and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-tstartPulse3"><code class="xref std std-option docutils literal notranslate"><span class="pre">tstartPulse3</span></code></a>: start time (in samples) of the first, second and third pulse in the record (0 if detection should be performed by the system; greater than 0 if provided by the user).</p></li>
<li><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-intermediate"><code class="xref std std-option docutils literal notranslate"><span class="pre">intermediate</span></code></a> and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-detectFile"><code class="xref std std-option docutils literal notranslate"><span class="pre">detectFile</span></code></a>: write intermediate file and name of this intermediate file.</p></li>
</ul>
<p id="librarycolumns"><strong>3) Library structure</strong></p>
<p>The library FITS file has 3 HDUs called <em>LIBRARY</em>, <em>FIXFILTT</em>, <em>FIXFILTF</em> which are always present, and other 2 HDUs  <em>PRECALWN</em> and <em>PRCLOFWM</em> which are optional depending on the input parameters <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRECALWN"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRECALWN</span></code></a> and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRCLOFWM"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRCLOFWM</span></code></a>.</p>
<p><em>LIBRARY</em> contains the following columns:</p>
<ul class="simple">
<li><p><strong>ENERGY</strong>: energies (in eV) in the library</p></li>
<li><p><strong>PHEIGHT</strong>: pulse heights of the templates</p></li>
</ul>
<ul class="simple">
<li><p><strong>PULSE</strong>: templates (obtained averaging many signals) with baseline. Its length is the base-2 value closest-lower than or equal-to the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a></p></li>
<li><p><strong>PLSMXLFF</strong>: long templates according to <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a> (obtained averaging many signals) with baseline. If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a> is a base-2, it does not appear (it only appears <strong>PULSE</strong>)</p></li>
<li><p><strong>PULSEB0</strong>: baseline subtracted templates (from <strong>PULSE</strong>)</p></li>
<li><p><strong>MF</strong>: matched filters (energy normalized templates) (from <strong>PULSE</strong>)</p></li>
<li><p><strong>MFB0</strong>: baseline subtracted matched filters ((from <strong>MFB0</strong>))</p></li>
<li><p><strong>COVARM</strong>: <a class="reference internal" href="#covmatrices"><span class="std std-ref">covariance matrices</span></a> ( <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-PulseLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">PulseLength</span></code></a> x <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-PulseLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">PulseLength</span></code></a> in shape ) stored in the FITS column as vectors of size <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-PulseLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">PulseLength</span></code></a> * <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-PulseLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">PulseLength</span></code></a>. It appears if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRECALWN"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRECALWN</span></code></a> = yes</p></li>
<li><p><strong>WEIGHTM</strong>: <a class="reference internal" href="#covmatrices"><span class="std std-ref">weight matrices</span></a> ( <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-PulseLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">PulseLength</span></code></a> x <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-PulseLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">PulseLength</span></code></a> in shape) stored in the FITS column as vectors of size <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-PulseLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">PulseLength</span></code></a> * <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-PulseLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">PulseLength</span></code></a>. It appears if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRECALWN"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRECALWN</span></code></a> = yes</p></li>
<li><p><strong>WAB</strong>: matrices <img class="math" src="_images/math/7e372e5297ed48180133f220e870a93da715eda3.png" alt="(W_\alpha + W_\beta)/2"/> stored as vectors ( <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-PulseLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">PulseLength</span></code></a> * <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-PulseLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">PulseLength</span></code></a> ), being <img class="math" src="_images/math/f312c77e5ecc3f770e2e4e9c54751c2fb0be5bac.png" alt="\mathit{W}"/> weight matrixes and <img class="math" src="_images/math/2f5aa019312e1bbc969deab8dca8b00f76025404.png" alt="\alpha"/> and <img class="math" src="_images/math/7138dad9ac96835665b17f5817eacfcaa9b834c9.png" alt="\beta"/> two consecutive energies in the library. It appears if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRECALWN"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRECALWN</span></code></a> = yes</p></li>
<li><p><strong>TV</strong>: vectors <img class="math" src="_images/math/ad074f3fb56e9c069bd7e7ccc40a3210412aaed5.png" alt="S_{\beta}-S_{\alpha}"/> being <img class="math" src="_images/math/f18bf639d8e5490eec40c8a4a6a7a1389c3dd6a5.png" alt="S_i"/> the template at <img class="math" src="_images/math/01601c8c5715da701de49b36a05e1c90253323a3.png" alt="\mathit{i}"/> energy. It appears if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRECALWN"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRECALWN</span></code></a> = yes</p></li>
<li><p><strong>tE</strong>: scalars <img class="math" src="_images/math/bac474829cd8c723558bb1a6854b938f9b5ae5e4.png" alt="T \cdot W_{\alpha} \cdot T"/>. It appears if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRECALWN"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRECALWN</span></code></a> = yes</p></li>
<li><p><strong>XM</strong>: matrices <img class="math" src="_images/math/7740dcec544dd348d6642033ce6048dea09ef3d9.png" alt="(W_\beta + W_\alpha)/t"/> stored as vectors ( <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-PulseLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">PulseLength</span></code></a> * <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-PulseLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">PulseLength</span></code></a> ). It appears if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRECALWN"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRECALWN</span></code></a> = yes</p></li>
<li><p><strong>YV</strong>: vectors <img class="math" src="_images/math/441ee5b5d6b9b6a7d35ed72fe5154d1d2ba9c185.png" alt="(W_\alpha \cdot T)/t"/>. It appears if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRECALWN"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRECALWN</span></code></a> = yes</p></li>
<li><p><strong>ZV</strong>: vectors <img class="math" src="_images/math/5dccdce50cc64639c773b9f271b103e40e7cf8bc.png" alt="\mathit{X \cdot T}"/>. It appears if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRECALWN"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRECALWN</span></code></a> = yes</p></li>
<li><p><strong>rE</strong>: scalars <img class="math" src="_images/math/672d09d8e4a966af82b5df660a93979413838f39.png" alt="\mathit{1/(Z \cdot T)}"/>. It appears if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-hduPRECALWN"><code class="xref std std-option docutils literal notranslate"><span class="pre">hduPRECALWN</span></code></a> = yes</p></li>
<li><p><strong>PAB</strong>: vectors <img class="math" src="_images/math/af14c4847ab9f539e94c713197bc6fc2ffb25038.png" alt="S_{\alpha}- E_{\alpha}(S_{\beta}-S_{\alpha})/(E_{\beta}-E_{\alpha})"/>, <img class="math" src="_images/math/9c91463a6cf1a0eee31df97be39ad933677ecc1c.png" alt="P(t)_{\alpha\beta}"/> in <a class="reference internal" href="#optimalfilter-nsd"><span class="std std-ref">first order approach</span></a>. It appears if there are several calibration energies (not only one) included in the library</p></li>
<li><p><strong>PABMXLFF</strong>: <strong>PAB</strong> according to <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a>. If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a> is a base-2, it does not appear (although several calibration energies are included in the library)</p></li>
<li><p><strong>DAB</strong>: vectors <img class="math" src="_images/math/08dc6e8446dee139977d36351bdaaf7656d59fa1.png" alt="(S_{\beta}-S_{\alpha})/(E_{\beta}-E_{\alpha})"/>, <img class="math" src="_images/math/2302c9216fadbbf6c3f283dcc7ee3ff1ea54b7dd.png" alt="D(t)_{\alpha\beta}"/> in <a class="reference internal" href="#optimalfilter-nsd"><span class="std std-ref">first order approach</span></a>. It appears if there are several calibration energies (not only one) included in the library.</p></li>
</ul>
<p>The <em>FIXFILTT</em> HDU contains pre-calculated optimal filters in the time domain for different lengths, calculated from the matched filters (<em>MF</em> or <em>MFB0</em> columns) in <strong>Tx</strong> columns, or from the <em>DAB</em> column, in the <strong>ABTx</strong> columns. The lengths <em>x</em> will be base-2 values and will vary from the base-2 system value closest-lower than or equal-to the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a> decreasing until 2. Moreover, <strong>Txmax</strong> and <strong>ABTxmax</strong> columns being <em>xmax</em> = <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a> are added if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a> is not a base-2 value. The <em>FIXFILTT</em> HDU always contains <strong>Tx</strong> columns but <strong>ABTx</strong> columns only appear if there are several calibration energies (not only one) included in the library.</p>
<p>The <em>FIXFILTF</em> HDU contains pre-calculated optimal filters in frequency domain for different lengths calculated from the matched filters (<em>MF</em> or <em>MFB0</em> columns), in columns <strong>Fx</strong>, or from the <em>DAB</em> column, in <strong>ABFx</strong> columns. The lengths <em>x</em> will be base-2 values and will vary from the base-2 system value closest-lower than or equal-to the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a> decreasing until 2. Moreover, <strong>Fxmax</strong> and <strong>ABFxmax</strong> columns being <em>xmax</em> = <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a> are added if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a> is not a base-2 value. The <em>FIXFILTF</em> HDU always contains <strong>Fx</strong> columns but <strong>ABFx</strong> columns only appear if there are several calibration energies (not only one) included in the library.</p>
<p>The <em>PRECALWN</em> HDU contains <a class="reference internal" href="#weightn"><span class="std std-ref">pre-calculated values by using the noise weight matrix from the subtraction of model from pulses</span></a> <img class="math" src="_images/math/ca71fc88bb7e7f650e9fe7fc9096c4f255733138.png" alt="(X'WX)^{-1}X'W"/> for different lengths, <strong>PCLx</strong>. The lengths <em>x</em> will be base-2 values and will vary from the base-2 system value closest-lower than or equal-to the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a> decreasing until 2.</p>
<p>The <em>PRCLOFWM</em> HDU contains <a class="reference internal" href="#optimalfilter-weightm"><span class="std std-ref">pre-calculated values by using the noise weight matrix from noise intervals</span></a> <img class="math" src="_images/math/5bd86a670370925e7f38e55b1a400a52e823f124.png" alt="(M'WM)^{-1}M'W"/> for different lengths, <strong>OFWx</strong>. The lengths <em>x</em> will be base-2 values and will vary from the base-2 system value closest-lower than or equal-to the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a> decreasing until 2.</p>
</div>
</div>
<div class="section" id="input-files">
<span id="inputfiles"></span><h3>Input Files<a class="headerlink" href="#input-files" title="Permalink to this headline">¶</a></h3>
<p>The input data (simulated) files, currently required to be in FITS format, are a sequence of variable length RECORDS, containing at least a column for the <strong>TIME</strong> of the digitalization process and a column for the detector current (<strong>ADC</strong>) at these samples. Every record (file row) is the result of an initial triggering process done by the SIXTE simulation tool <code class="docutils literal notranslate"><span class="pre">tessim</span></code> <a class="footnote-reference brackets" href="#id10" id="id9">4</a>.</p>
<div class="figure align-center" id="id42">
<span id="records"></span><a class="reference internal image-reference" href="_images/records.png"><img alt="_images/records.png" src="_images/records.png" style="width: 554.0px; height: 448.0px;" /></a>
<p class="caption"><span class="caption-text">Simulated data (pulses) in FITS records by using <code class="docutils literal notranslate"><span class="pre">tessim</span></code>.</span><a class="headerlink" href="#id42" title="Permalink to this image">¶</a></p>
</div>
<dl class="footnote brackets">
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id9">4</a></span></dt>
<dd><p>When working with <code class="docutils literal notranslate"><span class="pre">xifusim</span></code>, <em>TESRECORDS</em> HDU (among others HDUs such as <em>GEOCHANNELPARAM</em>, <em>TESPARAM</em>, <em>SQUIDPARAM</em>,…) instead of <em>RECORDS</em> HDU.</p>
</dd>
</dl>
<p>The sampling rate is calculated by using some keywords in the input FITS file. In case of <code class="docutils literal notranslate"><span class="pre">tessim</span></code> simulated data files, using the <code class="docutils literal notranslate"><span class="pre">DELTAT</span></code> keyword <em>samplingRate=1/deltat</em>. In case of <code class="docutils literal notranslate"><span class="pre">xifusim</span></code> simulated data files, every detector type defines a master clock-rate <code class="docutils literal notranslate"><span class="pre">TCLOCK</span></code> and the sampling rate is calculated either from a given decimation factor <code class="docutils literal notranslate"><span class="pre">DEC_FAC</span></code> (FDM and NOMUX) as <em>samplingRate=1/(tclock·dec_fac)</em>, or from the row period  <code class="docutils literal notranslate"><span class="pre">P_ROW</span></code> and the number of rows <code class="docutils literal notranslate"><span class="pre">NUMROW</span></code> (TDM) as <em>samplingRate=1/(tclock·numrow·p_row)</em>. In case of old simulated files, the sampling rate could be read from the <code class="docutils literal notranslate"><span class="pre">HISTORY</span></code> keyword in the <em>Primary</em> HDU or even from the input XML file. If the sampling frequency can not be get from the input files after all, a message will ask the user to include the <code class="docutils literal notranslate"><span class="pre">DELTAT</span></code> keyword (inverse of the sampling rate) in the input FITS file before running again.</p>
</div>
<div class="section" id="output-files">
<span id="reconoutfiles"></span><h3>Output Files<a class="headerlink" href="#output-files" title="Permalink to this headline">¶</a></h3>
<p>The reconstructed energies for all the detected events are saved into an output FITS file (governed by the <code class="docutils literal notranslate"><span class="pre">tesreconstruction</span></code> input parameter <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-TesEventFile"><code class="xref std std-option docutils literal notranslate"><span class="pre">TesEventFile</span></code></a>). It stores one event per row with the following information, in the HDU named <em>EVENTS</em>:</p>
<ul class="simple">
<li><p><strong>TIME</strong>: arrival time of the event (in s).</p></li>
<li><p><strong>SIGNAL</strong>: energy of the event (in keV).</p></li>
<li><p><strong>AVG4SD</strong>: average of the first 4 samples of the derivative of the pulse.</p></li>
<li><p><strong>ELOWRES</strong>: energy provided by a low resolution energy estimator filtering with a 4-samples-length filter (in keV).</p></li>
<li><p><strong>GRADE1</strong>: length of the filter used, i.e., the distance to the following pulse (in samples) or the pulse length if the next event is further than this value or if there are no more events in the same record.</p></li>
<li><p><strong>GRADE2</strong>: distance to the end of the preceding pulse (in samples). If pulse is the first event in the record, this is fixed to the pulse length value.</p></li>
<li><p><strong>PHI</strong>: arrival phase (offset relative to the central point of the parabola) (in samples).</p></li>
<li><p><strong>LAGS</strong>: number of samples shifted to find the maximum of the parabola.</p></li>
<li><p><strong>BSLN</strong>: mean value of the baseline in general ‘before’ a pulse (according the value in samples of <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-4"><code class="xref std std-option docutils literal notranslate"><span class="pre">LbT</span></code></a>).</p></li>
<li><p><strong>RMSBSLN</strong>: standard deviation of the baseline in general ‘before’ a pulse (according the value in samples of <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-4"><code class="xref std std-option docutils literal notranslate"><span class="pre">LbT</span></code></a>).</p></li>
<li><p><strong>PIX_ID</strong>: pixel number</p></li>
<li><p><strong>PH_ID</strong>: photon number identification for cross matching with the impact list.</p></li>
<li><p><strong>RISETIME</strong>: rise time of the event (in s).</p></li>
<li><p><strong>FALLTIME</strong>: fall time of the event (in s).</p></li>
<li><p><strong>GRADING</strong>: Pulse grade (HighRes=1, MidRes=2, LimRes=3, LowRes=4, Rejected=-1, Pileup=-2).</p></li>
</ul>
<div class="figure align-center" id="evtfile">
<a class="reference internal image-reference" href="_images/events1.png"><img alt="_images/events1.png" src="_images/events1.png" style="width: 382.2px; height: 82.8px;" /></a>
</div>
<div class="figure align-center" id="id43">
<a class="reference internal image-reference" href="_images/events2.png"><img alt="_images/events2.png" src="_images/events2.png" style="width: 979.1999999999999px; height: 345.59999999999997px;" /></a>
<p class="caption"><span class="caption-text">Output event file.</span><a class="headerlink" href="#id43" title="Permalink to this image">¶</a></p>
</div>
<p>In all the output files generated by SIRENA (the noise spectrum file, the library file and the reconstructed events file) the keywords <code class="docutils literal notranslate"><span class="pre">CREADATE</span></code> and <code class="docutils literal notranslate"><span class="pre">SIRENAV</span></code> provide the date of creation of the file and the SIRENA version used to run it respectively.</p>
<p>If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-intermediate"><code class="xref std std-option docutils literal notranslate"><span class="pre">intermediate</span></code></a> = 1, an intermediate FITS file with some useful info (for development purposes especially) will be created. The intermediate FITS file will contain 2 or 3 HDUs, <em>PULSES</em>, <em>TESTINFO</em> and <em>FILTER</em>. The <em>PULSES</em> HDU will contain info about the found pulses: <strong>TSTART</strong>, <strong>I0</strong> (the pulse itself), <strong>TEND</strong>, <strong>QUALITY</strong>, <strong>TAURISE</strong>, <strong>TAUFALL</strong> and <strong>ENERGY</strong>. The <em>TESTINFO</em> HDU will contain <strong>FILDER</strong> (the low-pass filtered and differentiated records) and <strong>THRESHOLD</strong> used in the detection. If it is useful (either <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLib"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLib</span></code></a> = no or <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLib"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLib</span></code></a> = yes, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-filtEeV"><code class="xref std std-option docutils literal notranslate"><span class="pre">filtEeV</span></code></a> = 0 and the the number of energies in the library FITS file is greater than 1), the <em>FILTER</em> HDU will contain the optimal filter used to calculate every pulse energy (<strong>OPTIMALF</strong> or <strong>OPTIMALFF</strong> column depending on time or frequency domain) and its length (<strong>OFLENGTH</strong>).</p>
<div class="figure align-center" id="id44">
<span id="intermfile"></span><a class="reference internal image-reference" href="_images/intermediate.png"><img alt="_images/intermediate.png" src="_images/intermediate.png" style="width: 1152.0px; height: 648.0px;" /></a>
<p class="caption"><span class="caption-text">Intermediate output FITS file with extra info.</span><a class="headerlink" href="#id44" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
<div class="section" id="reconstruction-process">
<span id="recons"></span><h2>Reconstruction Process<a class="headerlink" href="#reconstruction-process" title="Permalink to this headline">¶</a></h2>
<p>The energy reconstruction of the energies of the input pulses is performed with the tool <code class="docutils literal notranslate"><span class="pre">tesreconstruction</span></code> along three main blocks:</p>
<ul class="simple">
<li><p>Event Detection</p></li>
<li><p>Event Grading</p></li>
<li><p>Energy Determination</p></li>
</ul>
<div class="section" id="event-detection">
<span id="detect"></span><h3>Event Detection<a class="headerlink" href="#event-detection" title="Permalink to this headline">¶</a></h3>
<p>The first stage of SIRENA processing is a fine detection process performed over every <em>RECORD</em> in the input file, to look for missing (or secondary) pulses that can be on top of the primary (initially triggered) ones. Two algorithms can be used for this purpose, the <em>Adjusted derivative</em> (<strong>AD</strong>) (see <a class="bibtex reference internal" href="zreferences.html#boyce1999" id="id11">[Boyce+99]</a>) and what has been called <em>Single Threshold Crossing</em> (<strong>STC</strong>) (which has been implemented in the code with the aim of reducing the complexity and the computer power of the AD scheme) (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-detectionMode"><code class="xref std std-option docutils literal notranslate"><span class="pre">detectionMode</span></code></a> ).</p>
<div class="section" id="adjusted-derivative">
<span id="detection-ad"></span><h4><span class="pageblue">Adjusted Derivative</span><a class="headerlink" href="#adjusted-derivative" title="Permalink to this headline">¶</a></h4>
<p>It follows these steps:</p>
<p>1.- The record is differentiated and a <em>median kappa-clipping</em> process is applied to the data, so that the data values larger than the median plus <em>kappa</em> times the quiescent-signal standard deviation, are replaced by the median value in an iterative process until no more data points are left. Then the threshold is established at the clipped-data mean value plus <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-2"><code class="xref std std-option docutils literal notranslate"><span class="pre">nSgms</span></code></a> times the standard deviation.</p>
<div class="figure align-center" id="id45">
<a class="reference internal image-reference" href="_images/mediankappaclipping.png"><img alt="_images/mediankappaclipping.png" src="_images/mediankappaclipping.png" style="width: 952.0px; height: 112.0px;" /></a>
<p class="caption"><span class="caption-text">Median kappa-clipping block diagram.</span><a class="headerlink" href="#id45" title="Permalink to this image">¶</a></p>
</div>
<p>2.- A pulse is detected whenever the derivarive signal is above this threshold.</p>
<div class="figure align-center" id="id46">
<a class="reference internal image-reference" href="_images/ADskecth_blue.png"><img alt="_images/ADskecth_blue.png" src="_images/ADskecth_blue.png" style="width: 476.4px; height: 614.4px;" /></a>
<p class="caption"><span class="caption-text">Block diagram explaining the AD detection process (after the threshold establishment).</span><a class="headerlink" href="#id46" title="Permalink to this image">¶</a></p>
</div>
<p>3.- Based on the first sample of the signal derivative which passes the threshold level, a template is selected from the library. The 25-samples-long dot product of the pre-detected pulse and the template is then calculated at different positions (lags) around the initial starting time of the pulse to better determine its correct starting point. Usually a dot product in 3 different <strong>lags</strong> <a class="footnote-reference brackets" href="#id13" id="id12">5</a> around the sample of the initial detection is adequate to find a maximum and the following steps will depend on whether a maximum of the dot product has been found or not:</p>
<ul class="simple">
<li><p>If a maximum of the dot product has not been found, the starting time of the pulse is fixed to the time when the derivative gets over the threshold (in this case, the <em>tstart</em> matches a digitized sample without taking the possible jitter into account).</p></li>
<li><p>If a maximum of the dot product has been found, a new starting time f the pulse is going to be established (by using the 3-dot-product results around the maximum to analytically define a parabola and locate its maximum). Then, an iterative process begins in order to select the best template from the library, resulting each time in a new starting time with a different jitter. As due to the jitter, the pulses are placed out of a digitized sample clock, the first sample of the derivative of the pulse itself is not exactly the value of the first sample getting over the threshold and it would need to be corrected depending on the time shift with respect to the digitized samples (<em>samp1DER correction</em>).</p></li>
</ul>
<dl class="footnote brackets">
<dt class="label" id="id13"><span class="brackets"><a class="fn-backref" href="#id12">5</a></span></dt>
<dd><p>Nevertheless, when the residual signals are large, the maximum of the dot product moves towards the secondary pulse, missing the primary detection. This is why currently the maximum number of the dot product lags is limited to 5.</p>
</dd>
</dl>
<p>4.- Every time a sample is over the threshold, a check is performed for the slope of the straight line defined by this sample, its preceding one and its following one. If the slope is lower than the minimum slope of the templates in the calibration library, the pulse is discarded (it is likely a residual signal) and start a new search. If the slope is higher than the minimum slope of the templates in the calibration library, the pulse is labeled as detected.</p>
<p>5.- Once a primary pulse is detected in the record, the system starts a secondary detection to look for missing pulses that could be hidden by the primary one. For this purpose, a model template is chosen from the auxiliary library  and subtracted at the position of the detected pulse. The first sample of the detected pulse derivative (possibly different from the initial one after the realocation done by the dot product in the previous step) is used to select again the appropriate template from the library. After the <em>samp1DER correction</em> and also due to the jitter, the 100-samples-long template needs to be aligned with the pulse before subtraction (<em>template correction</em>). Then the search for samples above the threshold starts again.</p>
<p>This is an iterative process, until no more pulses are found.</p>
<p id="lpf">If the noise is large, input data can be low-pass filtered for the initial stage of the event detection. For this purpose, the input parameter <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-0"><code class="xref std std-option docutils literal notranslate"><span class="pre">scaleFactor</span></code></a> (<img class="math" src="_images/math/20bdb17cbbd606e110990bf41f4ad846281198e2.png" alt="\mathit{sF}"/>) is used. The low-pass filtering is applied as a box-car function, a temporal average window. If the cut-off frequency of the filter is <img class="math" src="_images/math/8f2b26baa4b19297c943d6f33a6e60b4b678a866.png" alt="fc"/>, the box-car length is <img class="math" src="_images/math/824220c0fddc72e1b1d3dc465fb6f8f94b3f285d.png" alt="(1/fc) \times \mathit{samprate}"/>, where <img class="math" src="_images/math/22c8486b7343d4eb5e80103626aef583e92daf29.png" alt="\mathit{samprate}"/> is the value of the sampling rate in Hz.</p>
<div class="math">
<p><img src="_images/math/922738a1a0345f236f1697097a2e7468fcbd1c1d.png" alt="f_{c1} &amp;= \frac{1}{pi\cdot\mathit{sF_1}} \\
f_{c2} &amp;= \frac{1}{pi\cdot\mathit{sF_2}}"/></p>
</div><p>for <img class="math" src="_images/math/639b752dd16646de3754571e3b1372ba930f668d.png" alt="\mathit{sF_1} &lt; \mathit{sF_2}"/></p>
<div class="figure align-center" id="id47">
<a class="reference internal image-reference" href="_images/lowpassfilter.png"><img alt="_images/lowpassfilter.png" src="_images/lowpassfilter.png" style="width: 376.5px; height: 100.0px;" /></a>
<p class="caption"><span class="caption-text">Low-pass filtering (LPF)</span><a class="headerlink" href="#id47" title="Permalink to this image">¶</a></p>
</div>
<p>If the parameter <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-0"><code class="xref std std-option docutils literal notranslate"><span class="pre">scaleFactor</span></code></a> is too large, the low-pass filter band is too narrow, and not only noise is rejected during the filtering, but also the signal.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A proper cut-off frequency of the low-pass filter must be chosen in order to avoid piling-up the first derivative and to detect as many pulses as possible in the input FITS file. However, filtering gives rise to a spreading in the signal so, the pulses start time calculated from the first derivative of the low-pass filtered event (which is spread by the low-pass filtering) has to be transformed into the start time of the non-filtered pulse.</p>
</div>
<div class="figure align-center" id="id48">
<a class="reference internal image-reference" href="_images/detect.jpeg"><img alt="_images/detect.jpeg" src="_images/detect.jpeg" style="width: 779.2px; height: 303.2px;" /></a>
<p class="caption"><span class="caption-text">First derivative of initial signal and initial threshold (left) and derivative of signal after subtraction of primary pulses (right).</span><a class="headerlink" href="#id48" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="single-threshold-crossing">
<span id="detection-stc"></span><h4><span class="pageblue">Single Threshold Crossing</span><a class="headerlink" href="#single-threshold-crossing" title="Permalink to this headline">¶</a></h4>
<p>1.- This alternative detection method also compares the derivative signal to a threshold (established in the same way as in the step 1 of the previous algorithm).</p>
<p>2.- If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-1"><code class="xref std std-option docutils literal notranslate"><span class="pre">samplesUp</span></code></a> samples of the derivative are above this threshold a pulse is detected.</p>
<p>3.- After the detection, the first sample of the derivative that crosses the threshold is taken as the Start Time of the detected pulse.</p>
<p>4.- If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-samplesDown"><code class="xref std std-option docutils literal notranslate"><span class="pre">samplesDown</span></code></a> samples of the derivative are below the threshold, the process of looking for a new pulse starts again.</p>
<p>In contrast to apply either of the last two detection algorithms, for testing and debugging purposes SIRENA code can be run in <strong>perfect detection</strong> mode, leaving out the detection stage, provided the (pairs or triplets of) simulated pulses are at the same position in all the RECORDS. In this case the start sample of the first/second/third pulse in the record is taken from the input parameter(s) <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-tstartPulse1"><code class="xref std std-option docutils literal notranslate"><span class="pre">tstartPulse1</span></code></a> <a class="footnote-reference brackets" href="#id15" id="id14">6</a>, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-tstartPulse2"><code class="xref std std-option docutils literal notranslate"><span class="pre">tstartPulse2</span></code></a>, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-tstartPulse3"><code class="xref std std-option docutils literal notranslate"><span class="pre">tstartPulse3</span></code></a> (parameters <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-0"><code class="xref std std-option docutils literal notranslate"><span class="pre">scaleFactor</span></code></a>, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-1"><code class="xref std std-option docutils literal notranslate"><span class="pre">samplesUp</span></code></a> or <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-2"><code class="xref std std-option docutils literal notranslate"><span class="pre">nSgms</span></code></a> would then not be required). Currently no subsample pulse rising has been implemented in the simulations nor in the reconstruction code (future development).</p>
<dl class="footnote brackets">
<dt class="label" id="id15"><span class="brackets"><a class="fn-backref" href="#id14">6</a></span></dt>
<dd><p><a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-tstartPulse1"><code class="xref std std-option docutils literal notranslate"><span class="pre">tstartPulse1</span></code></a> can also be a string with the file name containing the tstart (in seconds) of every pulse.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="event-grading">
<span id="grade"></span><h3>Event Grading<a class="headerlink" href="#event-grading" title="Permalink to this headline">¶</a></h3>
<p>The <em>Event Grading</em> stage qualifies the pulses according to the proximity of other events in the same record.</p>
<p>Once the events in a given record have been detected and their start times established, <strong>grades</strong> are assigned to every event taking into account the proximity of the following and previous pulses. This way, pulses are classified as <em>High</em>, <em>Medium</em>, <em>Limited</em> or <em>Low</em> resolution and as <em>Rejected</em> and <em>Pileup</em> pulses. Currently the grading is performed following the information in the input <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-XMLFile"><code class="xref std std-option docutils literal notranslate"><span class="pre">XMLFile</span></code></a>.</p>
</div>
<div class="section" id="event-energy-determination-methods">
<span id="reconmethods"></span><h3>Event Energy Determination: methods<a class="headerlink" href="#event-energy-determination-methods" title="Permalink to this headline">¶</a></h3>
<p>Once the input events have been detected and graded, their energy content can be determined. Currently all the events (independently of their grade) are processed with the same reconstruction method, but in the future, a different approach could be taken, for example simplifying the reconstruction for the lowest resolution events.</p>
<p>The SIRENA input parameter that controls the reconstruction method applied is <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-5"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> that should take values of <em>OPTFILT</em> for Optimal Filtering in Current space, <em>WEIGHT</em> for Covariance Matrices, <em>WEIGHTN</em> for first order approach of Covariance matrices method and <em>I2R</em> or <em>I2RFITTED</em> for Optimal Filtering implementation in (quasi)Resistance space. If optimal filtering and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFNoise"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFNoise</span></code></a> is <em>WEIGHTM</em> tthe noise weightt matrix from noise intervals is employed instead the noise spectral density (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFNoise"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFNoise</span></code></a> is <em>NSD</em>).</p>
<div class="section" id="optimal-filtering-by-using-the-noise-spectral-density">
<span id="optimalfilter-nsd"></span><h4><span class="pageblue">Optimal Filtering by using the noise spectral density</span><a class="headerlink" href="#optimal-filtering-by-using-the-noise-spectral-density" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>This is the baseline standard technique commonly used to process microcalorimeter data streams. It relies on two main assumptions. Firstly, the detector response is linear; that is, the pulse shapes are identical regardless of their energy and thus, the pulse amplitude is the scaling factor from one pulse to another <a class="bibtex reference internal" href="zreferences.html#boyce1999" id="id16">[Boyce+99]</a>, <a class="bibtex reference internal" href="zreferences.html#szym1993" id="id17">[Szymkowiak+93]</a>.</p>
<p>In the frequency domain (as noise can be frequency dependent), the raw data can be expressed as <img class="math" src="_images/math/3970cbcc7ab32b7accbb13b3d3bb71a3254a58c5.png" alt="P(f) = E\cdot S(f) + N(f)"/>, where <img class="math" src="_images/math/4b09380f889cdfb6b4375ed5b0a69b23c55677b2.png" alt="S(f)"/> is the normalized model pulse shape (matched filter), <img class="math" src="_images/math/18732b2feb4428c46a2db0ed01158777057721fe.png" alt="N(f)"/> is the noise and <img class="math" src="_images/math/1815f600df7845409443aed470eac2d449e4ddb0.png" alt="E"/> is the scalar amplitude for the photon energy.</p>
<p>The second assumption is that the noise is stationary, i.e. it does not vary with time. The amplitude of each pulse can then be estimated by minimizing (weighted least-squares sense) the difference between the noisy data and the model pulse shape, being the <img class="math" src="_images/math/1cbe49dd16598c0550b8a7477dd597e6bc04367e.png" alt="\chi^2"/> condition to be minimized:</p>
<div class="math" id="eqopt">
<p><img src="_images/math/51180eff9438e7b1f554164ba52058291473274a.png" alt="\chi^2 = \int \frac{(P(f)-E \cdot S(f))^2}{\langle\lvert N(f)\lvert ^2\rangle} df"/></p>
</div><p>In the time domain, the amplitude is the best weighted (optimally filtered) sum of the values in the pulse.</p>
<div class="math">
<p><img src="_images/math/0145dcef202b63c04beee7e052bd46a3d98df849.png" alt="E = k \int P(t)\cdot OF(t),"/></p>
</div><p>where <img class="math" src="_images/math/a79e71d115d41b1348337958fd2b5838c263fc41.png" alt="OF(t)"/> is the time domain expression of optimal filter in frequency domain</p>
<div class="math">
<p><img src="_images/math/870e5cfd6c947d9171945cdcfd8c0f20b5ba1aee.png" alt="OF(f) = \frac{S^*(f)}{\langle\lvert N(f)\lvert ^2\rangle}"/></p>
</div><p>and <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> is the normalization factor to give <img class="math" src="_images/math/1815f600df7845409443aed470eac2d449e4ddb0.png" alt="E"/> in units of energy</p>
<div class="math">
<p><img src="_images/math/2f1c70fb00e9be35ce49334fdbc3f60d456f3c46.png" alt="k = \int \frac{S(f)\cdot S^{*}(f)}{\langle\lvert N(f)\lvert ^2\rangle} df"/></p>
</div><p>Optimal filtering reconstruction can be currently performed in two different implementations: <em>baseline subtraction</em> (<strong>B0</strong> in SIRENA wording), where the baseline value read from the <code class="docutils literal notranslate"><span class="pre">BASELINE</span></code> keyword in the noise file is subtracted from the signal, and <em>frequency bin 0</em> (<strong>F0</strong>), where the frequency bin at <em>f=0 Hz</em> is discarded for the construction of the optimal filter. The final filter is thus zero summed, which produces an effective rejection of the signal baseline (see <a class="bibtex reference internal" href="zreferences.html#doriese2009" id="id18">[Doriese+09]</a> for a discussion about the effect of this approach on the TES energy resolution). This option is controlled by the parameter <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterMethod"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterMethod</span></code></a>.</p>
<p><strong>As the X-IFU detector is a non-linear one, the energy estimation after any filtering method has been applied, has to be transformed to an unbiased estimation by the application of a gain scale obtained by the application of the same method to pulse templates at different energies (not done inside SIRENA)</strong>.</p>
<p>In SIRENA, optimal filters can be calculated <em>on-the-fly</em> or read as pre-calculated values from the calibration library. This option is selected with the input parameter <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLib"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLib</span></code></a>. If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLib"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLib</span></code></a> = yes, fixed-length pre-calculated optimal filters (<strong>Tx</strong> or <strong>Fx</strong>) will be read from the library (the length selected <strong>x</strong> will be the base-2 system value closest -lower than or equal- to that of the event being reconstructed or <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-largeFilter"><code class="xref std std-option docutils literal notranslate"><span class="pre">largeFilter</span></code></a>). If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLib"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLib</span></code></a> = no, optimal filters will be calculated specifically for the pulse length of the event under study. This length calculation is determined by the parameter <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFStrategy"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFStrategy</span></code></a>. This way <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFStrategy"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFStrategy</span></code></a> = <em>FREE</em> will optimize the length of the filter to the maximum length available (let’s call this value <em>fltmaxlength</em>), given by the position of the following pulse, or the pulse length if this is shorter (it should be noticed that if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFStrategy"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFStrategy</span></code></a> = <em>FREE</em> and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLib"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLib</span></code></a> = yes, the base-2 system value closest -lower than or equal- to <em>fltmaxlength</em> will be chosen as the optimal filter length). <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFStrategy"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFStrategy</span></code></a> = <em>BYGRADE</em> will choose the filter length to use, according to the <a class="reference internal" href="#grade"><span class="std std-ref">grade</span></a> of the pulse (currently read from the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-XMLFile"><code class="xref std std-option docutils literal notranslate"><span class="pre">XMLFile</span></code></a>) and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFStrategy"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFStrategy</span></code></a> = <em>FIXED</em> will take a fixed length (given by the parameter <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLength</span></code></a>) for all the pulses. These last 2 options are only for checking and development purposes; a normal run with <em>on-the-fly</em> calculations with be done with <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFStrategy"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFStrategy</span></code></a> = <em>FREE</em>. Note that if <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLib"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLib</span></code></a> = no, a noise file must be provided through parameter <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-NoiseFile"><code class="xref std std-option docutils literal notranslate"><span class="pre">NoiseFile</span></code></a> (not in the case of <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLib"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLib</span></code></a> = yes), since in this case the optimal filter must be computed for each pulse at the required length.</p>
<p>In order to reconstruct all the events using filters at a single monochromatic energy, the input library should only contain one row with the calibration columns for that specific energy. If the input library is made of several monochromatic calibration energies, the optimal filters used in the reconstruction process can be tunned to the initially estimated energy of the event being analysed. For this purpose, a first order expansion of the temporal expression of a pulse at the unknown energy <em>E</em> will be taken into account:</p>
<div class="math" id="n">
<p><img src="_images/math/4d6fd6402b3c741f116c6f2370303527fcfd3632.png" alt="P(t,E) = S(t,E_{\alpha}) + b + \frac{(E-E_{\alpha})}{(E_{\beta}-E_{\alpha})}[S(t,E_{\beta})- S(t,E_{\alpha})]"/></p>
</div><p>where <img class="math" src="_images/math/68c7c8c65602677ab56cf7fd88002023f0edc575.png" alt="b"/> is the baseline level, and <img class="math" src="_images/math/06801b5aeb3da717683ff8c3cdb6ed9f370d5b1e.png" alt="S(t,E_{\alpha}), S(t,E_{\beta})"/> are pulse templates (<strong>PULSEB0</strong> columns) at the corresponding energies <img class="math" src="_images/math/b2ba959db58d56fc3434baf3fabe8f7a15561ef9.png" alt="E_{\alpha}, E_{\beta}"/> which embrace the energy <img class="math" src="_images/math/1815f600df7845409443aed470eac2d449e4ddb0.png" alt="E"/>. Operating here and grouping some terms:</p>
<div class="math">
<p><img src="_images/math/e039cd3cd7e35a9101e7218ed19e2dff4c55dfd1.png" alt="&amp; P(t)_{\alpha\beta} = S(t,E_{\alpha}) - \frac{E_{\alpha}}{(E_{\beta}-E_{\alpha})}[S(t,E_{\beta})-S(t,E_{\alpha})]\\
&amp; D(t)_{\alpha\beta} = \frac{[S(t,E_{\beta})-S(t,E_{\alpha})]}{(E_{\beta}-E_{\alpha})}"/></p>
</div><p>then</p>
<div class="math">
<p><img src="_images/math/710f02e0e99e618cc66d39bbe88ec6cacf8cb80d.png" alt="P(t,E) - P(t)_{\alpha\beta} = E \cdot D(t)_{\alpha\beta} + b"/></p>
</div><p>This expression resembles the one above for the optimal filtering if now the data <img class="math" src="_images/math/a3c7182ec35f01796a900808cbb5ad618d1d18e0.png" alt="P(t)"/> is given by <img class="math" src="_images/math/5926ff74fb8516cbcbbccc9d304486086b35d3cc.png" alt="P(t,E) - P(t)_{\alpha\beta}"/> and the role of normalized template <img class="math" src="_images/math/4b09380f889cdfb6b4375ed5b0a69b23c55677b2.png" alt="S(f)"/> is played by <img class="math" src="_images/math/2302c9216fadbbf6c3f283dcc7ee3ff1ea54b7dd.png" alt="D(t)_{\alpha\beta}"/>. This way, the optimal filters can be built over <img class="math" src="_images/math/2302c9216fadbbf6c3f283dcc7ee3ff1ea54b7dd.png" alt="D(t)_{\alpha\beta}"/>.</p>
<p>Again, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLib"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLib</span></code></a> will control whether the required (<em>interpolated</em>) optimal filter (built from <img class="math" src="_images/math/2302c9216fadbbf6c3f283dcc7ee3ff1ea54b7dd.png" alt="D(t)_{\alpha\beta}"/>) is read from the library (at any of the several fixed lengths stored, <strong>Fx</strong> or <strong>Tx</strong> if only one energy included in the library, or <strong>ABFx</strong> or <strong>ABTx</strong> if several energies included in the library) or whether an adequate filter is calculated <em>on-the-fly</em> (<a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLib"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLib</span></code></a> = <em>no</em>).</p>
<div class="figure align-center" id="id49">
<a class="reference internal image-reference" href="_images/OPTloop_new.png"><img alt="_images/OPTloop_new.png" src="_images/OPTloop_new.png" style="width: 635.2px; height: 459.20000000000005px;" /></a>
<p class="caption"><span class="caption-text">Decision loop for optimal filter calculation</span><a class="headerlink" href="#id49" title="Permalink to this image">¶</a></p>
</div>
<p>The optimal filtering technique (selected through the input parameter <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-5"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a>) can be applied in the frequency or in the time domain with the option <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-FilterDomain"><code class="xref std std-option docutils literal notranslate"><span class="pre">FilterDomain</span></code></a>.</p>
<p>The misalignement between the triggered pulse and the template applied for the optimal filter can affect the energy estimate. As the response will be maximum when the data and the template are coincident, an option has been implemented in SIRENA to calculate the energy at three different fixed lags between both, and estimate the final energy to better than the sample frequency (<a class="bibtex reference internal" href="zreferences.html#adams2009" id="id19">[Adams+09]</a>). This possibility is driven by input <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-LagsOrNot"><code class="xref std std-option docutils literal notranslate"><span class="pre">LagsOrNot</span></code></a>.</p>
</div></blockquote>
</div>
<div class="section" id="optimal-filtering-by-using-the-noise-weight-matrix-from-noise-intervals">
<span id="optimalfilter-weightm"></span><h4><span class="pageblue">Optimal Filtering by using the noise weight matrix from noise intervals</span><a class="headerlink" href="#optimal-filtering-by-using-the-noise-weight-matrix-from-noise-intervals" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>By choosing the input parameter <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFNoise"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFNoise</span></code></a> as <strong>WEIGHTM</strong> the optimal filtering method is going to use the noise weight matrix calculated from noise intervals (rather than the noise spectral density as in <a class="reference internal" href="#optimalfilter-nsd"><span class="std std-ref">the previous section</span></a>). Using the noise power spectrum (FFT) is also possible, but it introduces an additional wrong assumption of periodicity. The signal-to-noise cost for filtering in the Fourier domain may be small in some cases but it is worth while checking the importance of this cost (<a class="bibtex reference internal" href="zreferences.html#fowler2015" id="id20">[FowlerAlpertDoriese+15]</a>).</p>
<p>Being <img class="math" src="_images/math/1fbee781f84569077719a167b64e12064360fac1.png" alt="W"/> the noise covariance matrix, the best estimate energy is (<a class="reference internal" href="#weightn"><span class="std std-ref">see mathematical development of the first order approach</span></a> where the variables <img class="math" src="_images/math/ed38fa24f1c94891bd312012aab3f6673be3eb83.png" alt="X"/> and <img class="math" src="_images/math/4abba779877abb276b98ccb2b4ba9bf2e41947ab.png" alt="M"/> should be exchanged because they are not exactly the same):</p>
<div class="math">
<p><img src="_images/math/541ad6fba6102c079148cf14386c11400d2cbf39.png" alt="E = e_1^T[M^T \cdot W \cdot M]^{-1} [M^T \cdot W \cdot Y]"/></p>
</div><p>where <img class="math" src="_images/math/a4073ca0c7fe9b49107908e56035021920ff7046.png" alt="e_1^T \equiv [1, 0]"/> is the unit vector to select only the term that corresponds to the energy (amplitude) of the pulse. <img class="math" src="_images/math/4abba779877abb276b98ccb2b4ba9bf2e41947ab.png" alt="M"/> is a model matrix whose first column is the pulse shape and the second column is a column of ones in order to can calculate the baseline. <img class="math" src="_images/math/7daf0d4815e763eb90f0d5f1dc406f668c1e21db.png" alt="Y"/> is the measured data.</p>
</div></blockquote>
</div>
<div class="section" id="quasi-resistance-space">
<span id="rspace"></span><h4><span class="pageblue">Quasi Resistance Space</span><a class="headerlink" href="#quasi-resistance-space" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>A new approach aimed at dealing with the non-linearity of the signals, is the transformation of the current signal before the reconstruction process to a (quasi) resistance space (<a class="bibtex reference internal" href="zreferences.html#bandler2006" id="id21">[Bandler+06]</a>, <a class="bibtex reference internal" href="zreferences.html#lee2015" id="id22">[Lee+15]</a>). It should improve the linearity by removing the non-linearity due to the bias circuit, although the non-linearity from the R-T transition still remains. A potential additional benefit could also be a more uniform noise across the pulse.</p>
<p><code class="docutils literal notranslate"><span class="pre">tessim</span></code> (<a class="bibtex reference internal" href="zreferences.html#wilms2016" id="id23">[Wilms+16]</a>) is based on a generic model of the TES/absorber pixel with a first stage read-out circuit. The overall setup of this model is presented in the figure below. <code class="docutils literal notranslate"><span class="pre">tessim</span></code> performs the numerical solution of the differential equations for the time-dependent temperature, <img class="math" src="_images/math/67a3360fc1124cab36791ad37a942914378196aa.png" alt="T(t)"/>, and the current, <img class="math" src="_images/math/f18d26a3a2d8ebea3e2c4e5e0108d55122fdd1c6.png" alt="I(t)"/>, in the TES using <a class="bibtex reference internal" href="zreferences.html#irwin2005" id="id24">[Irw05]</a> :</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Physicsmodel_equivalentcircuit.png"><img alt="_images/Physicsmodel_equivalentcircuit.png" src="_images/Physicsmodel_equivalentcircuit.png" style="width: 60%;" /></a>
</div>
<p>Physics model coupling the thermal and electrical behaviour of the TES/absorber pixel used by <code class="docutils literal notranslate"><span class="pre">tessim</span></code>.</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/6e30a87e3fa6c640ec22483b129fec807d5fc5d3.png" alt="C \frac{dT}{dt} = -P_b + R(T,I)I^2 + P_{X-ray} + Noise

L \frac{dI}{dt} = V_0 - IR_L - IR(T,I) + Noise"/></p>
</div></div></blockquote>
<p>In the electrical equation, <img class="math" src="_images/math/19eef1966f7c545af3ac8c0fa486974d873e3c65.png" alt="L"/> is the effective inductance of the readout circuit, <img class="math" src="_images/math/6b4687ed6f0687164e5c9a74bf355e759895de71.png" alt="R_L"/> is the effective load resistor and <img class="math" src="_images/math/3b91308a0751f9601ef49963a6a62565abff8ac7.png" alt="V_0"/> is the constant voltage bias. Under AC bias conditions,</p>
<blockquote>
<div><p><img class="math" src="_images/math/b8b64415adc2ca16c5004add8bed2c1b3daec62f.png" alt="L ="/> <code class="docutils literal notranslate"><span class="pre">LFILTER</span></code> / <code class="docutils literal notranslate"><span class="pre">TTR²</span></code></p>
<p><img class="math" src="_images/math/0f5fef05ab8ef715d5e0fc470fe15d61a1f85c66.png" alt="R_L ="/> <code class="docutils literal notranslate"><span class="pre">RPARA</span></code> / <code class="docutils literal notranslate"><span class="pre">TTR²</span></code></p>
<p><img class="math" src="_images/math/20dd4b26492a81686916c15864735a96ebbbe943.png" alt="\mathit{V0} ="/> <code class="docutils literal notranslate"><span class="pre">I0_START</span></code> ( <code class="docutils literal notranslate"><span class="pre">R0</span></code> <img class="math" src="_images/math/b9dd286c0b8183e52e7cf5d85c3ab235c457af1e.png" alt="+ \mathit{R_L} )"/></p>
</div></blockquote>
<p>and thus the transformation to resistance space would be:</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/d4fb1102a0fc517c755b7129dfaa7fb04bda902a.png" alt="R = \frac{(\mathit{V0} - I \cdot R_L - L \cdot dI/dt)}{I}"/></p>
</div></div></blockquote>
<p>In the previous transformation, the addition of a derivative term increases the noise and thus degrades the resolution. Therefore, a new transformation could be done where the circuit inductance  neglected ( <a class="bibtex reference internal" href="zreferences.html#lee2015" id="id25">[Lee+15]</a> ), thus suppressing the main source on non-linearity of the detector that comes from the first stage read-out circuit:</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/bcc134331cb261e87f3d4f556489babe78370624.png" alt="R = \frac{(\mathit{V0} - I \cdot R_L)}{I}"/></p>
</div></div></blockquote>
<p>These previous transformations were supported by SIRENA in the past. Nevertheless, SIRENA at this time implements two transformations that can be accessed through the <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-5"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> command line option. The <em>I2R</em> transformation considers linearization as a linear scale in the height of the pulses with energy, while the <em>I2RFITTED</em> transformation is also able to get a linear gain scale when the signal is reconstructed with a simple filter.</p>
<p>Let’s see first some definitions given by columns and keywords in simulated data files to make the transformation to the (quasi) resistance space possible:</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">ADC</dt>
<dd class="field-odd"><p>Data signal in current space [adu (arbitrary data units)] (column)</p>
</dd>
</dl>
<p><em>Group 1</em>:</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">ADU_CNV</span></code></dt>
<dd class="field-odd"><p>ADU conversion factor [A/adu] (keyword)</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">I_BIAS</span></code></dt>
<dd class="field-even"><p>Bias current [A] (keyword)</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">ADU_BIAS</span></code></dt>
<dd class="field-odd"><p>Bias current [adu] (keyword)</p>
</dd>
</dl>
<p><em>Group 2</em>:</p>
<dl class="field-list simple">
<dt class="field-odd">I0_START</dt>
<dd class="field-odd"><p>Bias current [A] (column)</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">IMIN</span></code></dt>
<dd class="field-even"><p>Current corresponding to lowest adu value [A] (keyword)</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">IMAX</span></code></dt>
<dd class="field-odd"><p>Current corresponding to largest adu value [A] (keyword)</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<ul>
<li><p><strong>I2R</strong> transformation</p>
<blockquote>
<div><p>A linearization (in the sense of pulse height vs. energy) has been implemented in SIRENA.</p>
<p>If the <em>Group 1</em> info is available in the input FITS file:</p>
<blockquote>
<div><p><img class="math" src="_images/math/8b8f78254b5898bd03ee6ad091ab0038e5bb63f0.png" alt="\Delta I="/> <code class="docutils literal notranslate"><span class="pre">I_BIAS</span></code> + <code class="docutils literal notranslate"><span class="pre">ADU_CNV</span></code> * <img class="math" src="_images/math/c236b22636e73396c7e46890540f074740fdc9cc.png" alt="(\mathit{ADC}"/>-<code class="docutils literal notranslate"><span class="pre">ADU_BIAS</span></code><img class="math" src="_images/math/cbab1ec94bbe87773ec4f2267433e29a335ea105.png" alt=")"/></p>
<div class="math">
<p><img src="_images/math/c7fd01518865ea81550178928c03f158c5e7f7d1.png" alt="\frac{R}{R0} = \mathit{1} - \left(\frac{abs(\Delta I)/\mathit{I\_BIAS}}{1 + abs(\Delta I)/\mathit{I\_BIAS}}\right)"/></p>
</div></div></blockquote>
<p>If the <em>Group 1</em> info is not available in the input FITS file, the <em>Group 2</em> is used. In this case the ADU conversion factor must be calculated taking into account the number of quantification levels (65534):</p>
<blockquote>
<div><p><img class="math" src="_images/math/638fec6a2b9786d16ac9f620cd62fd046ab61fa8.png" alt="aducnv ="/> (<code class="docutils literal notranslate"><span class="pre">IMAX</span></code> - <code class="docutils literal notranslate"><span class="pre">IMIN</span></code>) / 65534</p>
<p><img class="math" src="_images/math/afd60a99c7f643fa1b80c04c025d2cdc811ebede.png" alt="I = ADC * aducnv"/> + <code class="docutils literal notranslate"><span class="pre">IMIN</span></code></p>
<p><img class="math" src="_images/math/703f80b0165258f418d07ab0c95ff789172a633f.png" alt="\Delta I= \mathit{I}"/> - <code class="docutils literal notranslate"><span class="pre">I0_START</span></code></p>
<div class="math">
<p><img src="_images/math/683df12221b146edb1737c2f72bc5ea6038df193.png" alt="\frac{R}{R0} = {\mathit{1} - \left(\frac{abs(\Delta I)/\mathit{I0\_START}}{1 + abs(\Delta I)/\mathit{I0\_START}}\right)}\cdot10^5"/></p>
</div></div></blockquote>
</div></blockquote>
</li>
<li><p><strong>I2RFITTED</strong> transformation</p>
<blockquote>
<div><p>Looking for a simple transformation that would produce also a linear gain scale, a new transformation <em>I2RFITTED</em> has been proposed in <a class="bibtex reference internal" href="zreferences.html#peille2016" id="id26">[Peille+16]</a>.</p>
<blockquote>
<div><div class="math">
<p><img src="_images/math/d6455a97dd29a4780fd62eccb0a1ed946027444a.png" alt="\frac{R}{V0} = -10^5\frac{1}{(I_{fit} + ADC)}"/></p>
</div></div></blockquote>
<p>The <img class="math" src="_images/math/fd0179dc927022f51d9a8abdb0acfd9f4e91f5ba.png" alt="I_{fit}"/> value is tunable for the moment as an input parameter.</p>
</div></blockquote>
</li>
</ul>
<p>The <img class="math" src="_images/math/1005d5cba0257915abbd43381cee3bfa5eda67e3.png" alt="10^5"/> scaling factor has been included in the quasi resistance space (both <strong>I2R</strong> and <strong>I2RFITTED</strong> transformations) to avoid rounding errors when working with very small numbers.</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div></div></blockquote>
</div></blockquote>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="two-experimental-approaches-adding-a-prebuffer-or-0-padding">
<span id="prebuffer-or-0-padding"></span><h4><span class="pageblue">Two experimental approaches: adding a preBuffer or 0-padding</span><a class="headerlink" href="#two-experimental-approaches-adding-a-prebuffer-or-0-padding" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>For pulses closer than the High Resolution length, short optimal filters in current or quasi-resistance space must be used in their reconstruction, causing a degradation of the energy resolution that must be studied <a class="bibtex reference internal" href="zreferences.html#doriese2009" id="id27">[Doriese+09]</a>. Two different experimental approaches (<strong>variant of Optimal Filtering by using the noise spectral density in current or quasi resistance space</strong>) have been developed to try to minimize this degradation:</p>
<p><strong>a) Adding a preBuffer:</strong></p>
<p>First, the addition of a few signal samples, <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-preBuffer"><code class="xref std std-option docutils literal notranslate"><span class="pre">preBuffer</span></code></a> (different from 0), before the triggering point to the pulses template that is used to build the optimal filter.</p>
<div class="figure align-center" id="id50">
<a class="reference internal image-reference" href="_images/preBuffer.png"><img alt="_images/preBuffer.png" src="_images/preBuffer.png" style="width: 227.7px; height: 166.2px;" /></a>
<p class="caption"><span class="caption-text">Adding a preBuffer as a variant of Optimal Filtering by using the noise spectral density in current or quasi resistance space</span><a class="headerlink" href="#id50" title="Permalink to this image">¶</a></p>
</div>
<p><strong>b) 0-padding:</strong></p>
<p>Second, instead of obtaining the energy through the scalar product of the short pulse and the corresponding short optimal filter (built with a reduced-length template), the full filter (built from a high resolution-long template) is always used, but it is padded with 0s after the short pulse length. If <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-PulseLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">PulseLength</span></code></a> &lt; <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLength"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLength</span></code></a>, 0-padding will be run.</p>
<div class="figure align-center" id="id51">
<a class="reference internal image-reference" href="_images/0-padding.png"><img alt="_images/0-padding.png" src="_images/0-padding.png" style="width: 227.7px; height: 166.5px;" /></a>
<p class="caption"><span class="caption-text">0-padding as a variant of Optimal Filtering by using the noise spectral density in current or quasi resistance space</span><a class="headerlink" href="#id51" title="Permalink to this image">¶</a></p>
</div>
</div></blockquote>
</div>
<div class="section" id="covariance-matrices">
<span id="covmatrices"></span><h4><span class="pageblue">Covariance matrices</span><a class="headerlink" href="#covariance-matrices" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>In real detectors, none of the above assumptions (linearity and stationary noise) is strictly correct, so a different approach is required in the presence of non-stationary noise along the signal event, which has to be optimal also when the detector is non-linear. In this method a set of calibration points constructed by many pulse repetitions (<img class="math" src="_images/math/9f17b8e511c575b4da169de10990e8bfbdc162ad.png" alt="S^i"/>), is defined at different energies <img class="math" src="_images/math/d271a4f6bba9ae479b0ba52235e9054d76189915.png" alt="(\alpha, \beta, ...)"/>. At these energy points, a pulse model (<strong>PULSEB0</strong> column in library) is obtained averaging the data pulses <img class="math" src="_images/math/617fa8f118553adb0d20466312e7bb84967d6bf6.png" alt="(M = &lt;S^i&gt;)"/>, and the deviations of these pulses from the data model <img class="math" src="_images/math/9e69a7ea6d7be6ba14c89c8e2403cd8086127d66.png" alt="(D^i = S^i - M^i)"/> are used to build a covariance matrix <img class="math" src="_images/math/ff5a9d405941a686ef7f9794abf5c2b5348c3db7.png" alt="V^{ij} = &lt;D^iD^j&gt;"/> (the weight matrix <img class="math" src="_images/math/1fbee781f84569077719a167b64e12064360fac1.png" alt="W"/>, inverse of the covariance matrix, is also calculated).  The non-stationary noise is better described by a full noise covariance matrix rather than a simpler Fourier transform <a class="bibtex reference internal" href="zreferences.html#fixsen2004" id="id28">[Fixsen+04]</a>.</p>
<p>An initial estimation of the energy of the unknown signal data is sufficient to determine the calibration points which straddle it. Then with a linear interpolation of the weight matrix and the signal, the best energy estimate is just a function of the energies of the embracing calibration points, the unknown signal and some other magnitudes that can be pre-calculated with the calibration data (see Eq. 2 in <a class="bibtex reference internal" href="zreferences.html#fixsen2004" id="id29">[Fixsen+04]</a>):</p>
<div class="math">
<p><img src="_images/math/9a5f4d67a866d8b038b7e01736a33dc7adcc900a.png" alt="E = E_{\alpha} + (E_{\beta}-E_{\alpha}) \frac{r}{3}\left((2DZ - 1) + \sqrt{(2DZ - 1)^2 + \frac{3(2DY - DXD)}{r}}\right)"/></p>
</div><p>where <img class="math" src="_images/math/7f4225a69bef32167bae6a94afa4f70aacdac4dc.png" alt="D = U - M_{\alpha}"/>, being <img class="math" src="_images/math/9098c1c4618d7a0f321cee441aabee7f1b57a19b.png" alt="U"/> the unknown data signal (<img class="math" src="_images/math/9098c1c4618d7a0f321cee441aabee7f1b57a19b.png" alt="U"/> and <img class="math" src="_images/math/e7900f35ed86fcfb251029a4a52f465402e339e8.png" alt="M_{\alpha}"/> are signals without baseline, i.e., we are assuming that the baseline is known or that the baseline is constant from calibration to the measurement time). Some of these terms are precalculated with calibration data and included in the <a class="reference internal" href="#library"><span class="std std-ref">library</span></a> to be read during the reconstruction process. In particular: <img class="math" src="_images/math/d4d86dfb30242fd6758f5b39abf973b3061dec64.png" alt="T = (S_{\beta} - S_{\alpha})"/>, <img class="math" src="_images/math/11a9883a7bb581142e7f5d0d453c3bbb5988f728.png" alt="t = TW_{\alpha}T"/>, <img class="math" src="_images/math/6d7aa4c452c82b6d4cccf4009047ebc9fd053e77.png" alt="X = (W_{\beta} - W_{\alpha})/t"/>, <img class="math" src="_images/math/528b25cf3c945ab8119578acf4ed664e45b92691.png" alt="Y = W_{\alpha}T/t"/>, <img class="math" src="_images/math/b2e77642f0e28a80e7075e3621b60604200c5735.png" alt="Z = XT"/> and <img class="math" src="_images/math/b4f8fcf344cc8a610483d782ee2dab11b1dc4262.png" alt="r = 1(ZT)"/>.</p>
<p>Energy reconstruction with <em>Covariance Matrices</em> is selected with input option <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-5"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>WEIGHT</strong>.</p>
</div></blockquote>
</div>
<div class="section" id="covariance-matrices-0-n">
<span id="weightn"></span><h4><span class="pageblue">Covariance matrices 0(n)</span><a class="headerlink" href="#covariance-matrices-0-n" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>A first order approximation can be used for the Covariance Matrices method from a first order expansion of the pulse expression at a given <em>t</em>:</p>
<div class="math">
<p><img src="_images/math/07092fe53bae68a534c6fef9c7bee690652c102b.png" alt="P(t,E) = S(t,E_{\alpha}) + b + \frac{(E-E_{\alpha})}{(E_{\beta}-E_{\alpha})}[S(t,E_{\beta})-S(t,E_{\alpha})]"/></p>
</div><p>where <img class="math" src="_images/math/68c7c8c65602677ab56cf7fd88002023f0edc575.png" alt="b"/> is the baseline level, and <img class="math" src="_images/math/06801b5aeb3da717683ff8c3cdb6ed9f370d5b1e.png" alt="S(t,E_{\alpha}), S(t,E_{\beta})"/> are pulse templates (column <strong>PULSEB0</strong> in the library) at the corresponding energies <img class="math" src="_images/math/b2ba959db58d56fc3434baf3fabe8f7a15561ef9.png" alt="E_{\alpha}, E_{\beta}"/> which embrace the unknown energy <img class="math" src="_images/math/1815f600df7845409443aed470eac2d449e4ddb0.png" alt="E"/>.</p>
<div class="math">
<p><img src="_images/math/8b133545933f4ddc1c358766a638112956ce5a69.png" alt="&amp; D(t)_{\alpha\beta} =  \frac{[S(t,E_{\beta})- S(t,E_{\alpha})]}{(E_{\beta}-E_{\alpha})} \\
&amp; P(t)_{\alpha\beta} = S(t,E_{\alpha}) - \frac{E_{\alpha}}{(E_{\beta}-E_{\alpha})}[S(t,E_{\beta})-S(t,E_{\alpha})] \\
&amp; P(t,E) - P(t)_{\alpha\beta} = E \cdot D(t)_{\alpha\beta} + b"/></p>
</div><p>resembles an equation of condition in matrix notation <img class="math" src="_images/math/ffe36b1b925d4a4d0e1f163014be4ada97b60c52.png" alt="Y = A\cdot X"/> that for a <img class="math" src="_images/math/1cbe49dd16598c0550b8a7477dd597e6bc04367e.png" alt="\chi^2"/> problem with the covariance matrices used as weights (<img class="math" src="_images/math/a80181eea76d340d4a7bc37754bebf63a7e6a71e.png" alt="W=V^{-1}"/>):</p>
<div class="math">
<p><img src="_images/math/147c15b787685900a3781c16d06c88cd9bdc5fc9.png" alt="X = \left[ \begin{array}{ccc} x_0 &amp; 1 \\ x_1 &amp; 1 \\ \vdots &amp; \vdots \\ x_m &amp; 1 \end{array} \right] =  \left[ \begin{array}{ccc} . &amp; 1 \\ D(t)_{\alpha\beta} &amp; 1 \\ . &amp; 1 \end{array} \right] , Y = \left[ \begin{array}{ccc} y_0 \\ y_1 \\ \vdots \\ y_m \end{array} \right] = \left[ \begin{array}{ccc} . \\ P(t,E)-P(t)_{\alpha\beta} \\ . \end{array} \right] , A = \left[ \begin{array}{ccc} E \\ b \end{array} \right]"/></p>
</div><div class="math">
<p><img src="_images/math/c024f9cd4ebab4b7f74e9bc8c16fe3ff80754e1b.png" alt="A = [X^T \cdot W \cdot X]^{-1} [X^T \cdot W \cdot Y]

E = e_1^T[X^T \cdot W \cdot X]^{-1} [X^T \cdot W \cdot Y]"/></p>
</div><p>where <img class="math" src="_images/math/a4073ca0c7fe9b49107908e56035021920ff7046.png" alt="e_1^T \equiv [1, 0]"/> is the unit vector to select only the term that corresponds to the energy (amplitude) of the pulse.</p>
<p>Energy reconstruction with <em>Covariance Matrices 0(n)</em> is selected with input option <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-5"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>WEIGHTN</strong>. If parameter <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-OFLib"><code class="xref std std-option docutils literal notranslate"><span class="pre">OFLib</span></code></a> = yes, some components can be used from the precalculated values at the <a class="reference internal" href="#library"><span class="std std-ref">libraryColumns</span></a> (<em>PRECALWN</em> HDU).</p>
</div></blockquote>
</div>
<div class="section" id="principal-component-analysis-pca">
<span id="pca"></span><h4><span class="pageblue">Principal Component Analysis (PCA)</span><a class="headerlink" href="#principal-component-analysis-pca" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>As the assumptions of the optimal filter technique (linearity and stationary noise) are not strictly correct and the covariance matrix methods are highly resource-demanding, energy reconstruction with <em>Principal Component Analysis</em> has been explored (<a class="bibtex reference internal" href="zreferences.html#busch2015" id="id30">[Busch+15]</a> and <a class="bibtex reference internal" href="zreferences.html#yan2016" id="id31">[Yan+16]</a>).</p>
<p>According to <a class="bibtex reference internal" href="zreferences.html#yan2016" id="id32">[Yan+16]</a>, taking a set of non piled-up pulses from the detector (<img class="math" src="_images/math/9124ce49bb007dd09267c9a3e7bbaec60f13273f.png" alt="n=1,...N"/>), each one sampled in time (<img class="math" src="_images/math/69a90e9b41736fa24651dd5ea2c4991cd17c838c.png" alt="t=1,...T"/>), a data matrix <img class="math" src="_images/math/ac25d8e092162f5a402ce5d304d1156f9224f4cf.png" alt="D_{T \times N}"/></p>
<div class="math">
<p><img src="_images/math/2387da7259b260357839df79ba1d8cf815b2fd1a.png" alt="D_{T \times N} = C_{T \times S} \cdot R_{S \times N}"/></p>
</div><p>can be represented through the basis set <img class="math" src="_images/math/7fffbac0d6b531f84e642bed41986cf23f2829e8.png" alt="C_{T \times S}"/> with <em>S</em> characteristics pulse shape factors. <img class="math" src="_images/math/ee665b30eb93954875cb10e554412729c0990da4.png" alt="R_{S \times N}"/> is the weigthing of members of this basis set.</p>
<p>The basis set <img class="math" src="_images/math/7fffbac0d6b531f84e642bed41986cf23f2829e8.png" alt="C_{T \times S}"/> can be calculated from the data time covariance <img class="math" src="_images/math/d1a0d531556e14307ce6c0420525d10876a71514.png" alt="[T \times T]"/> square matrix. Unlike the (residuals) <a class="reference internal" href="#covmatrices"><span class="std std-ref">covariance matrix</span></a> created for <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-5"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> = <strong>WEIGHT</strong> or <strong>WEIGHTN</strong>, the <em>pulseaverage</em> (i.e. model) is not subtracted in <a class="reference internal" href="SIRENAfunctions.html#_CPPv412weightMatrixP21ReconstructInitSIRENAbP16PulsesCollectionP16PulsesCollectionlP10gsl_vectorP10gsl_vectorPP10gsl_matrixPP10gsl_matrix" title="weightMatrix"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">weightMatrix()</span></code></a>.</p>
<p>Since this time covariance matrix is symetric, it can be represented it in terms of a set of eigenvectors <img class="math" src="_images/math/7fffbac0d6b531f84e642bed41986cf23f2829e8.png" alt="C_{T \times S}"/> (and eigenvalues weightings). The eigenvectors of the data covariance matrix are the principal components to characterise the information.</p>
<p>If a subset (<em>S’</em>) of eigenvectors can be found (finding patterns depending on the values of the eigenvalues), each pulse could be more compactly represented, not with all the time points <em>T</em> but in terms of just its <em>S’</em> weighting factors, i.e., the chosen eigenvectors. Once the matrix <img class="math" src="_images/math/f6e4b9280da843c01d01af7b368ea837bb122778.png" alt="C_{T \times S'}"/> has been determined and inverted, the weighting factors <img class="math" src="_images/math/cedee88cbfbf9714a3325a4e49144ad696d574e8.png" alt="R_{S' \times N}"/> of each pulse can be found by</p>
<div class="math">
<p><img src="_images/math/3f6f6ff2b093550fefd54dda084b0c7961e72382.png" alt="R_{S' \times N} = C_{T \times S'}^{-1} \cdot D_{T \times N}"/></p>
</div><p>If the matrix <img class="math" src="_images/math/7fffbac0d6b531f84e642bed41986cf23f2829e8.png" alt="C_{T \times S}"/> is constructed to have orthogonal vectors to ease matrix inversion, these eigenvectors could be sorted in order of decreasing statistical significance and a reduced basis set <img class="math" src="_images/math/f6e4b9280da843c01d01af7b368ea837bb122778.png" alt="C_{T \times S'}"/> could be easily separated from the full basis set <img class="math" src="_images/math/7fffbac0d6b531f84e642bed41986cf23f2829e8.png" alt="C_{T \times S}"/>. This reduced set <img class="math" src="_images/math/f6e4b9280da843c01d01af7b368ea837bb122778.png" alt="C_{T \times S'}"/> of eigenvectors can describe all the significant characteristic pulse shape components.</p>
<div class="math">
<p><img src="_images/math/e9aea074eb787c387b38232c242a4d7d32876cbe.png" alt="R_{S' \times N} = C_{T \times S'}^{-1} \cdot D_{T \times N} = C_{S' \times T}^{T} \cdot D_{T \times N}"/></p>
</div><p>A compressed (and noise-filtered) version of the original data can also then be generated:</p>
<div class="math">
<p><img src="_images/math/a60a8608844073fc988e8d18e1343a7d3b44d62c.png" alt="D'_{T \times N} = C_{T \times S'} \cdot R_{S' \times N}"/></p>
</div><p>The next step is understanding how to extract energy information from these 2D scatter plot. In <a class="bibtex reference internal" href="zreferences.html#yan2016" id="id33">[Yan+16]</a>, PCA method is applied to a real dataset with Mn <img class="math" src="_images/math/3868552e5c6228506fa8a94019a4a50b3bdde2ec.png" alt="K \alpha"/> and Mn <img class="math" src="_images/math/56dd29476a582193e4bc4acb373624a14f51b3e4.png" alt="K \beta"/> lines of the Fe-55 source and very different pulse shapes. In order to extract energy information, the weighting matrix <img class="math" src="_images/math/cedee88cbfbf9714a3325a4e49144ad696d574e8.png" alt="R_{S' \times N}"/>, restricted to <em>S’</em> =2 for simplicity, is examined (see their fig.4 below). Two clusters (elongated by the pulse shape variation) can be seen associated with the Mn <img class="math" src="_images/math/3868552e5c6228506fa8a94019a4a50b3bdde2ec.png" alt="K \alpha"/> (black) and Mn <img class="math" src="_images/math/56dd29476a582193e4bc4acb373624a14f51b3e4.png" alt="K \beta"/> (blue) lines. By fitting a line (red) to the Mn <img class="math" src="_images/math/3868552e5c6228506fa8a94019a4a50b3bdde2ec.png" alt="K \alpha"/> cluster, an axis is generated and used to rotate the 2D scatter plot of the weighting matrix so that the clusters are vertical. From the projection onto the X-axis, the energy histogram (right subfigure) is built and thus, the energy can be correlated to a linear combination of the first two PCA components.</p>
<div class="figure align-center" id="id52">
<a class="reference internal image-reference" href="_images/merge.png"><img alt="_images/merge.png" src="_images/merge.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text">Fig. 4 from <a class="bibtex reference internal" href="zreferences.html#yan2016" id="id34">[Yan+16]</a> showing the distribution of elements in the weighting matrix (left) and the energy histogram (right).</span><a class="headerlink" href="#id52" title="Permalink to this image">¶</a></p>
</div>
<p>In order to show more clearly how to follow the process, we have simulated (using <code class="docutils literal notranslate"><span class="pre">tessim</span></code>) a data set containing pulses of two different energies, 0.5 and 1 keV (ADC units), that we trim at <img class="math" src="_images/math/e86b2601271390d9a209b22a6eaa28f04c3628ab.png" alt="T=1024"/> samples. The first 50 eigenvalues of this dataset are shown in the left subfigure below. According to the eigenvalues, this dataset contains two primary eigenvectors (see the right subfigure below), giving essentially the averages of the pulse shapes (there are two different pulse shapes in the data for two different energies). Higher order eigenvevectors give corrections to these averages and noise correlations.</p>
<div class="figure align-center" id="id53">
<a class="reference internal image-reference" href="_images/eigen.png"><img alt="_images/eigen.png" src="_images/eigen.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text">Most significant eigenvalues (left) and eigenvectors (right) of a dataset containing pulses of two different energies (shapes), 0.5 and 1 keV (ADC units), and 1024 samples.</span><a class="headerlink" href="#id53" title="Permalink to this image">¶</a></p>
</div>
<p>The next subfigure on the left shows the distribution of elements from the weighting matrix <img class="math" src="_images/math/253b127b875e344f496699f752d41abcf0a508ce.png" alt="R_{S'=2 \times N}"/>, where components 1 and 2, respectively, are the weighting factors of the first and second eigenvectors. The right subfigure is simply a zoom showing only the 0.5 keV (ADC units) events.</p>
<div class="figure align-center" id="id54">
<a class="reference internal image-reference" href="_images/r2xn.png"><img alt="_images/r2xn.png" src="_images/r2xn.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text">Distribution of the events from the weighting matrix <img class="math" src="_images/math/253b127b875e344f496699f752d41abcf0a508ce.png" alt="R_{S'=2 \times N}"/> for <em>S’</em> =2 (left) and zoom of the left bottom cluster (right).</span><a class="headerlink" href="#id54" title="Permalink to this image">¶</a></p>
</div>
<p>In the next figure, the <img class="math" src="_images/math/d558cea506d7732938752a1e0ee2d43632c88a64.png" alt="\Delta E"/> line represents the direction of variable energies and the <img class="math" src="_images/math/9d36492909c19452c98e19f000f664b4abf5bee7.png" alt="ConstantE"/> line the perpendicular direction which is used to rotate the 2D scatter plot. From the projection onto the X-axis (clusters in red), the energy histograms are built. Since we know the energy difference in eV (the two energies are provided as input parameters <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-energyPCA1"><code class="xref std std-option docutils literal notranslate"><span class="pre">energyPCA1</span></code></a> and <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-energyPCA2"><code class="xref std std-option docutils literal notranslate"><span class="pre">energyPCA2</span></code></a>), it is possible to calculate a conversion factor between arbitrary units to eV.</p>
<div class="figure align-center" id="id55">
<a class="reference internal image-reference" href="_images/rsxnRotatedHistograms.png"><img alt="_images/rsxnRotatedHistograms.png" src="_images/rsxnRotatedHistograms.png" style="width: 90%;" /></a>
<p class="caption"><span class="caption-text"><img class="math" src="_images/math/d558cea506d7732938752a1e0ee2d43632c88a64.png" alt="\Delta E"/> and <img class="math" src="_images/math/9d36492909c19452c98e19f000f664b4abf5bee7.png" alt="ConstantE"/> lines to stablish the clusters rotation (left) and histograms of the two energies (center and right).</span><a class="headerlink" href="#id55" title="Permalink to this image">¶</a></p>
</div>
<p>PCA has not yet been implemented as a full-functionality <a class="reference internal" href="SIRENAcommandline.html#cmdoption-arg-5"><code class="xref std std-option docutils literal notranslate"><span class="pre">EnergyMethod</span></code></a> (only for testing and development purposes). For the time being, input FITS files to PCA method must have pulses of two different energies which must be provided as input parameters. If it would be necessary, future developments will be done in order to implement this approach in a real-time software.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="use-of-library-columns-in-the-different-reconstruction-methods">
<span id="libraryuse"></span><h3>Use of library columns in the different reconstruction methods<a class="headerlink" href="#use-of-library-columns-in-the-different-reconstruction-methods" title="Permalink to this headline">¶</a></h3>
<p><strong>1) Optimal filtering and NSD</strong></p>
<blockquote>
<div><div class="figure align-center">
<a class="reference internal image-reference" href="_images/OPTFILTNSD.png"><img alt="_images/OPTFILTNSD.png" src="_images/OPTFILTNSD.png" style="width: 90%;" /></a>
</div>
</div></blockquote>
<p><strong>2) Optimal filtering and WEIGHTM</strong></p>
<blockquote>
<div><div class="figure align-center">
<a class="reference internal image-reference" href="_images/OPTFILTWEIGHTM.png"><img alt="_images/OPTFILTWEIGHTM.png" src="_images/OPTFILTWEIGHTM.png" style="width: 40%;" /></a>
</div>
</div></blockquote>
<p><strong>3) Covariance matrices</strong></p>
<blockquote>
<div><div class="figure align-center">
<a class="reference internal image-reference" href="_images/WEIGHT.png"><img alt="_images/WEIGHT.png" src="_images/WEIGHT.png" style="width: 85%;" /></a>
</div>
</div></blockquote>
<p><strong>4) Covariance matrices O(n)</strong></p>
<blockquote>
<div><div class="figure align-center">
<a class="reference internal image-reference" href="_images/WEIGHTN.png"><img alt="_images/WEIGHTN.png" src="_images/WEIGHTN.png" style="width: 99%;" /></a>
</div>
</div></blockquote>
</div>
<div class="section" id="examples">
<span id="id35"></span><h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<p>In the <img class="math" src="_images/math/92de66f8b672e3fb14b85d1abef1022c5109c20e.png" alt="\mathit{sixte/scripts/SIRENA}"/> folder of the SIXTE environment, a straightforward SIRENA tutorial and a set of scripts can be found with the aim of providing the user with a first approach running SIRENA. Moreover, some examples to run SIRENA with different purposes are shown:</p>
<ol class="arabic simple">
<li><p>Full Energy reconstruction performed with the (F0) optimal filtering algorithm (filters calculated on-the-fly) in the current space (including detection) for the detector described in the XMLFile:</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="n">tesreconstruction</span> <span class="n">Recordfile</span><span class="o">=</span><span class="n">inputEvents</span><span class="o">.</span><span class="n">fits</span> <span class="n">TesEventFile</span><span class="o">=</span><span class="n">outputEvents</span><span class="o">.</span><span class="n">fits</span>
<span class="n">OFLib</span><span class="o">=</span><span class="n">no</span> <span class="n">OFStrategy</span><span class="o">=</span><span class="n">FREE</span> <span class="n">samplesUp</span><span class="o">=</span><span class="mi">3</span> <span class="n">nSgms</span><span class="o">=</span><span class="mf">3.5</span> <span class="n">samplesDown</span><span class="o">=</span><span class="mi">4</span>\
<span class="n">LibraryFile</span><span class="o">=</span><span class="n">libraryMultiE</span><span class="o">.</span><span class="n">fits</span> <span class="n">opmode</span><span class="o">=</span><span class="mi">1</span> <span class="n">NoiseFile</span><span class="o">=</span><span class="n">noise8192samplesADC</span><span class="o">.</span><span class="n">fits</span>\
<span class="n">FilterMethod</span><span class="o">=</span><span class="n">F0</span> <span class="n">clobber</span><span class="o">=</span><span class="n">yes</span> <span class="n">intermediate</span><span class="o">=</span><span class="mi">0</span> <span class="n">EnergyMethod</span><span class="o">=</span><span class="n">OPTFILT</span> \
<span class="n">XMLFile</span><span class="o">=</span><span class="n">xifu_detector_lpa_75um_AR0</span><span class="o">.</span><span class="mi">5</span><span class="n">_pixoffset_mux40_pitch275um</span><span class="o">.</span><span class="n">xml</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Energy reconstruction performed with the (F0) optimal filtering algorithm (filters extracted from the library) in the current space (known event position) for the detector described in the XMLFile:</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="n">tesreconstruction</span> <span class="n">Recordfile</span><span class="o">=</span><span class="n">inputEvents</span><span class="o">.</span><span class="n">fits</span> <span class="n">TesEventFile</span><span class="o">=</span><span class="n">outputEvents</span><span class="o">.</span><span class="n">fits</span> \
<span class="n">LibraryFile</span><span class="o">=</span><span class="n">libraryMultiE</span><span class="o">.</span><span class="n">fits</span> <span class="n">opmode</span><span class="o">=</span><span class="mi">1</span> <span class="n">OFLib</span><span class="o">=</span><span class="n">yes</span>\
<span class="n">FilterMethod</span><span class="o">=</span><span class="n">F0</span> <span class="n">clobber</span><span class="o">=</span><span class="n">yes</span> <span class="n">intermediate</span><span class="o">=</span><span class="mi">0</span> <span class="n">EnergyMethod</span><span class="o">=</span><span class="n">OPTFILT</span>\
<span class="n">XMLFile</span><span class="o">=</span><span class="n">xifu_detector_lpa_75um_AR0</span><span class="o">.</span><span class="mi">5</span><span class="n">_pixoffset_mux40_pitch275um</span><span class="o">.</span><span class="n">xml</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>Energy reconstruction performed with the Covariance matrices algorithm in the current space (known event position) for the detector described in the XMLFile:</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="n">tesreconstruction</span> <span class="n">Recordfile</span><span class="o">=</span><span class="n">inputEvents</span><span class="o">.</span><span class="n">fits</span> <span class="n">TesEventFile</span><span class="o">=</span><span class="n">outputEvents</span><span class="o">.</span><span class="n">fits</span>
<span class="n">LibraryFile</span><span class="o">=</span><span class="n">libraryMultiE</span><span class="o">.</span><span class="n">fits</span> <span class="n">opmode</span><span class="o">=</span><span class="mi">1</span> \
<span class="n">NoiseFile</span><span class="o">=</span><span class="n">noise1024samplesADC</span><span class="o">.</span><span class="n">fits</span> <span class="n">clobber</span><span class="o">=</span><span class="n">yes</span> <span class="n">intermediate</span><span class="o">=</span><span class="mi">0</span> \
<span class="n">EnergyMethod</span><span class="o">=</span><span class="n">WEIGHT</span> <span class="n">XMLFile</span><span class="o">=</span><span class="n">xifu_detector_lpa_75um_AR0</span><span class="o">.</span><span class="mi">5</span><span class="n">_pixoffset_mux40_pitch275um</span><span class="o">.</span><span class="n">xml</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li><p>Energy reconstruction performed with the (F0) optimal filtering algorithm in the <em>I2R</em> Resistance space (known event position) for the detector described in the XMLFile, with filters calculates for every event:</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="n">tesreconstruction</span> <span class="n">Recordfile</span><span class="o">=</span><span class="n">inputEvents</span><span class="o">.</span><span class="n">fits</span> <span class="n">TesEventFile</span><span class="o">=</span><span class="n">outputEvents</span><span class="o">.</span><span class="n">fits</span> \
<span class="n">LibraryFile</span><span class="o">=</span><span class="n">libraryMultiE</span><span class="o">.</span><span class="n">fits</span> <span class="n">opmode</span><span class="o">=</span><span class="mi">1</span> \
<span class="n">NoiseFile</span><span class="o">=</span><span class="n">noise8192samplesR</span><span class="o">.</span><span class="n">fits</span> <span class="n">FilterMethod</span><span class="o">=</span><span class="n">F0</span> <span class="n">clobber</span><span class="o">=</span><span class="n">yes</span> <span class="n">intermediate</span><span class="o">=</span><span class="mi">0</span> \
<span class="n">EnergyMethod</span><span class="o">=</span><span class="n">I2R</span> <span class="n">XMLFile</span><span class="o">=</span><span class="n">xifu_detector_hex_baseline</span><span class="o">.</span><span class="n">xml</span> <span class="n">OFLib</span><span class="o">=</span><span class="n">no</span> <span class="n">OFStrategy</span><span class="o">=</span><span class="n">FREE</span>
</pre></div>
</div>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="SIRENAcommandline.html" title="SIRENA Tools CLI"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="SIRENA documentation"
             >previous</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>

        <li class="nav-item nav-item-this"><a href="">SIRENA description</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Bea Cobo &amp; Maite Ceballos (IFCA).
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>